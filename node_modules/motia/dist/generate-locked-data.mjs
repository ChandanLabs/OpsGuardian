import { CompilationError } from "./utils/errors/compilation.error.mjs";
import { LockedDataGenerationError } from "./utils/errors/locked-data-generation.error.mjs";
import { LockedData, MemoryStreamAdapterManager, NoPrinter, Printer, getStepConfig, getStreamConfig } from "@motiadev/core";
import { randomUUID } from "crypto";
import { existsSync } from "fs";
import { globSync } from "glob";
import path from "path";
import pc from "picocolors";

//#region src/generate-locked-data.ts
const version = `${randomUUID()}:${Math.floor(Date.now() / 1e3)}`;
const getStepFilesFromDir = (dir) => {
	if (!existsSync(dir)) return [];
	return [...globSync("**/*.step.{ts,js,rb}", {
		absolute: true,
		cwd: dir
	}), ...globSync("**/*_step.{ts,js,py,rb}", {
		absolute: true,
		cwd: dir
	})];
};
const getStepFiles = (projectDir) => {
	const stepsDir = path.join(projectDir, "steps");
	const srcDir = path.join(projectDir, "src");
	return [...getStepFilesFromDir(stepsDir), ...getStepFilesFromDir(srcDir)];
};
const getStreamFilesFromDir = (dir) => {
	if (!existsSync(dir)) return [];
	return [...globSync("**/*.stream.{ts,js,rb}", {
		absolute: true,
		cwd: dir
	}), ...globSync("**/*_stream.{ts,js,py,rb}", {
		absolute: true,
		cwd: dir
	})];
};
const getStreamFiles = (projectDir) => {
	const stepsDir = path.join(projectDir, "steps");
	const srcDir = path.join(projectDir, "src");
	return [...getStreamFilesFromDir(stepsDir), ...getStreamFilesFromDir(srcDir)];
};
const collectFlows = async (projectDir, lockedData) => {
	const invalidSteps = [];
	const stepFiles = getStepFiles(projectDir);
	const streamFiles = getStreamFiles(projectDir);
	const stepsDir = path.join(projectDir, "steps");
	const srcDir = path.join(projectDir, "src");
	const deprecatedSteps = [...existsSync(stepsDir) ? globSync("**/*.step.py", {
		absolute: true,
		cwd: stepsDir
	}) : [], ...existsSync(srcDir) ? globSync("**/*.step.py", {
		absolute: true,
		cwd: srcDir
	}) : []];
	for (const filePath of stepFiles) try {
		const config = await getStepConfig(filePath, projectDir);
		if (!config) {
			console.warn(`No config found in step ${filePath}, step skipped`);
			continue;
		}
		if (!lockedData.createStep({
			filePath,
			version,
			config
		}, { disableTypeCreation: true })) invalidSteps.push({
			filePath,
			version,
			config
		});
	} catch (err) {
		const errorMessage = err instanceof Error ? err.message : String(err);
		if (errorMessage.includes("Executable ruby not found") || errorMessage.includes("Executable python not found")) {
			console.warn(pc.yellow(`! [WARNING] Skipping step ${filePath}: ${errorMessage}`));
			continue;
		}
		throw new CompilationError(`Error collecting flow ${filePath}`, path.relative(projectDir, filePath), err);
	}
	for (const filePath of streamFiles) {
		const config = await getStreamConfig(filePath);
		if (!config) {
			console.warn(`No config found in stream ${filePath}, stream skipped`);
			continue;
		}
		lockedData.createStream({
			filePath,
			config
		}, { disableTypeCreation: true });
	}
	if (deprecatedSteps.length > 0) {
		const warning = pc.yellow("! [WARNING]");
		console.warn(pc.yellow([
			"",
			"========================================",
			warning,
			"",
			`Python steps with ${pc.gray(".step.py")} extensions are no longer supported.`,
			`Please rename them to ${pc.gray("_step.py")}.`,
			"",
			pc.bold("Steps:"),
			...deprecatedSteps.map((step) => pc.reset(`- ${pc.cyan(pc.bold(step.replace(projectDir, "")))} rename to ${pc.gray(`${step.replace(projectDir, "").replace(".step.py", "_step.py")}`)}`)),
			"",
			"Make sure the step names are importable from Python:",
			`- Don't use numbers, dots, dashes, commas, spaces, colons, or special characters`,
			"========================================",
			""
		].join("\n")));
	}
	return invalidSteps;
};
const generateLockedData = async (config) => {
	try {
		const { projectDir, streamAdapter = new MemoryStreamAdapterManager(), printerType = "default", redisClient, streamAuth } = config;
		const lockedData = new LockedData(projectDir, streamAdapter, printerType === "disabled" ? new NoPrinter() : new Printer(projectDir), redisClient);
		lockedData.setStreamAuthConfig(streamAuth);
		await collectFlows(projectDir, lockedData);
		lockedData.saveTypes();
		return lockedData;
	} catch (error) {
		console.error(error);
		throw new LockedDataGenerationError("Failed to parse the project, generating locked data step failed", error);
	}
};

//#endregion
export { collectFlows, generateLockedData, getStepFiles, getStreamFiles };
//# sourceMappingURL=generate-locked-data.mjs.map