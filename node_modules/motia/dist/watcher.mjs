import { getStepConfig, getStreamConfig, invalidate } from "@motiadev/core";
import { randomUUID } from "crypto";
import chokidar from "chokidar";

//#region src/watcher.ts
var Watcher = class {
	constructor(dir, lockedData) {
		this.dir = dir;
		this.lockedData = lockedData;
	}
	onStepChange(handler) {
		this.stepChangeHandler = handler;
	}
	onStepCreate(handler) {
		this.stepCreateHandler = handler;
	}
	onStepDelete(handler) {
		this.stepDeleteHandler = handler;
	}
	onStreamChange(handler) {
		this.streamChangeHandler = handler;
	}
	onStreamCreate(handler) {
		this.streamCreateHandler = handler;
	}
	onStreamDelete(handler) {
		this.streamDeleteHandler = handler;
	}
	findStep(path) {
		return this.lockedData.activeSteps.find((step) => step.filePath === path) || this.lockedData.devSteps.find((step) => step.filePath === path);
	}
	async onStepFileAdd(path) {
		if (!this.stepCreateHandler) {
			console.warn(`No step create handler, step skipped`);
			return;
		}
		const config = await getStepConfig(path, this.lockedData.baseDir).catch((err) => console.error(err));
		if (!config) return;
		const step = {
			filePath: path,
			version: `${randomUUID()}:${Math.floor(Date.now() / 1e3)}`,
			config
		};
		this.stepCreateHandler?.(step);
	}
	async onStepFileChange(path) {
		if (path.endsWith(".ts")) invalidate(path);
		const config = await getStepConfig(path, this.lockedData.baseDir).catch((err) => {
			console.error(err);
		});
		const step = this.findStep(path);
		if (!step && !config) return;
		if (!step && config) {
			const step$1 = {
				filePath: path,
				version: `${randomUUID()}:${Math.floor(Date.now() / 1e3)}`,
				config
			};
			this.stepCreateHandler?.(step$1);
		}
		if (step && config) {
			const newStep = {
				...step,
				config
			};
			this.stepChangeHandler?.(step, newStep);
		}
		if (step && !config) this.stepDeleteHandler?.(step);
	}
	async onStepFileDelete(path) {
		if (path.endsWith(".ts")) invalidate(path);
		const step = this.findStep(path);
		if (!step) {
			console.warn(`Step ${path} not found, step skipped`);
			return;
		}
		this.stepDeleteHandler?.(step);
	}
	async onStreamFileAdd(path) {
		const config = await getStreamConfig(path).catch((err) => console.error(err));
		if (!config) return;
		this.streamCreateHandler?.({
			filePath: path,
			config,
			factory: null
		});
	}
	async onStreamFileChange(path) {
		const stream = this.lockedData.findStream(path);
		const config = await getStreamConfig(path).catch((err) => console.error(err));
		if (!stream && config) this.streamCreateHandler?.({
			filePath: path,
			config,
			factory: null
		});
		else if (stream && config) this.streamChangeHandler?.(stream, {
			filePath: path,
			config,
			factory: null
		});
		else if (stream && !config) this.streamDeleteHandler?.(stream);
	}
	async onStreamFileDelete(path) {
		const stream = this.lockedData.findStream(path);
		if (this.streamDeleteHandler && stream) this.streamDeleteHandler(stream);
	}
	async onFileAdd(path) {
		if (this.isStepFile(path)) this.onStepFileAdd(path);
		else if (this.isStreamFile(path)) this.onStreamFileAdd(path);
	}
	async onFileChange(path) {
		if (this.isStepFile(path)) this.onStepFileChange(path);
		else if (this.isStreamFile(path)) this.onStreamFileChange(path);
	}
	async onFileDelete(path) {
		if (this.isStepFile(path)) this.onStepFileDelete(path);
		else if (this.isStreamFile(path)) this.onStreamFileDelete(path);
	}
	init() {
		this.watcher = chokidar.watch(this.dir, {
			persistent: true,
			ignoreInitial: true
		}).on("add", (path) => this.onFileAdd(path)).on("change", (path) => this.onFileChange(path)).on("unlink", (path) => this.onFileDelete(path));
	}
	isStepFile(path) {
		const isUiNode = /\.(tsx|jsx)$/.test(path);
		const isDeprecatedPythonStep = /\.step\.py$/.test(path);
		return /[._]step\.((ts)|(js)|(rb)|(py))$/.test(path) && !isUiNode && !isDeprecatedPythonStep;
	}
	isStreamFile(path) {
		const isUiNode = /\.(tsx|jsx)$/.test(path);
		const isDeprecatedPythonStream = /\.stream\.py$/.test(path);
		return /[._]stream\.((ts)|(js)|(rb)|(py))$/.test(path) && !isUiNode && !isDeprecatedPythonStream;
	}
	async stop() {
		if (this.watcher) await this.watcher.close();
	}
};

//#endregion
export { Watcher };
//# sourceMappingURL=watcher.mjs.map