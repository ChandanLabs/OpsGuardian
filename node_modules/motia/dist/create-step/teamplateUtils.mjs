import { promises } from "fs";
import path from "path";
import { fileURLToPath } from "url";

//#region src/create-step/teamplateUtils.ts
/**
* Reads a template file and replaces variables
*/
async function readTemplate(templatePath, answers) {
	return replaceTemplateVariables(await promises.readFile(templatePath, "utf8"), answers);
}
/**
* Replaces template variables with actual values
*/
function replaceTemplateVariables(content, answers) {
	const replacements = {
		STEP_NAME: answers.name,
		DESCRIPTION: answers.description || "",
		FLOWS: JSON.stringify(answers.flows),
		EMITS: JSON.stringify(answers.emits),
		METHOD: answers.method || "",
		PATH: answers.path || "",
		SUBSCRIPTIONS: JSON.stringify(answers.subscriptions || []),
		CRON_EXPRESSION: answers.cronExpression || "",
		VIRTUAL_EMITS: JSON.stringify(answers.virtualEmits || []),
		VIRTUAL_SUBSCRIBES: JSON.stringify(answers.virtualSubscribes || [])
	};
	return Object.entries(replacements).reduce((content$1, [key, value]) => {
		const regex = new RegExp(`\\{\\{${key}\\}\\}`, "g");
		return content$1.replace(regex, String(value));
	}, content);
}
/**
* Generates the appropriate template based on language and type
*/
const __dirname = path.dirname(fileURLToPath(import.meta.url));
async function generateTemplate(answers) {
	const templateDir = path.join(__dirname, "templates", answers.type);
	const templateFile = `template.${answers.language}.txt`;
	const templatePath = path.join(templateDir, templateFile);
	try {
		return await readTemplate(templatePath, answers);
	} catch (error) {
		throw new Error(`Failed to generate template: ${error}`);
	}
}

//#endregion
export { generateTemplate };
//# sourceMappingURL=teamplateUtils.mjs.map