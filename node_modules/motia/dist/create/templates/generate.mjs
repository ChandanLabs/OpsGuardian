import { version } from "../../version.mjs";
import { constants, mkdirSync, promises, statSync } from "fs";
import { globSync } from "glob";
import * as path$1 from "path";
import { fileURLToPath } from "url";

//#region src/create/templates/generate.ts
const replaceTemplateVariables = (content, projectName, version$1) => {
	const replacements = {
		"{{PROJECT_NAME}}": projectName,
		"{{PLUGIN_NAME}}": toPascalCase(projectName),
		"{{VERSION}}": version$1 || "latest"
	};
	return Object.entries(replacements).reduce((result, [key, value]) => {
		return result.replace(new RegExp(key, "g"), value);
	}, content);
};
const toPascalCase = (str) => {
	return str.replace(/^@[^/]+\//, "").split(/[-_]/).map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join("");
};
const __dirname = path$1.dirname(fileURLToPath(import.meta.url));
const generateTemplateSteps = (templateFolder) => {
	return async (rootDir, context) => {
		const templatePath = path$1.join(__dirname, templateFolder);
		const files = globSync("**/*", {
			absolute: false,
			cwd: templatePath,
			dot: true
		});
		const projectName = path$1.basename(rootDir);
		try {
			for (const fileName of files) {
				const filePath = path$1.join(templatePath, fileName);
				const targetFilePath = path$1.join(rootDir, fileName);
				mkdirSync(path$1.dirname(targetFilePath), { recursive: true });
				if (statSync(filePath).isDirectory()) {
					const folderPath = filePath.replace(templatePath, "");
					mkdirSync(path$1.join(rootDir, folderPath), { recursive: true });
					continue;
				}
				const sanitizedFileName = fileName === "requirements.txt" ? fileName : fileName.replace(".txt", "");
				const isWorkbenchConfig = fileName.match("motia-workbench.json");
				const generateFilePath = path$1.join(rootDir, sanitizedFileName);
				let content = await promises.readFile(filePath, "utf8");
				if (isWorkbenchConfig) try {
					let fd$1 = null;
					try {
						fd$1 = await promises.open(generateFilePath, constants.O_RDONLY);
						const existingWorkbenchConfig = await fd$1.readFile("utf8");
						const workbenchContent = JSON.parse(content);
						content = JSON.stringify([...JSON.parse(existingWorkbenchConfig), ...workbenchContent], null, 2);
						context.log("workbench-config-updated", (message) => message.tag("success").append("Workbench config").append("has been updated."));
					} finally {
						if (fd$1) await fd$1.close();
					}
				} catch {}
				else content = replaceTemplateVariables(content, projectName);
				let fd = null;
				try {
					fd = await promises.open(generateFilePath, constants.O_CREAT | constants.O_WRONLY | constants.O_TRUNC, 420);
					await fd.writeFile(content, "utf8");
				} finally {
					if (fd) await fd.close();
				}
				context.log(sanitizedFileName, (message) => {
					message.tag("success").append("File").append(sanitizedFileName, "cyan").append("has been created.");
				});
			}
		} catch (error) {
			console.error("Error generating template files:", error);
		}
	};
};
const generatePluginTemplate = (templateFolder) => {
	return async (rootDir, context) => {
		const templatePath = path$1.join(__dirname, templateFolder);
		const files = globSync("**/*", {
			absolute: false,
			cwd: templatePath,
			dot: true
		});
		const projectName = path$1.basename(rootDir);
		try {
			for (const fileName of files) {
				const filePath = path$1.join(templatePath, fileName);
				const targetFilePath = path$1.join(rootDir, fileName);
				mkdirSync(path$1.dirname(targetFilePath), { recursive: true });
				if (statSync(filePath).isDirectory()) {
					const folderPath = filePath.replace(templatePath, "");
					mkdirSync(path$1.join(rootDir, folderPath), { recursive: true });
					continue;
				}
				const sanitizedFileName = fileName.replace(".txt", "");
				const generateFilePath = path$1.join(rootDir, sanitizedFileName);
				let content = await promises.readFile(filePath, "utf8");
				content = replaceTemplateVariables(content, projectName, version);
				let fd = null;
				try {
					fd = await promises.open(generateFilePath, constants.O_CREAT | constants.O_WRONLY | constants.O_TRUNC, 420);
					await fd.writeFile(content, "utf8");
				} finally {
					if (fd) await fd.close();
				}
				context.log(sanitizedFileName, (message) => {
					message.tag("success").append("File").append(sanitizedFileName, "cyan").append("has been created.");
				});
			}
		} catch (error) {
			console.error("Error generating template files:", error);
		}
	};
};

//#endregion
export { generatePluginTemplate, generateTemplateSteps };
//# sourceMappingURL=generate.mjs.map