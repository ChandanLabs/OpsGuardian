import pc from "picocolors";
import readline from "readline";
import { table } from "table";

//#region src/cloud/cli-output-manager.ts
const progress = pc.yellow("➜ [PROGRESS]");
const tags = {
	success: pc.green("✓ [SUCCESS]"),
	failed: pc.red("✘ [ERROR]"),
	progress,
	warning: pc.yellow("! [WARNING]"),
	info: pc.blue("i [INFO]")
};
const colorTags = {
	gray: pc.gray,
	dark: pc.magenta,
	red: pc.red,
	green: pc.green,
	yellow: pc.yellow,
	blue: pc.blue,
	magenta: pc.magenta,
	cyan: pc.cyan,
	white: pc.white
};
var Message = class {
	constructor() {
		this.output = [];
	}
	dark(message) {
		return pc.magenta(message);
	}
	text(message) {
		this.output.push(message);
		return this;
	}
	tag(tag) {
		this.output.push(tags[tag]);
		return this;
	}
	append(message, color) {
		if (color) this.output.push(colorTags[color](message));
		else this.output.push(message);
		return this;
	}
	box(messages, color = "blue") {
		const message = messages.join("\n \n");
		const lines = message.match(/.{1,40}/g) || [message];
		const width = Math.min(40, Math.max(...lines.map((line) => line.length)));
		const border = "─".repeat(width + 2);
		const borderColor = colorTags[color];
		this.output.push(borderColor("\n ┌" + border + "┐\n"));
		lines.forEach((line) => {
			const padding = " ".repeat(width - line.trim().length);
			this.output.push(borderColor("│ ") + line.trim() + padding + borderColor(" │\n"));
		});
		this.output.push(borderColor("└" + border + "┘"));
		return this;
	}
	table(headers, rows) {
		const records = [headers?.map((header) => pc.blue(pc.bold(header))), ...rows].filter((record) => record !== void 0);
		this.output.push(table(records, { border: {
			topBody: pc.blue("─"),
			topJoin: pc.blue("┬"),
			topLeft: pc.blue("┌"),
			topRight: pc.blue("┐"),
			bodyLeft: pc.blue("│"),
			bodyRight: pc.blue("│"),
			bottomBody: pc.blue("─"),
			bottomJoin: pc.blue("┴"),
			bottomLeft: pc.blue("└"),
			bottomRight: pc.blue("┘"),
			joinLeft: pc.blue("├"),
			joinRight: pc.blue("┤"),
			joinMiddleDown: pc.blue("│"),
			joinMiddleUp: pc.blue(""),
			joinMiddleLeft: pc.blue("│"),
			joinMiddleRight: pc.blue("│"),
			bodyJoin: pc.blue("│"),
			joinBody: pc.blue("─"),
			headerJoin: pc.blue("│"),
			joinJoin: pc.blue("┼")
		} }));
		return this;
	}
	toString() {
		return this.output.join(" ");
	}
};
var CLIOutputManager = class {
	constructor() {
		this.lines = /* @__PURE__ */ new Map();
		this.lineCount = 0;
	}
	log(id, callback) {
		const lineIndex = this.lines.get(id);
		if (lineIndex === void 0) {
			const msg$1 = this.createMessage();
			callback(msg$1);
			this.lines.set(id, this.lineCount);
			process.stdout.write(`${msg$1.toString()}\n`);
			this.lineCount++;
			return;
		}
		const msg = this.createMessage();
		callback(msg);
		readline.moveCursor(process.stdout, 0, -(this.lineCount - lineIndex));
		readline.clearLine(process.stdout, 0);
		process.stdout.write(`${msg.toString()}\n`);
		readline.moveCursor(process.stdout, 0, this.lineCount - lineIndex - 1);
	}
	createMessage() {
		return new Message();
	}
};

//#endregion
export { CLIOutputManager };
//# sourceMappingURL=cli-output-manager.mjs.map