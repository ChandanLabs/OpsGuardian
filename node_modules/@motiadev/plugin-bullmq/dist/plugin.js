import IORedis from "ioredis";
import { StreamAdapter } from "@motiadev/core";
import { Queue, QueueEvents } from "bullmq";

//#region src/streams/queues-stream.ts
const queues = /* @__PURE__ */ new Map();
const queueEvents = /* @__PURE__ */ new Map();
const getOrCreateQueue = (name, connection, prefix) => {
	const existing = queues.get(name);
	if (existing) return existing;
	const queue = new Queue(name, {
		connection,
		prefix
	});
	queues.set(name, queue);
	return queue;
};
const discoverQueueNames = async (connection, prefix) => {
	const pattern = `${prefix}:*:id`;
	const keys = await connection.keys(pattern);
	const queueNames = /* @__PURE__ */ new Set();
	for (const key of keys) {
		const withoutId = key.slice(prefix.length + 1).slice(0, -3);
		queueNames.add(withoutId);
	}
	return queueNames;
};
const getQueueInfo = async (name, connection, prefix, dlqSuffix) => {
	const queue = getOrCreateQueue(name, connection, prefix);
	const [isPaused, counts] = await Promise.all([queue.isPaused(), queue.getJobCounts()]);
	return {
		name,
		displayName: name,
		isPaused,
		isDLQ: name.endsWith(dlqSuffix),
		stats: {
			waiting: counts.waiting || 0,
			active: counts.active || 0,
			completed: counts.completed || 0,
			failed: counts.failed || 0,
			delayed: counts.delayed || 0,
			paused: counts.paused || 0,
			prioritized: counts.prioritized || 0
		}
	};
};
const DEBOUNCE_MS = 500;
var QueuesStream = class extends StreamAdapter {
	constructor(connection, prefix, dlqSuffix) {
		super("__motia.bullmq-queues");
		this.knownQueues = /* @__PURE__ */ new Set();
		this.lastStatsCache = /* @__PURE__ */ new Map();
		this.debounceTimers = /* @__PURE__ */ new Map();
		this.connection = connection;
		this.prefix = prefix;
		this.dlqSuffix = dlqSuffix;
	}
	setUpdateCallback(callback) {
		this.onQueueUpdate = callback;
	}
	async get(_groupId, id) {
		try {
			const info = await getQueueInfo(id, this.connection, this.prefix, this.dlqSuffix);
			return {
				...info,
				id: info.name
			};
		} catch {
			return null;
		}
	}
	async set(_groupId, _id, data) {
		return data;
	}
	async delete(_groupId, id) {
		this.knownQueues.delete(id);
		this.lastStatsCache.delete(id);
		return { id };
	}
	async getGroup(_groupId) {
		const queueNames = await discoverQueueNames(this.connection, this.prefix);
		const queueInfos = [];
		for (const name of queueNames) {
			this.knownQueues.add(name);
			const info = await getQueueInfo(name, this.connection, this.prefix, this.dlqSuffix);
			const streamInfo = {
				...info,
				id: info.name
			};
			queueInfos.push(streamInfo);
			this.lastStatsCache.set(name, JSON.stringify({
				stats: info.stats,
				isPaused: info.isPaused
			}));
		}
		return queueInfos;
	}
	async refreshQueue(name) {
		const info = await getQueueInfo(name, this.connection, this.prefix, this.dlqSuffix);
		const streamInfo = {
			...info,
			id: info.name
		};
		this.knownQueues.add(name);
		const newStatsKey = JSON.stringify({
			stats: info.stats,
			isPaused: info.isPaused
		});
		if (this.lastStatsCache.get(name) !== newStatsKey) {
			this.lastStatsCache.set(name, newStatsKey);
			this.onQueueUpdate?.(streamInfo);
		}
		return streamInfo;
	}
	debouncedRefresh(queueName) {
		const existing = this.debounceTimers.get(queueName);
		if (existing) clearTimeout(existing);
		const timer = setTimeout(() => {
			this.debounceTimers.delete(queueName);
			this.refreshQueue(queueName);
		}, DEBOUNCE_MS);
		this.debounceTimers.set(queueName, timer);
	}
	setupQueueEvents(queueName) {
		if (queueEvents.has(queueName)) return;
		const events = new QueueEvents(queueName, {
			connection: this.connection,
			prefix: this.prefix
		});
		const refreshOnEvent = () => {
			this.debouncedRefresh(queueName);
		};
		events.on("waiting", refreshOnEvent);
		events.on("active", refreshOnEvent);
		events.on("completed", refreshOnEvent);
		events.on("failed", refreshOnEvent);
		events.on("delayed", refreshOnEvent);
		events.on("removed", refreshOnEvent);
	}
	async setupAllQueueEvents() {
		const queueNames = await discoverQueueNames(this.connection, this.prefix);
		for (const name of queueNames) this.setupQueueEvents(name);
	}
	async closeAllQueueEvents() {
		for (const timer of this.debounceTimers.values()) clearTimeout(timer);
		this.debounceTimers.clear();
		for (const [, events] of queueEvents) await events.close();
		queueEvents.clear();
	}
	getKnownQueues() {
		return this.knownQueues;
	}
};

//#endregion
//#region src/api.ts
const discoverQueues = async (connection, prefix, dlqSuffix) => {
	const queueNames = await discoverQueueNames(connection, prefix);
	const queueInfos = [];
	for (const name of queueNames) {
		const info = await getQueueInfo(name, connection, prefix, dlqSuffix);
		queueInfos.push(info);
	}
	return queueInfos;
};
const api = ({ registerApi }, prefix, dlqSuffix, connection) => {
	registerApi({
		method: "GET",
		path: "/__motia/bullmq/queues"
	}, async () => {
		try {
			return {
				status: 200,
				body: { queues: await discoverQueues(connection, prefix, dlqSuffix) }
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "GET",
		path: "/__motia/bullmq/queues/:name"
	}, async (req) => {
		try {
			const name = req.pathParams.name;
			const queue = getOrCreateQueue(name, connection, prefix);
			const [isPaused, counts] = await Promise.all([queue.isPaused(), queue.getJobCounts()]);
			return {
				status: 200,
				body: {
					name,
					displayName: name,
					isPaused,
					isDLQ: name.endsWith(dlqSuffix),
					stats: {
						waiting: counts.waiting || 0,
						active: counts.active || 0,
						completed: counts.completed || 0,
						failed: counts.failed || 0,
						delayed: counts.delayed || 0,
						paused: counts.paused || 0,
						prioritized: counts.prioritized || 0
					}
				}
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "POST",
		path: "/__motia/bullmq/queues/:name/pause"
	}, async (req) => {
		try {
			const name = req.pathParams.name;
			await getOrCreateQueue(name, connection, prefix).pause();
			return {
				status: 200,
				body: { message: "Queue paused" }
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "POST",
		path: "/__motia/bullmq/queues/:name/resume"
	}, async (req) => {
		try {
			const name = req.pathParams.name;
			await getOrCreateQueue(name, connection, prefix).resume();
			return {
				status: 200,
				body: { message: "Queue resumed" }
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "POST",
		path: "/__motia/bullmq/queues/:name/clean"
	}, async (req) => {
		try {
			const name = req.pathParams.name;
			const body = req.body;
			const options = {
				grace: body.grace ?? 0,
				limit: body.limit ?? 1e3,
				status: body.status ?? "completed"
			};
			const deletedIds = await getOrCreateQueue(name, connection, prefix).clean(options.grace, options.limit, options.status);
			return {
				status: 200,
				body: {
					deleted: deletedIds.length,
					ids: deletedIds
				}
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "POST",
		path: "/__motia/bullmq/queues/:name/drain"
	}, async (req) => {
		try {
			const name = req.pathParams.name;
			await getOrCreateQueue(name, connection, prefix).drain();
			return {
				status: 200,
				body: { message: "Queue drained" }
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "GET",
		path: "/__motia/bullmq/queues/:name/jobs"
	}, async (req) => {
		try {
			const name = req.pathParams.name;
			const status = req.queryParams.status || "waiting";
			const start = parseInt(req.queryParams.start, 10) || 0;
			const end = parseInt(req.queryParams.end, 10) || 100;
			return {
				status: 200,
				body: { jobs: (await getOrCreateQueue(name, connection, prefix).getJobs([status], start, end)).map((job) => ({
					id: job.id || "",
					name: job.name,
					data: job.data,
					opts: job.opts,
					progress: typeof job.progress === "object" ? JSON.stringify(job.progress) : job.progress,
					timestamp: job.timestamp,
					attemptsMade: job.attemptsMade,
					processedOn: job.processedOn,
					finishedOn: job.finishedOn,
					returnvalue: job.returnvalue,
					failedReason: job.failedReason,
					stacktrace: job.stacktrace
				})) }
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "GET",
		path: "/__motia/bullmq/queues/:queueName/jobs/:jobId"
	}, async (req) => {
		try {
			const queueName = req.pathParams.queueName;
			const jobId = req.pathParams.jobId;
			const job = await getOrCreateQueue(queueName, connection, prefix).getJob(jobId);
			if (!job) return {
				status: 404,
				body: { error: "Job not found" }
			};
			return {
				status: 200,
				body: {
					id: job.id || "",
					name: job.name,
					data: job.data,
					opts: job.opts,
					progress: typeof job.progress === "object" ? JSON.stringify(job.progress) : job.progress,
					timestamp: job.timestamp,
					attemptsMade: job.attemptsMade,
					processedOn: job.processedOn,
					finishedOn: job.finishedOn,
					returnvalue: job.returnvalue,
					failedReason: job.failedReason,
					stacktrace: job.stacktrace
				}
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "POST",
		path: "/__motia/bullmq/queues/:queueName/jobs/:jobId/retry"
	}, async (req) => {
		try {
			const queueName = req.pathParams.queueName;
			const jobId = req.pathParams.jobId;
			const job = await getOrCreateQueue(queueName, connection, prefix).getJob(jobId);
			if (!job) return {
				status: 404,
				body: { error: "Job not found" }
			};
			await job.retry();
			return {
				status: 200,
				body: { message: "Job retried" }
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "POST",
		path: "/__motia/bullmq/queues/:queueName/jobs/:jobId/remove"
	}, async (req) => {
		try {
			const queueName = req.pathParams.queueName;
			const jobId = req.pathParams.jobId;
			const job = await getOrCreateQueue(queueName, connection, prefix).getJob(jobId);
			if (!job) return {
				status: 404,
				body: { error: "Job not found" }
			};
			await job.remove();
			return {
				status: 200,
				body: { message: "Job removed" }
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "POST",
		path: "/__motia/bullmq/queues/:queueName/jobs/:jobId/promote"
	}, async (req) => {
		try {
			const queueName = req.pathParams.queueName;
			const jobId = req.pathParams.jobId;
			const job = await getOrCreateQueue(queueName, connection, prefix).getJob(jobId);
			if (!job) return {
				status: 404,
				body: { error: "Job not found" }
			};
			await job.promote();
			return {
				status: 200,
				body: { message: "Job promoted" }
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "GET",
		path: "/__motia/bullmq/dlq/:name/jobs"
	}, async (req) => {
		try {
			const name = req.pathParams.name;
			const start = parseInt(req.queryParams.start, 10) || 0;
			const end = parseInt(req.queryParams.end, 10) || 100;
			return {
				status: 200,
				body: { jobs: (await getOrCreateQueue(name.endsWith(dlqSuffix) ? name : `${name}${dlqSuffix}`, connection, prefix).getJobs(["waiting", "completed"], start, end)).map((job) => ({
					id: job.id || "",
					name: job.name,
					data: job.data,
					timestamp: job.timestamp,
					originalEvent: job.data?.originalEvent,
					failureReason: job.data?.failureReason || job.failedReason,
					failureTimestamp: job.data?.failureTimestamp || job.finishedOn,
					attemptsMade: job.data?.attemptsMade || job.attemptsMade
				})) }
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "POST",
		path: "/__motia/bullmq/dlq/:name/retry/:jobId"
	}, async (req) => {
		try {
			const name = req.pathParams.name;
			const jobId = req.pathParams.jobId;
			const dlqName = name.endsWith(dlqSuffix) ? name : `${name}${dlqSuffix}`;
			const job = await getOrCreateQueue(dlqName, connection, prefix).getJob(jobId);
			if (!job) return {
				status: 404,
				body: { error: "Job not found in DLQ" }
			};
			const originalEvent = job.data?.originalEvent;
			if (originalEvent) {
				const originalQueue = getOrCreateQueue(dlqName.replace(dlqSuffix, ""), connection, prefix);
				const jobData = {
					topic: originalEvent.topic,
					data: originalEvent.data,
					traceId: originalEvent.traceId
				};
				if (originalEvent.flows) jobData.flows = originalEvent.flows;
				if (originalEvent.messageGroupId) jobData.messageGroupId = originalEvent.messageGroupId;
				await originalQueue.add(originalEvent.topic || job.name, jobData);
			}
			await job.remove();
			return {
				status: 200,
				body: { message: "Job retried from DLQ" }
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "POST",
		path: "/__motia/bullmq/dlq/:name/retry-all"
	}, async (req) => {
		try {
			const name = req.pathParams.name;
			const dlqName = name.endsWith(dlqSuffix) ? name : `${name}${dlqSuffix}`;
			const jobs = await getOrCreateQueue(dlqName, connection, prefix).getJobs(["waiting", "completed"]);
			const originalQueue = getOrCreateQueue(dlqName.replace(dlqSuffix, ""), connection, prefix);
			let count = 0;
			for (const job of jobs) {
				const originalEvent = job.data?.originalEvent;
				if (originalEvent) {
					const jobData = {
						topic: originalEvent.topic,
						data: originalEvent.data,
						traceId: originalEvent.traceId
					};
					if (originalEvent.flows) jobData.flows = originalEvent.flows;
					if (originalEvent.messageGroupId) jobData.messageGroupId = originalEvent.messageGroupId;
					await originalQueue.add(originalEvent.topic || job.name, jobData);
				}
				await job.remove();
				count++;
			}
			return {
				status: 200,
				body: {
					message: `Retried ${count} jobs from DLQ`,
					count
				}
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
	registerApi({
		method: "POST",
		path: "/__motia/bullmq/dlq/:name/clear"
	}, async (req) => {
		try {
			const name = req.pathParams.name;
			await getOrCreateQueue(name.endsWith(dlqSuffix) ? name : `${name}${dlqSuffix}`, connection, prefix).obliterate({ force: true });
			return {
				status: 200,
				body: { message: "DLQ cleared" }
			};
		} catch (error) {
			return {
				status: 500,
				body: { error: error instanceof Error ? error.message : "Unknown error" }
			};
		}
	});
};

//#endregion
//#region src/plugin.ts
const STREAM_NAME = "__motia.bullmq-queues";
const isBullMQAdapter = (adapter) => {
	return adapter !== null && typeof adapter === "object" && "connection" in adapter && "prefix" in adapter && "dlqSuffix" in adapter;
};
function plugin(motia) {
	let connection;
	let prefix;
	let dlqSuffix;
	let ownsConnection = false;
	if (isBullMQAdapter(motia.eventAdapter)) {
		connection = motia.eventAdapter.connection;
		prefix = motia.eventAdapter.prefix;
		dlqSuffix = motia.eventAdapter.dlqSuffix;
	} else {
		const host = process.env.BULLMQ_REDIS_HOST || process.env.REDIS_HOST || "localhost";
		const port = parseInt(process.env.BULLMQ_REDIS_PORT || process.env.REDIS_PORT || "6379", 10);
		const password = process.env.BULLMQ_REDIS_PASSWORD || process.env.REDIS_PASSWORD || void 0;
		prefix = process.env.BULLMQ_PREFIX || "motia:events";
		dlqSuffix = process.env.BULLMQ_DLQ_SUFFIX || ".dlq";
		connection = new IORedis({
			host,
			port,
			password,
			maxRetriesPerRequest: null
		});
		ownsConnection = true;
	}
	const queuesStream = new QueuesStream(connection, prefix, dlqSuffix);
	const stream = motia.lockedData.createStream({
		filePath: `${STREAM_NAME}.ts`,
		hidden: true,
		config: {
			name: STREAM_NAME,
			baseConfig: {
				storageType: "custom",
				factory: () => queuesStream
			},
			schema: null
		}
	})();
	queuesStream.setUpdateCallback((queueInfo) => {
		stream.set("default", queueInfo.id, queueInfo);
	});
	queuesStream.setupAllQueueEvents().then(() => {
		queuesStream.getGroup("default").then((queues$1) => {
			for (const queue of queues$1) stream.set("default", queue.id, queue);
		});
	});
	api(motia, prefix, dlqSuffix, connection);
	return {
		workbench: [{
			packageName: "@motiadev/plugin-bullmq",
			cssImports: ["@motiadev/plugin-bullmq/dist/styles.css"],
			label: "Queues",
			position: "top",
			componentName: "QueuesPage",
			labelIcon: "layers"
		}],
		onShutdown: async () => {
			await queuesStream.closeAllQueueEvents();
			if (ownsConnection) await connection.quit();
		}
	};
}

//#endregion
export { plugin as default };
//# sourceMappingURL=plugin.js.map