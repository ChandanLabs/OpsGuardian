import { createClient } from "redis";
import { v4 } from "uuid";

//#region src/redis-cron-adapter.ts
function isRedisClient(input) {
	return typeof input === "object" && "isOpen" in input && "connect" in input;
}
var RedisCronAdapter = class {
	constructor(redisConnection, options) {
		this.connected = false;
		this.keyPrefix = options?.keyPrefix || "motia:cron:lock:";
		this.lockTTL = options?.lockTTL || 3e5;
		this.lockRetryDelay = options?.lockRetryDelay || 1e3;
		this.lockRetryAttempts = options?.lockRetryAttempts || 0;
		this.instanceId = options?.instanceId || `motia-${v4()}`;
		this.enableHealthCheck = options?.enableHealthCheck ?? true;
		if (isRedisClient(redisConnection)) {
			this.client = redisConnection;
			this.isExternalClient = true;
			this.connected = this.client.isOpen;
		} else {
			const config = redisConnection;
			this.isExternalClient = false;
			this.client = createClient(config);
			this.client.on("error", (err) => {
				if (this.connected) console.error("[Redis Cron] Client error:", err?.message);
			});
			this.client.on("connect", () => {
				this.connected = true;
			});
			this.client.on("disconnect", () => {
				console.warn("[Redis Cron] Disconnected");
				this.connected = false;
			});
			this.client.on("reconnecting", () => {
				console.log("[Redis Cron] Reconnecting...");
			});
			this.connect();
		}
	}
	async connect() {
		if (!this.connected && !this.client.isOpen) try {
			await this.client.connect();
		} catch (error) {
			console.error("[Redis Cron] Failed to connect:", error);
			throw error;
		}
	}
	async ensureConnected() {
		if (!this.client.isOpen) await this.connect();
	}
	makeKey(jobName) {
		return `${this.keyPrefix}${jobName}`;
	}
	async acquireLock(jobName, ttl) {
		await this.ensureConnected();
		const lockTTL = ttl || this.lockTTL;
		const lockId = v4();
		const key = this.makeKey(jobName);
		const now = Date.now();
		const lock = {
			jobName,
			lockId,
			acquiredAt: now,
			expiresAt: now + lockTTL,
			instanceId: this.instanceId
		};
		const lockData = JSON.stringify(lock);
		if (await this.client.set(key, lockData, {
			PX: lockTTL,
			NX: true
		}) === "OK") return lock;
		if (this.lockRetryAttempts > 0) for (let attempt = 0; attempt < this.lockRetryAttempts; attempt++) {
			await new Promise((resolve) => setTimeout(resolve, this.lockRetryDelay));
			if (await this.client.set(key, lockData, {
				PX: lockTTL,
				NX: true
			}) === "OK") return lock;
		}
		return null;
	}
	async releaseLock(lock) {
		await this.ensureConnected();
		const key = this.makeKey(lock.jobName);
		const luaScript = `
      local current = redis.call('GET', KEYS[1])
      if not current then
        return 0
      end
      
      local lock = cjson.decode(current)
      if lock.lockId == ARGV[1] and lock.instanceId == ARGV[2] then
        return redis.call('DEL', KEYS[1])
      end
      
      return 0
    `;
		try {
			await this.client.eval(luaScript, {
				keys: [key],
				arguments: [lock.lockId, lock.instanceId]
			});
		} catch (error) {
			console.error("[Redis Cron] Error releasing lock:", error);
		}
	}
	async renewLock(lock, ttl) {
		await this.ensureConnected();
		const key = this.makeKey(lock.jobName);
		const expiresAt = Date.now() + ttl;
		const renewedLock = {
			...lock,
			expiresAt
		};
		const luaScript = `
      local current = redis.call('GET', KEYS[1])
      if not current then
        return 0
      end
      
      local lock = cjson.decode(current)
      if lock.lockId == ARGV[1] and lock.instanceId == ARGV[2] then
        redis.call('SET', KEYS[1], ARGV[3], 'PX', ARGV[4])
        return 1
      end
      
      return 0
    `;
		try {
			return await this.client.eval(luaScript, {
				keys: [key],
				arguments: [
					lock.lockId,
					lock.instanceId,
					JSON.stringify(renewedLock),
					ttl.toString()
				]
			}) === 1;
		} catch (error) {
			console.error("[Redis Cron] Error renewing lock:", error);
			return false;
		}
	}
	async isHealthy() {
		if (!this.enableHealthCheck) return true;
		try {
			await this.ensureConnected();
			return await this.client.ping() === "PONG";
		} catch {
			return false;
		}
	}
	async shutdown() {
		await this.ensureConnected();
		const pattern = `${this.keyPrefix}*`;
		const keys = await this.scanKeys(pattern);
		for (const key of keys) {
			const lockData = await this.client.get(key);
			if (lockData) try {
				if (JSON.parse(lockData).instanceId === this.instanceId) await this.client.del(key);
			} catch (error) {
				console.error("[Redis Cron] Error cleaning up lock during shutdown:", error);
			}
		}
		if (!this.isExternalClient && this.client.isOpen) await this.client.quit();
	}
	async getActiveLocks() {
		await this.ensureConnected();
		const pattern = `${this.keyPrefix}*`;
		const keys = await this.scanKeys(pattern);
		const locks = [];
		for (const key of keys) {
			const lockData = await this.client.get(key);
			if (lockData) try {
				const lock = JSON.parse(lockData);
				locks.push({
					jobName: lock.jobName,
					instanceId: lock.instanceId,
					acquiredAt: lock.acquiredAt,
					expiresAt: lock.expiresAt
				});
			} catch (error) {
				console.error("[Redis Cron] Error parsing lock data:", error);
			}
		}
		return locks;
	}
	async scanKeys(pattern) {
		const keys = [];
		let cursor = "0";
		do {
			const result = await this.client.scan(cursor.toString(), {
				MATCH: pattern,
				COUNT: 100
			});
			cursor = result.cursor;
			keys.push(...result.keys);
		} while (String(cursor) !== "0");
		return keys;
	}
};

//#endregion
export { RedisCronAdapter };
//# sourceMappingURL=redis-cron-adapter.mjs.map