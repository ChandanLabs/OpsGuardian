{"version":3,"file":"redis-stream-adapter.mjs","names":["item: StreamItemWithTimestamp<TData>"],"sources":["../src/redis-stream-adapter.ts"],"sourcesContent":["import type { BaseStreamItem, StateStreamEvent, StateStreamEventChannel } from '@motiadev/core'\nimport { StreamAdapter, type StreamQueryFilter } from '@motiadev/core'\nimport { createClient, type RedisClientOptions, type RedisClientType } from 'redis'\nimport type { RedisStreamAdapterConfig } from './types'\n\ntype StreamItemWithTimestamp<TData> = BaseStreamItem<TData> & {\n  _createdAt?: number\n}\n\ntype RedisSocketConfig = {\n  host?: string\n  port?: number\n  keepAlive?: boolean\n  noDelay?: boolean\n}\n\ntype EventHandler<T> = (event: StateStreamEvent<T>) => void | Promise<void>\n\nexport class RedisStreamAdapter<TData> extends StreamAdapter<TData> {\n  private client: RedisClientType\n  private subClient?: RedisClientType\n  private keyPrefix: string\n  private groupPrefix: string\n  private subscriptions: Map<string, EventHandler<unknown>> = new Map()\n\n  constructor(streamName: string, config: RedisStreamAdapterConfig, sharedClient: RedisClientType) {\n    super(streamName)\n    this.keyPrefix = config.keyPrefix || 'motia:stream:'\n    this.groupPrefix = `${this.keyPrefix}${streamName}:group:`\n\n    this.client = sharedClient\n  }\n\n  private makeGroupKey(groupId: string): string {\n    return `${this.groupPrefix}${groupId}`\n  }\n\n  private makeChannelKey(channel: StateStreamEventChannel): string {\n    return channel.id\n      ? `motia:stream:events:${this.streamName}:${channel.groupId}:${channel.id}`\n      : `motia:stream:events:${this.streamName}:${channel.groupId}`\n  }\n\n  async get(groupId: string, id: string): Promise<BaseStreamItem<TData> | null> {\n    const hashKey = this.makeGroupKey(groupId)\n    const value = await this.client.hGet(hashKey, id)\n    return value ? JSON.parse(value) : null\n  }\n\n  async set(groupId: string, id: string, data: TData): Promise<BaseStreamItem<TData>> {\n    const hashKey = this.makeGroupKey(groupId)\n    const dataWithTimestamp = data as StreamItemWithTimestamp<TData>\n    const item: StreamItemWithTimestamp<TData> = {\n      ...data,\n      id,\n      _createdAt: dataWithTimestamp._createdAt || Date.now(),\n    }\n    const itemJson = JSON.stringify(item)\n\n    const existed = await this.client.hExists(hashKey, id)\n    const eventType = existed ? 'update' : 'create'\n\n    await Promise.all([\n      this.client.hSet(hashKey, id, itemJson),\n      this.send({ groupId, id }, { type: eventType, data: item }),\n    ])\n\n    return item\n  }\n\n  async delete(groupId: string, id: string): Promise<BaseStreamItem<TData> | null> {\n    const hashKey = this.makeGroupKey(groupId)\n    const value = await this.client.hGet(hashKey, id)\n\n    if (!value) return null\n\n    const item = JSON.parse(value) as BaseStreamItem<TData>\n\n    await Promise.all([this.client.hDel(hashKey, id), this.send({ groupId, id }, { type: 'delete', data: item })])\n\n    return item\n  }\n\n  async getGroup(groupId: string): Promise<BaseStreamItem<TData>[]> {\n    const hashKey = this.makeGroupKey(groupId)\n    const values = await this.client.hGetAll(hashKey)\n\n    const items = Object.values(values).map((v) => JSON.parse(v) as StreamItemWithTimestamp<TData>)\n\n    return items.sort((a, b) => {\n      const aTime = a._createdAt || 0\n      const bTime = b._createdAt || 0\n      return aTime - bTime\n    })\n  }\n\n  async send<T>(channel: StateStreamEventChannel, event: StateStreamEvent<T>): Promise<void> {\n    const channelKey = this.makeChannelKey(channel)\n    await this.client.publish(channelKey, JSON.stringify(event))\n  }\n\n  async subscribe<T>(\n    channel: StateStreamEventChannel,\n    handler: (event: StateStreamEvent<T>) => void | Promise<void>,\n  ): Promise<void> {\n    const channelKey = this.makeChannelKey(channel)\n\n    if (!this.subClient) {\n      const socketConfig = this.client.options?.socket as RedisSocketConfig | undefined\n      const keepAliveValue = socketConfig?.keepAlive\n      const clientConfig: RedisClientOptions = {\n        socket: {\n          host: socketConfig?.host || 'localhost',\n          port: socketConfig?.port || 6379,\n          keepAlive: keepAliveValue,\n          noDelay: true,\n        },\n        password: this.client.options?.password,\n        username: this.client.options?.username,\n        database: this.client.options?.database || 0,\n      }\n      this.subClient = createClient(clientConfig) as RedisClientType\n\n      this.subClient.on('error', (err) => {\n        console.error('[Redis Stream] Sub client error:', err)\n      })\n\n      await this.subClient.connect()\n    }\n\n    this.subscriptions.set(channelKey, handler as EventHandler<unknown>)\n\n    const subClient = this.subClient\n    if (!subClient) return\n\n    await subClient.subscribe(channelKey, async (message) => {\n      try {\n        const event = JSON.parse(message) as StateStreamEvent<T>\n        await handler(event)\n      } catch (error) {\n        console.error('[Redis Stream] Error processing subscription message:', error)\n      }\n    })\n  }\n\n  async unsubscribe(channel: StateStreamEventChannel): Promise<void> {\n    if (!this.subClient) return\n\n    const channelKey = this.makeChannelKey(channel)\n    this.subscriptions.delete(channelKey)\n\n    try {\n      await this.subClient.unsubscribe(channelKey)\n    } catch (error) {\n      console.error('[Redis Stream] Error unsubscribing:', error)\n    }\n  }\n\n  async clear(groupId: string): Promise<void> {\n    const hashKey = this.makeGroupKey(groupId)\n    await this.client.del(hashKey)\n  }\n\n  async query(groupId: string, filter: StreamQueryFilter<TData>): Promise<BaseStreamItem<TData>[]> {\n    let items = await this.getGroup(groupId)\n\n    if (filter.where) {\n      const where = filter.where\n      items = items.filter((item) => {\n        return Object.entries(where).every(([key, value]) => {\n          const itemKey = key as keyof BaseStreamItem<TData>\n          return item[itemKey] === value\n        })\n      })\n    }\n\n    if (filter.orderBy) {\n      items.sort((a, b) => {\n        const orderKey = filter.orderBy as keyof BaseStreamItem<TData>\n        const aVal = a[orderKey]\n        const bVal = b[orderKey]\n        const comparison = aVal < bVal ? -1 : aVal > bVal ? 1 : 0\n        return filter.orderDirection === 'desc' ? -comparison : comparison\n      })\n    }\n\n    if (filter.offset) {\n      items = items.slice(filter.offset)\n    }\n\n    if (filter.limit) {\n      items = items.slice(0, filter.limit)\n    }\n\n    return items\n  }\n\n  async cleanup(): Promise<void> {\n    this.subscriptions.clear()\n  }\n}\n"],"mappings":"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"}