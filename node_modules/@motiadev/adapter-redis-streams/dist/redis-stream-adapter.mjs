import { StreamAdapter } from "@motiadev/core";
import { createClient } from "redis";

//#region src/redis-stream-adapter.ts
var RedisStreamAdapter = class extends StreamAdapter {
	constructor(streamName, config, sharedClient) {
		super(streamName);
		this.subscriptions = /* @__PURE__ */ new Map();
		this.keyPrefix = config.keyPrefix || "motia:stream:";
		this.groupPrefix = `${this.keyPrefix}${streamName}:group:`;
		this.client = sharedClient;
	}
	makeGroupKey(groupId) {
		return `${this.groupPrefix}${groupId}`;
	}
	makeChannelKey(channel) {
		return channel.id ? `motia:stream:events:${this.streamName}:${channel.groupId}:${channel.id}` : `motia:stream:events:${this.streamName}:${channel.groupId}`;
	}
	async get(groupId, id) {
		const hashKey = this.makeGroupKey(groupId);
		const value = await this.client.hGet(hashKey, id);
		return value ? JSON.parse(value) : null;
	}
	async set(groupId, id, data) {
		const hashKey = this.makeGroupKey(groupId);
		const dataWithTimestamp = data;
		const item = {
			...data,
			id,
			_createdAt: dataWithTimestamp._createdAt || Date.now()
		};
		const itemJson = JSON.stringify(item);
		const eventType = await this.client.hExists(hashKey, id) ? "update" : "create";
		await Promise.all([this.client.hSet(hashKey, id, itemJson), this.send({
			groupId,
			id
		}, {
			type: eventType,
			data: item
		})]);
		return item;
	}
	async delete(groupId, id) {
		const hashKey = this.makeGroupKey(groupId);
		const value = await this.client.hGet(hashKey, id);
		if (!value) return null;
		const item = JSON.parse(value);
		await Promise.all([this.client.hDel(hashKey, id), this.send({
			groupId,
			id
		}, {
			type: "delete",
			data: item
		})]);
		return item;
	}
	async getGroup(groupId) {
		const hashKey = this.makeGroupKey(groupId);
		const values = await this.client.hGetAll(hashKey);
		return Object.values(values).map((v) => JSON.parse(v)).sort((a, b) => {
			return (a._createdAt || 0) - (b._createdAt || 0);
		});
	}
	async send(channel, event) {
		const channelKey = this.makeChannelKey(channel);
		await this.client.publish(channelKey, JSON.stringify(event));
	}
	async subscribe(channel, handler) {
		const channelKey = this.makeChannelKey(channel);
		if (!this.subClient) {
			const socketConfig = this.client.options?.socket;
			const keepAliveValue = socketConfig?.keepAlive;
			this.subClient = createClient({
				socket: {
					host: socketConfig?.host || "localhost",
					port: socketConfig?.port || 6379,
					keepAlive: keepAliveValue,
					noDelay: true
				},
				password: this.client.options?.password,
				username: this.client.options?.username,
				database: this.client.options?.database || 0
			});
			this.subClient.on("error", (err) => {
				console.error("[Redis Stream] Sub client error:", err);
			});
			await this.subClient.connect();
		}
		this.subscriptions.set(channelKey, handler);
		const subClient = this.subClient;
		if (!subClient) return;
		await subClient.subscribe(channelKey, async (message) => {
			try {
				await handler(JSON.parse(message));
			} catch (error) {
				console.error("[Redis Stream] Error processing subscription message:", error);
			}
		});
	}
	async unsubscribe(channel) {
		if (!this.subClient) return;
		const channelKey = this.makeChannelKey(channel);
		this.subscriptions.delete(channelKey);
		try {
			await this.subClient.unsubscribe(channelKey);
		} catch (error) {
			console.error("[Redis Stream] Error unsubscribing:", error);
		}
	}
	async clear(groupId) {
		const hashKey = this.makeGroupKey(groupId);
		await this.client.del(hashKey);
	}
	async query(groupId, filter) {
		let items = await this.getGroup(groupId);
		if (filter.where) {
			const where = filter.where;
			items = items.filter((item) => {
				return Object.entries(where).every(([key, value]) => {
					return item[key] === value;
				});
			});
		}
		if (filter.orderBy) items.sort((a, b) => {
			const orderKey = filter.orderBy;
			const aVal = a[orderKey];
			const bVal = b[orderKey];
			const comparison = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
			return filter.orderDirection === "desc" ? -comparison : comparison;
		});
		if (filter.offset) items = items.slice(filter.offset);
		if (filter.limit) items = items.slice(0, filter.limit);
		return items;
	}
	async cleanup() {
		this.subscriptions.clear();
	}
};

//#endregion
export { RedisStreamAdapter };
//# sourceMappingURL=redis-stream-adapter.mjs.map