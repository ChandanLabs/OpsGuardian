import {
  create
} from "./chunk-GN6RPVUP.js";
import {
  createJSONStorage,
  persist
} from "./chunk-PK4VJZPQ.js";
import {
  Anchor,
  Arrow,
  Content,
  Content2,
  DismissableLayer,
  Portal,
  Portal2,
  Presence,
  Primitive,
  Provider,
  Root2,
  Root3,
  Trigger,
  VISUALLY_HIDDEN_STYLES,
  composeEventHandlers,
  composeRefs,
  createContextScope,
  createPopperScope,
  dispatchDiscreteCustomEvent,
  useCallbackRef,
  useComposedRefs,
  useControllableState,
  useId,
  useLayoutEffect2,
  useSize
} from "./chunk-H3Z5RFEW.js";
import {
  cva
} from "./chunk-6JCWOCCU.js";
import {
  clsx
} from "./chunk-ZYTAZ2LT.js";
import {
  require_lucide_react
} from "./chunk-A2EHX3L2.js";
import {
  require_jsx_runtime
} from "./chunk-OVCHON5Z.js";
import {
  require_react_dom
} from "./chunk-VZXGP5H5.js";
import {
  require_compiler_runtime
} from "./chunk-N7QBCMQ7.js";
import {
  require_react
} from "./chunk-J3YWFM6B.js";
import {
  __commonJS,
  __toESM
} from "./chunk-PR4QN5HX.js";

// node_modules/react-use-resizable/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-use-resizable/lib/index.js"(exports) {
    "use strict";
    var __assign2 = exports && exports.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useResizable = void 0;
    var react_1 = require_react();
    var MoveEvent;
    (function(MoveEvent2) {
      MoveEvent2["MouseMove"] = "mousemove";
      MoveEvent2["TouchMove"] = "touchmove";
    })(MoveEvent || (MoveEvent = {}));
    var EndEvent;
    (function(EndEvent2) {
      EndEvent2["MouseUp"] = "mouseup";
      EndEvent2["TouchEnd"] = "touchend";
    })(EndEvent || (EndEvent = {}));
    var defaultProps = {
      interval: 1,
      initialHeight: 100,
      initialWidth: 100,
      lockHorizontal: false,
      lockVertical: false
    };
    var useResizable2 = function(options) {
      var props2 = __assign2(__assign2({}, defaultProps), options);
      var parentRef = (0, react_1.useRef)(null);
      var getRootProps = function() {
        var initialHeight = props2.initialHeight, initialWidth = props2.initialWidth;
        return {
          ref: parentRef,
          style: {
            height: initialHeight,
            width: initialWidth
          }
        };
      };
      var getHandleProps = function(handleProps) {
        if (!handleProps) {
          handleProps = {};
        }
        var _a = __assign2(__assign2({}, props2), handleProps), _b = _a.parent, parent = _b === void 0 ? parentRef : _b, _c = _a.interval, interval = _c === void 0 ? 1 : _c, _d = _a.maxHeight, maxHeight = _d === void 0 ? Number.MAX_SAFE_INTEGER : _d, _e = _a.maxWidth, maxWidth = _e === void 0 ? Number.MAX_SAFE_INTEGER : _e, reverse = _a.reverse, lockHorizontal = _a.lockHorizontal, lockVertical = _a.lockVertical, onResize = _a.onResize, onDragEnd = _a.onDragEnd, onDragStart = _a.onDragStart, _f = _a.minHeight, minHeight = _f === void 0 ? 0 : _f, _g = _a.minWidth, minWidth = _g === void 0 ? 0 : _g, _h = _a.disabled, disabled = _h === void 0 ? false : _h, _j = _a.maintainAspectRatio, maintainAspectRatio = _j === void 0 ? false : _j;
        var handleMove = function(clientY, startHeight, startY, clientX, startWidth, startX) {
          var _a2, _b2;
          if (disabled)
            return;
          var currentWidth = ((_a2 = parent === null || parent === void 0 ? void 0 : parent.current) === null || _a2 === void 0 ? void 0 : _a2.clientWidth) || 0;
          var currentHeight = ((_b2 = parent === null || parent === void 0 ? void 0 : parent.current) === null || _b2 === void 0 ? void 0 : _b2.clientHeight) || 0;
          var roundedHeight = currentHeight;
          var roundedWidth = currentWidth;
          if (!lockVertical) {
            var newHeight = startHeight + (clientY - startY) * (reverse ? -1 : 1);
            roundedHeight = Math.round(newHeight / interval) * interval;
            if (roundedHeight <= 0) {
              roundedHeight = interval;
            }
            if (roundedHeight >= maxHeight) {
              roundedHeight = maxHeight;
            }
            if (roundedHeight <= minHeight) {
              roundedHeight = minHeight;
            }
            if (parent === null || parent === void 0 ? void 0 : parent.current) {
              parent.current.style.height = "".concat(roundedHeight, "px");
            }
          }
          if (!lockHorizontal) {
            var newWidth = startWidth + (clientX - startX) * (reverse ? -1 : 1);
            roundedWidth = Math.round(newWidth / interval) * interval;
            if (roundedWidth <= 0) {
              roundedWidth = interval;
            }
            if (roundedWidth >= maxWidth) {
              roundedWidth = maxWidth;
            }
            if (roundedWidth <= minWidth) {
              roundedWidth = minWidth;
            }
            if (parent === null || parent === void 0 ? void 0 : parent.current) {
              parent.current.style.width = "".concat(roundedWidth, "px");
            }
          }
          if (maintainAspectRatio) {
            var aspectRatio = currentWidth / currentHeight;
            var newAspectRatio = roundedWidth / roundedHeight;
            if (newAspectRatio > aspectRatio) {
              roundedWidth = roundedHeight * aspectRatio;
              if (parent === null || parent === void 0 ? void 0 : parent.current) {
                parent.current.style.width = "".concat(roundedWidth, "px");
              }
            } else {
              roundedHeight = roundedWidth / aspectRatio;
              if (parent === null || parent === void 0 ? void 0 : parent.current) {
                parent.current.style.height = "".concat(roundedHeight, "px");
              }
            }
          }
          if (onResize) {
            onResize({
              newHeight: roundedHeight,
              heightDiff: roundedHeight - currentHeight,
              newWidth: roundedWidth,
              widthDiff: roundedWidth - currentWidth
            });
          }
        };
        var handleMouseMove = function(startHeight, startY, startWidth, startX) {
          return function(e) {
            if (!(e instanceof MouseEvent))
              return;
            handleMove(e.clientY, startHeight, startY, e.clientX, startWidth, startX);
          };
        };
        var handleTouchMove = function(startHeight, startY, startWidth, startX) {
          return function(e) {
            e.preventDefault();
            if (!(e instanceof TouchEvent))
              return;
            handleMove(e.touches[0].clientY, startHeight, startY, e.touches[0].clientX, startWidth, startX);
          };
        };
        var handleDragEnd = function(handleMoveInstance, moveEvent, endEvent, startHeight, startWidth) {
          function dragHandler() {
            var _a2, _b2;
            document.removeEventListener(moveEvent, handleMoveInstance);
            document.removeEventListener(endEvent, dragHandler);
            if (onDragEnd) {
              var currentWidth = ((_a2 = parent === null || parent === void 0 ? void 0 : parent.current) === null || _a2 === void 0 ? void 0 : _a2.clientWidth) || 0;
              var currentHeight = ((_b2 = parent === null || parent === void 0 ? void 0 : parent.current) === null || _b2 === void 0 ? void 0 : _b2.clientHeight) || 0;
              onDragEnd({
                newHeight: currentHeight,
                heightDiff: currentHeight - startHeight,
                newWidth: currentWidth,
                widthDiff: currentWidth - startWidth
              });
            }
          }
          return dragHandler;
        };
        var handleDown = function(e) {
          var _a2, _b2;
          if (disabled)
            return;
          var startHeight = ((_a2 = parent === null || parent === void 0 ? void 0 : parent.current) === null || _a2 === void 0 ? void 0 : _a2.clientHeight) || 0;
          var startWidth = ((_b2 = parent === null || parent === void 0 ? void 0 : parent.current) === null || _b2 === void 0 ? void 0 : _b2.clientWidth) || 0;
          var moveHandler = null;
          var moveEvent = null;
          var endEvent = null;
          if (e.type === "mousedown") {
            var _c2 = e, clientY = _c2.clientY, clientX = _c2.clientX;
            moveHandler = handleMouseMove(startHeight, clientY, startWidth, clientX);
            moveEvent = MoveEvent.MouseMove;
            endEvent = EndEvent.MouseUp;
          } else if (e.type === "touchstart") {
            var touches = e.touches;
            var _d2 = touches[0], clientY = _d2.clientY, clientX = _d2.clientX;
            moveHandler = handleTouchMove(startHeight, clientY, startWidth, clientX);
            moveEvent = MoveEvent.TouchMove;
            endEvent = EndEvent.TouchEnd;
          }
          if (!moveHandler || !moveEvent || !endEvent)
            return;
          if (onDragStart) {
            onDragStart({
              newHeight: startHeight,
              heightDiff: 0,
              newWidth: startWidth,
              widthDiff: 0
            });
          }
          var dragEndHandler = handleDragEnd(moveHandler, moveEvent, endEvent, startHeight, startWidth);
          document.addEventListener(moveEvent, moveHandler, { passive: false });
          document.addEventListener(endEvent, dragEndHandler);
        };
        var cursor;
        if (disabled) {
          cursor = "not-allowed";
        } else if (lockHorizontal && lockVertical) {
          cursor = "default";
        } else if (lockHorizontal) {
          cursor = "row-resize";
        } else if (lockVertical) {
          cursor = "col-resize";
        } else {
          cursor = "nwse-resize";
        }
        var style = {
          cursor
        };
        return {
          onMouseDown: handleDown,
          onTouchStart: handleDown,
          style
        };
      };
      return {
        rootRef: parentRef,
        getRootProps,
        getHandleProps
      };
    };
    exports.useResizable = useResizable2;
  }
});

// node_modules/@motiadev/ui/dist/components/ui/background-effect.js
var import_compiler_runtime = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var types = { subtle: {
  width: "100%",
  height: "100%"
} };
var BackgroundEffect = (t0) => {
  const $ = (0, import_compiler_runtime.c)(3);
  if ($[0] !== "4f42de8f13e9101da05465a8fb9b4f0def434e7c70f6c656a69fe13f89e811f0") {
    for (let $i = 0; $i < 3; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "4f42de8f13e9101da05465a8fb9b4f0def434e7c70f6c656a69fe13f89e811f0";
  }
  const { patternType: t1 } = t0;
  const style = types[t1 === void 0 ? "subtle" : t1];
  let t2;
  if ($[1] !== style) {
    t2 = (0, import_jsx_runtime.jsx)("div", {
      "aria-hidden": "true",
      className: "absolute top-0 h-full w-full inset-x-0 -z-10 transform-gpu overflow-hidden pointer-events-none",
      children: (0, import_jsx_runtime.jsx)("div", {
        style,
        className: "relative -z-10 aspect-1155/678 bg-linear-to-br from-white/60 to-[#050505] opacity-10 pointer-events-none"
      })
    });
    $[1] = style;
    $[2] = t2;
  } else t2 = $[2];
  return t2;
};

// node_modules/tailwind-merge/dist/bundle-mjs.mjs
var concatArrays = (array1, array2) => {
  const combinedArray = new Array(array1.length + array2.length);
  for (let i = 0; i < array1.length; i++) {
    combinedArray[i] = array1[i];
  }
  for (let i = 0; i < array2.length; i++) {
    combinedArray[array1.length + i] = array2[i];
  }
  return combinedArray;
};
var createClassValidatorObject = (classGroupId, validator) => ({
  classGroupId,
  validator
});
var createClassPartObject = (nextPart = /* @__PURE__ */ new Map(), validators2 = null, classGroupId) => ({
  nextPart,
  validators: validators2,
  classGroupId
});
var CLASS_PART_SEPARATOR = "-";
var EMPTY_CONFLICTS = [];
var ARBITRARY_PROPERTY_PREFIX = "arbitrary..";
var createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className) => {
    if (className.startsWith("[") && className.endsWith("]")) {
      return getGroupIdForArbitraryProperty(className);
    }
    const classParts = className.split(CLASS_PART_SEPARATOR);
    const startIndex = classParts[0] === "" && classParts.length > 1 ? 1 : 0;
    return getGroupRecursive(classParts, startIndex, classMap);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    if (hasPostfixModifier) {
      const modifierConflicts = conflictingClassGroupModifiers[classGroupId];
      const baseConflicts = conflictingClassGroups[classGroupId];
      if (modifierConflicts) {
        if (baseConflicts) {
          return concatArrays(baseConflicts, modifierConflicts);
        }
        return modifierConflicts;
      }
      return baseConflicts || EMPTY_CONFLICTS;
    }
    return conflictingClassGroups[classGroupId] || EMPTY_CONFLICTS;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
var getGroupRecursive = (classParts, startIndex, classPartObject) => {
  const classPathsLength = classParts.length - startIndex;
  if (classPathsLength === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[startIndex];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  if (nextClassPartObject) {
    const result = getGroupRecursive(classParts, startIndex + 1, nextClassPartObject);
    if (result) return result;
  }
  const validators2 = classPartObject.validators;
  if (validators2 === null) {
    return void 0;
  }
  const classRest = startIndex === 0 ? classParts.join(CLASS_PART_SEPARATOR) : classParts.slice(startIndex).join(CLASS_PART_SEPARATOR);
  const validatorsLength = validators2.length;
  for (let i = 0; i < validatorsLength; i++) {
    const validatorObj = validators2[i];
    if (validatorObj.validator(classRest)) {
      return validatorObj.classGroupId;
    }
  }
  return void 0;
};
var getGroupIdForArbitraryProperty = (className) => className.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const content = className.slice(1, -1);
  const colonIndex = content.indexOf(":");
  const property = content.slice(0, colonIndex);
  return property ? ARBITRARY_PROPERTY_PREFIX + property : void 0;
})();
var createClassMap = (config) => {
  const {
    theme: theme2,
    classGroups
  } = config;
  return processClassGroups(classGroups, theme2);
};
var processClassGroups = (classGroups, theme2) => {
  const classMap = createClassPartObject();
  for (const classGroupId in classGroups) {
    const group = classGroups[classGroupId];
    processClassesRecursively(group, classMap, classGroupId, theme2);
  }
  return classMap;
};
var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme2) => {
  const len = classGroup.length;
  for (let i = 0; i < len; i++) {
    const classDefinition = classGroup[i];
    processClassDefinition(classDefinition, classPartObject, classGroupId, theme2);
  }
};
var processClassDefinition = (classDefinition, classPartObject, classGroupId, theme2) => {
  if (typeof classDefinition === "string") {
    processStringDefinition(classDefinition, classPartObject, classGroupId);
    return;
  }
  if (typeof classDefinition === "function") {
    processFunctionDefinition(classDefinition, classPartObject, classGroupId, theme2);
    return;
  }
  processObjectDefinition(classDefinition, classPartObject, classGroupId, theme2);
};
var processStringDefinition = (classDefinition, classPartObject, classGroupId) => {
  const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
  classPartObjectToEdit.classGroupId = classGroupId;
};
var processFunctionDefinition = (classDefinition, classPartObject, classGroupId, theme2) => {
  if (isThemeGetter(classDefinition)) {
    processClassesRecursively(classDefinition(theme2), classPartObject, classGroupId, theme2);
    return;
  }
  if (classPartObject.validators === null) {
    classPartObject.validators = [];
  }
  classPartObject.validators.push(createClassValidatorObject(classGroupId, classDefinition));
};
var processObjectDefinition = (classDefinition, classPartObject, classGroupId, theme2) => {
  const entries = Object.entries(classDefinition);
  const len = entries.length;
  for (let i = 0; i < len; i++) {
    const [key, value] = entries[i];
    processClassesRecursively(value, getPart(classPartObject, key), classGroupId, theme2);
  }
};
var getPart = (classPartObject, path) => {
  let current = classPartObject;
  const parts = path.split(CLASS_PART_SEPARATOR);
  const len = parts.length;
  for (let i = 0; i < len; i++) {
    const part = parts[i];
    let next = current.nextPart.get(part);
    if (!next) {
      next = createClassPartObject();
      current.nextPart.set(part, next);
    }
    current = next;
  }
  return current;
};
var isThemeGetter = (func) => "isThemeGetter" in func && func.isThemeGetter === true;
var createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ Object.create(null);
  let previousCache = /* @__PURE__ */ Object.create(null);
  const update = (key, value) => {
    cache[key] = value;
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ Object.create(null);
    }
  };
  return {
    get(key) {
      let value = cache[key];
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache[key]) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (key in cache) {
        cache[key] = value;
      } else {
        update(key, value);
      }
    }
  };
};
var IMPORTANT_MODIFIER = "!";
var MODIFIER_SEPARATOR = ":";
var EMPTY_MODIFIERS = [];
var createResultObject = (modifiers, hasImportantModifier, baseClassName, maybePostfixModifierPosition, isExternal) => ({
  modifiers,
  hasImportantModifier,
  baseClassName,
  maybePostfixModifierPosition,
  isExternal
});
var createParseClassName = (config) => {
  const {
    prefix,
    experimentalParseClassName
  } = config;
  let parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let parenDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    const len = className.length;
    for (let index = 0; index < len; index++) {
      const currentCharacter = className[index];
      if (bracketDepth === 0 && parenDepth === 0) {
        if (currentCharacter === MODIFIER_SEPARATOR) {
          modifiers.push(className.slice(modifierStart, index));
          modifierStart = index + 1;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index;
          continue;
        }
      }
      if (currentCharacter === "[") bracketDepth++;
      else if (currentCharacter === "]") bracketDepth--;
      else if (currentCharacter === "(") parenDepth++;
      else if (currentCharacter === ")") parenDepth--;
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.slice(modifierStart);
    let baseClassName = baseClassNameWithImportantModifier;
    let hasImportantModifier = false;
    if (baseClassNameWithImportantModifier.endsWith(IMPORTANT_MODIFIER)) {
      baseClassName = baseClassNameWithImportantModifier.slice(0, -1);
      hasImportantModifier = true;
    } else if (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER)
    ) {
      baseClassName = baseClassNameWithImportantModifier.slice(1);
      hasImportantModifier = true;
    }
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return createResultObject(modifiers, hasImportantModifier, baseClassName, maybePostfixModifierPosition);
  };
  if (prefix) {
    const fullPrefix = prefix + MODIFIER_SEPARATOR;
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => className.startsWith(fullPrefix) ? parseClassNameOriginal(className.slice(fullPrefix.length)) : createResultObject(EMPTY_MODIFIERS, false, className, void 0, true);
  }
  if (experimentalParseClassName) {
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => experimentalParseClassName({
      className,
      parseClassName: parseClassNameOriginal
    });
  }
  return parseClassName;
};
var createSortModifiers = (config) => {
  const modifierWeights = /* @__PURE__ */ new Map();
  config.orderSensitiveModifiers.forEach((mod, index) => {
    modifierWeights.set(mod, 1e6 + index);
  });
  return (modifiers) => {
    const result = [];
    let currentSegment = [];
    for (let i = 0; i < modifiers.length; i++) {
      const modifier = modifiers[i];
      const isArbitrary = modifier[0] === "[";
      const isOrderSensitive = modifierWeights.has(modifier);
      if (isArbitrary || isOrderSensitive) {
        if (currentSegment.length > 0) {
          currentSegment.sort();
          result.push(...currentSegment);
          currentSegment = [];
        }
        result.push(modifier);
      } else {
        currentSegment.push(modifier);
      }
    }
    if (currentSegment.length > 0) {
      currentSegment.sort();
      result.push(...currentSegment);
    }
    return result;
  };
};
var createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  sortModifiers: createSortModifiers(config),
  ...createClassGroupUtils(config)
});
var SPLIT_CLASSES_REGEX = /\s+/;
var mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds,
    sortModifiers
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index = classNames.length - 1; index >= 0; index -= 1) {
    const originalClassName = classNames[index];
    const {
      isExternal,
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    if (isExternal) {
      result = originalClassName + (result.length > 0 ? " " + result : result);
      continue;
    }
    let hasPostfixModifier = !!maybePostfixModifierPosition;
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = modifiers.length === 0 ? "" : modifiers.length === 1 ? modifiers[0] : sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.indexOf(classId) > -1) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i = 0; i < conflictGroups.length; ++i) {
      const group = conflictGroups[i];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
var twJoin = (...classLists) => {
  let index = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index < classLists.length) {
    if (argument = classLists[index++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
var toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
var createTailwindMerge = (createConfigFirst, ...createConfigRest) => {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall;
  const initTailwindMerge = (classList) => {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  };
  const tailwindMerge = (classList) => {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  };
  functionToCall = initTailwindMerge;
  return (...args) => functionToCall(twJoin(...args));
};
var fallbackThemeArr = [];
var fromTheme = (key) => {
  const themeGetter = (theme2) => theme2[key] || fallbackThemeArr;
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
var arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
var arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
var fractionRegex = /^\d+\/\d+$/;
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/;
var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var isFraction = (value) => fractionRegex.test(value);
var isNumber = (value) => !!value && !Number.isNaN(Number(value));
var isInteger = (value) => !!value && Number.isInteger(Number(value));
var isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
var isTshirtSize = (value) => tshirtUnitRegex.test(value);
var isAny = () => true;
var isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
var isNever = () => false;
var isShadow = (value) => shadowRegex.test(value);
var isImage = (value) => imageRegex.test(value);
var isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value);
var isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever);
var isArbitraryValue = (value) => arbitraryValueRegex.test(value);
var isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly);
var isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber);
var isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever);
var isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage);
var isArbitraryShadow = (value) => getIsArbitraryValue(value, isLabelShadow, isShadow);
var isArbitraryVariable = (value) => arbitraryVariableRegex.test(value);
var isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength);
var isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName);
var isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition);
var isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize);
var isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage);
var isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, true);
var getIsArbitraryValue = (value, testLabel, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
var getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {
  const result = arbitraryVariableRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return shouldMatchNoLabel;
  }
  return false;
};
var isLabelPosition = (label) => label === "position" || label === "percentage";
var isLabelImage = (label) => label === "image" || label === "url";
var isLabelSize = (label) => label === "length" || label === "size" || label === "bg-size";
var isLabelLength = (label) => label === "length";
var isLabelNumber = (label) => label === "number";
var isLabelFamilyName = (label) => label === "family-name";
var isLabelShadow = (label) => label === "shadow";
var validators = Object.defineProperty({
  __proto__: null,
  isAny,
  isAnyNonArbitrary,
  isArbitraryImage,
  isArbitraryLength,
  isArbitraryNumber,
  isArbitraryPosition,
  isArbitraryShadow,
  isArbitrarySize,
  isArbitraryValue,
  isArbitraryVariable,
  isArbitraryVariableFamilyName,
  isArbitraryVariableImage,
  isArbitraryVariableLength,
  isArbitraryVariablePosition,
  isArbitraryVariableShadow,
  isArbitraryVariableSize,
  isFraction,
  isInteger,
  isNumber,
  isPercent,
  isTshirtSize
}, Symbol.toStringTag, {
  value: "Module"
});
var getDefaultConfig = () => {
  const themeColor = fromTheme("color");
  const themeFont = fromTheme("font");
  const themeText = fromTheme("text");
  const themeFontWeight = fromTheme("font-weight");
  const themeTracking = fromTheme("tracking");
  const themeLeading = fromTheme("leading");
  const themeBreakpoint = fromTheme("breakpoint");
  const themeContainer = fromTheme("container");
  const themeSpacing = fromTheme("spacing");
  const themeRadius = fromTheme("radius");
  const themeShadow = fromTheme("shadow");
  const themeInsetShadow = fromTheme("inset-shadow");
  const themeTextShadow = fromTheme("text-shadow");
  const themeDropShadow = fromTheme("drop-shadow");
  const themeBlur = fromTheme("blur");
  const themePerspective = fromTheme("perspective");
  const themeAspect = fromTheme("aspect");
  const themeEase = fromTheme("ease");
  const themeAnimate = fromTheme("animate");
  const scaleBreak = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const scalePosition = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ];
  const scalePositionWithArbitrary = () => [...scalePosition(), isArbitraryVariable, isArbitraryValue];
  const scaleOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const scaleOverscroll = () => ["auto", "contain", "none"];
  const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];
  const scaleInset = () => [isFraction, "full", "auto", ...scaleUnambiguousSpacing()];
  const scaleGridTemplateColsRows = () => [isInteger, "none", "subgrid", isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartAndEnd = () => ["auto", {
    span: ["full", isInteger, isArbitraryVariable, isArbitraryValue]
  }, isInteger, isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartOrEnd = () => [isInteger, "auto", isArbitraryVariable, isArbitraryValue];
  const scaleGridAutoColsRows = () => ["auto", "min", "max", "fr", isArbitraryVariable, isArbitraryValue];
  const scaleAlignPrimaryAxis = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"];
  const scaleAlignSecondaryAxis = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"];
  const scaleMargin = () => ["auto", ...scaleUnambiguousSpacing()];
  const scaleSizing = () => [isFraction, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...scaleUnambiguousSpacing()];
  const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];
  const scaleBgPosition = () => [...scalePosition(), isArbitraryVariablePosition, isArbitraryPosition, {
    position: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleBgRepeat = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }];
  const scaleBgSize = () => ["auto", "cover", "contain", isArbitraryVariableSize, isArbitrarySize, {
    size: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleGradientStopPosition = () => [isPercent, isArbitraryVariableLength, isArbitraryLength];
  const scaleRadius = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    themeRadius,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleBorderWidth = () => ["", isNumber, isArbitraryVariableLength, isArbitraryLength];
  const scaleLineStyle = () => ["solid", "dashed", "dotted", "double"];
  const scaleBlendMode = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const scaleMaskImagePosition = () => [isNumber, isPercent, isArbitraryVariablePosition, isArbitraryPosition];
  const scaleBlur = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    themeBlur,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleRotate = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleScale = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleSkew = () => [isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleTranslate = () => [isFraction, "full", ...scaleUnambiguousSpacing()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [isTshirtSize],
      breakpoint: [isTshirtSize],
      color: [isAny],
      container: [isTshirtSize],
      "drop-shadow": [isTshirtSize],
      ease: ["in", "out", "in-out"],
      font: [isAnyNonArbitrary],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [isTshirtSize],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [isTshirtSize],
      shadow: [isTshirtSize],
      spacing: ["px", isNumber],
      text: [isTshirtSize],
      "text-shadow": [isTshirtSize],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", isFraction, isArbitraryValue, isArbitraryVariable, themeAspect]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isNumber, isArbitraryValue, isArbitraryVariable, themeContainer]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": scaleBreak()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": scaleBreak()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: scalePositionWithArbitrary()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: scaleOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": scaleOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": scaleOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: scaleOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": scaleOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": scaleOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: scaleInset()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": scaleInset()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": scaleInset()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: scaleInset()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: scaleInset()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: scaleInset()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: scaleInset()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: scaleInset()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: scaleInset()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [isInteger, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [isFraction, "full", "auto", themeContainer, ...scaleUnambiguousSpacing()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [isNumber, isFraction, "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [isInteger, "first", "last", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": scaleGridAutoColsRows()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": scaleGridAutoColsRows()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: scaleUnambiguousSpacing()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": scaleUnambiguousSpacing()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": scaleUnambiguousSpacing()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...scaleAlignPrimaryAxis(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...scaleAlignSecondaryAxis(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...scaleAlignPrimaryAxis()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": scaleAlignPrimaryAxis()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...scaleAlignSecondaryAxis(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: scaleUnambiguousSpacing()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: scaleUnambiguousSpacing()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: scaleUnambiguousSpacing()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: scaleMargin()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: scaleMargin()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: scaleMargin()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: scaleMargin()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: scaleMargin()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: scaleMargin()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: scaleMargin()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: scaleMargin()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: scaleMargin()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: scaleSizing()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [themeContainer, "screen", ...scaleSizing()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          themeContainer,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...scaleSizing()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          themeContainer,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [themeBreakpoint]
          },
          ...scaleSizing()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...scaleSizing()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...scaleSizing()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...scaleSizing()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", themeText, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", isPercent, isArbitraryValue]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [themeTracking, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [isNumber, "none", isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          themeLeading,
          ...scaleUnambiguousSpacing()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: scaleColor()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: scaleColor()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...scaleLineStyle(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [isNumber, "from-font", "auto", isArbitraryVariable, isArbitraryLength]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: scaleColor()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [isNumber, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: scaleUnambiguousSpacing()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: scaleBgPosition()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: scaleBgRepeat()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: scaleBgSize()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isInteger, isArbitraryVariable, isArbitraryValue],
          radial: ["", isArbitraryVariable, isArbitraryValue],
          conic: [isInteger, isArbitraryVariable, isArbitraryValue]
        }, isArbitraryVariableImage, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: scaleColor()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: scaleColor()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: scaleColor()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: scaleColor()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: scaleRadius()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": scaleRadius()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": scaleRadius()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": scaleRadius()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": scaleRadius()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": scaleRadius()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": scaleRadius()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": scaleRadius()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": scaleRadius()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": scaleRadius()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": scaleRadius()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": scaleRadius()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": scaleRadius()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": scaleRadius()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": scaleRadius()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: scaleBorderWidth()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": scaleBorderWidth()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": scaleBorderWidth()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": scaleBorderWidth()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": scaleBorderWidth()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": scaleBorderWidth()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": scaleBorderWidth()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": scaleBorderWidth()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": scaleBorderWidth()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": scaleBorderWidth()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": scaleBorderWidth()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: scaleColor()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": scaleColor()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": scaleColor()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": scaleColor()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": scaleColor()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": scaleColor()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": scaleColor()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": scaleColor()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": scaleColor()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: scaleColor()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...scaleLineStyle(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", isNumber, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: scaleColor()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: scaleColor()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", themeInsetShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": scaleColor()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: scaleBorderWidth()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: scaleColor()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [isNumber, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": scaleColor()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": scaleBorderWidth()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": scaleColor()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", themeTextShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": scaleColor()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...scaleBlendMode(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": scaleBlendMode()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [isNumber]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": scaleMaskImagePosition()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": scaleMaskImagePosition()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": scaleColor()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": scaleColor()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": scaleMaskImagePosition()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": scaleMaskImagePosition()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": scaleColor()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": scaleColor()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": scaleMaskImagePosition()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": scaleMaskImagePosition()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": scaleColor()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": scaleColor()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": scaleMaskImagePosition()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": scaleMaskImagePosition()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": scaleColor()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": scaleColor()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": scaleMaskImagePosition()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": scaleMaskImagePosition()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": scaleColor()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": scaleColor()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": scaleMaskImagePosition()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": scaleMaskImagePosition()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": scaleColor()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": scaleColor()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": scaleMaskImagePosition()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": scaleMaskImagePosition()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": scaleColor()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": scaleColor()
      }],
      "mask-image-radial": [{
        "mask-radial": [isArbitraryVariable, isArbitraryValue]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": scaleMaskImagePosition()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": scaleMaskImagePosition()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": scaleColor()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": scaleColor()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": scalePosition()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [isNumber]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": scaleMaskImagePosition()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": scaleMaskImagePosition()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": scaleColor()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": scaleColor()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: scaleBgPosition()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: scaleBgRepeat()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: scaleBgSize()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: scaleBlur()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeDropShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": scaleColor()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": scaleBlur()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": scaleUnambiguousSpacing()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [isNumber, "initial", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", themeEase, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", themeAnimate, isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [themePerspective, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": scalePositionWithArbitrary()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: scaleRotate()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": scaleRotate()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": scaleRotate()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": scaleRotate()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: scaleScale()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": scaleScale()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": scaleScale()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": scaleScale()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: scaleSkew()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": scaleSkew()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": scaleSkew()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [isArbitraryVariable, isArbitraryValue, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: scalePositionWithArbitrary()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: scaleTranslate()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": scaleTranslate()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": scaleTranslate()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": scaleTranslate()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: scaleColor()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: scaleColor()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryVariable, isArbitraryValue]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...scaleColor()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isNumber, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...scaleColor()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
};
var twMerge = createTailwindMerge(getDefaultConfig);

// node_modules/@motiadev/ui/dist/lib/utils.js
function cn(...inputs) {
  return twMerge(clsx(inputs));
}

// node_modules/@motiadev/ui/dist/components/ui/badge.js
var import_compiler_runtime2 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var badgeVariants = cva("inline-flex items-center rounded-full px-4 py-1 text-xs font-bold transition-colors", {
  variants: { variant: {
    info: "dark:bg-accent-100 dark:text-accent-1000 bg-accent-200 text-accent-900 capitalize",
    success: "bg-accent-1000 text-white",
    error: "bg-destructive/10 text-destructive capitalize",
    default: "dark:bg-gray-800/30 dark:text-gray-500 bg-gray-100 text-gray-800",
    outline: "border border-gray-200 dark:border-gray-700",
    warning: "border-transparent bg-amber-300 text-amber-950 hover:bg-amber/80"
  } },
  defaultVariants: { variant: "default" }
});
var Badge = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(11);
  if ($[0] !== "16ccda96cbfb6921771b65e8b9c3472148a756b8545b2ac6fa3ecbfb332c1bd6") {
    for (let $i = 0; $i < 11; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "16ccda96cbfb6921771b65e8b9c3472148a756b8545b2ac6fa3ecbfb332c1bd6";
  }
  let className;
  let props2;
  let variant;
  if ($[1] !== t0) {
    ({ className, variant, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
    $[4] = variant;
  } else {
    className = $[2];
    props2 = $[3];
    variant = $[4];
  }
  let t1;
  if ($[5] !== className || $[6] !== variant) {
    t1 = cn(badgeVariants({ variant }), className);
    $[5] = className;
    $[6] = variant;
    $[7] = t1;
  } else t1 = $[7];
  let t2;
  if ($[8] !== props2 || $[9] !== t1) {
    t2 = (0, import_jsx_runtime2.jsx)("div", {
      className: t1,
      ...props2
    });
    $[8] = props2;
    $[9] = t1;
    $[10] = t2;
  } else t2 = $[10];
  return t2;
};
Badge.displayName = "Badge";

// node_modules/@motiadev/ui/dist/components/ui/button.js
var import_compiler_runtime3 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var React = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy");
var use = React[" use ".trim().toString()];
function isPromiseLike(value) {
  return typeof value === "object" && value !== null && "then" in value;
}
function isLazyComponent(element) {
  return element != null && typeof element === "object" && "$$typeof" in element && element.$$typeof === REACT_LAZY_TYPE && "_payload" in element && isPromiseLike(element._payload);
}
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot22 = React.forwardRef((props2, forwardedRef) => {
    let { children, ...slotProps } = props2;
    if (isLazyComponent(children) && typeof use === "function") {
      children = use(children._payload);
    }
    const childrenArray = React.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React.Children.count(newElement) > 1) return React.Children.only(null);
          return React.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime3.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime3.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React.forwardRef((props2, forwardedRef) => {
    let { children, ...slotProps } = props2;
    if (isLazyComponent(children) && typeof use === "function") {
      children = use(children._payload);
    }
    if (React.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props22 = mergeProps(slotProps, children.props);
      if (children.type !== React.Fragment) {
        props22.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React.cloneElement(children, props22);
    }
    return React.Children.count(children) > 1 ? React.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = /* @__PURE__ */ Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable22 = ({ children }) => {
    return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children });
  };
  Slottable22.displayName = `${ownerName}.Slottable`;
  Slottable22.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable22;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@motiadev/ui/dist/components/ui/button.js
var buttonVariants = cva("inline-flex items-center cursor-pointer justify-center gap-2 whitespace-nowrap rounded-md font-semibold transition-all duration-200 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0", {
  variants: {
    variant: {
      default: "bg-input text-foreground hover:bg-border active:bg-card",
      accent: "bg-accent text-accent-foreground hover:bg-accent/90 active:bg-accent/80",
      light: "bg-background text-foreground border border-border hover:bg-muted active:bg-muted/80",
      secondary: "bg-secondary text-foreground shadow-sm hover:opacity-90 active:opacity-80",
      destructive: "bg-destructive text-destructive-foreground shadow-sm hover:opacity-90 active:opacity-80",
      outline: "border border-border bg-transparent hover:bg-muted hover:text-muted-foreground text-foreground",
      ghost: "hover:bg-muted-foreground/20 text-foreground",
      link: "text-primary underline-offset-4 hover:underline text-primary-foreground",
      icon: "hover:bg-muted-foreground/20 text-foreground rounded-full bg-muted-foreground/10"
    },
    size: {
      sm: "h-6 px-3 text-xs [&_svg]:size-3",
      default: "h-9 px-4 text-sm [&_svg]:size-4",
      md: "h-9 px-4 text-sm [&_svg]:size-4",
      lg: "h-11 px-6 text-base [&_svg]:size-5",
      icon: "h-4 w-4 [&_svg]:size-4"
    }
  },
  defaultVariants: {
    variant: "default",
    size: "default"
  }
});
var Button = (0, import_react.forwardRef)((t0, ref) => {
  const $ = (0, import_compiler_runtime3.c)(16);
  if ($[0] !== "dc9d813c9a7cd4549d9765c8ac1c4cb94d9637ac4c1593debc6787ad7268f2a6") {
    for (let $i = 0; $i < 16; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "dc9d813c9a7cd4549d9765c8ac1c4cb94d9637ac4c1593debc6787ad7268f2a6";
  }
  let className;
  let props2;
  let size;
  let t1;
  let variant;
  if ($[1] !== t0) {
    ({ className, variant, size, asChild: t1, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
    $[4] = size;
    $[5] = t1;
    $[6] = variant;
  } else {
    className = $[2];
    props2 = $[3];
    size = $[4];
    t1 = $[5];
    variant = $[6];
  }
  const Comp = (t1 === void 0 ? false : t1) ? Slot : "button";
  let t2;
  if ($[7] !== className || $[8] !== size || $[9] !== variant) {
    t2 = cn(buttonVariants({
      variant,
      size
    }), className);
    $[7] = className;
    $[8] = size;
    $[9] = variant;
    $[10] = t2;
  } else t2 = $[10];
  let t3;
  if ($[11] !== Comp || $[12] !== props2 || $[13] !== ref || $[14] !== t2) {
    t3 = (0, import_jsx_runtime4.jsx)(Comp, {
      className: t2,
      ref,
      ...props2
    });
    $[11] = Comp;
    $[12] = props2;
    $[13] = ref;
    $[14] = t2;
    $[15] = t3;
  } else t3 = $[15];
  return t3;
});
Button.displayName = "Button";

// node_modules/@motiadev/ui/dist/components/ui/dropdown-menu.js
var import_compiler_runtime4 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_lucide_react = __toESM(require_lucide_react(), 1);

// node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
var React19 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-menu/dist/index.mjs
var React18 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-collection/dist/index.mjs
var import_react2 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-collection/node_modules/@radix-ui/react-slot/dist/index.mjs
var React2 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
function createSlot2(ownerName) {
  const SlotClone = createSlotClone2(ownerName);
  const Slot22 = React2.forwardRef((props2, forwardedRef) => {
    const { children, ...slotProps } = props2;
    const childrenArray = React2.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable2);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React2.Children.count(newElement) > 1) return React2.Children.only(null);
          return React2.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime5.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React2.isValidElement(newElement) ? React2.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime5.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot2 = createSlot2("Slot");
function createSlotClone2(ownerName) {
  const SlotClone = React2.forwardRef((props2, forwardedRef) => {
    const { children, ...slotProps } = props2;
    if (React2.isValidElement(children)) {
      const childrenRef = getElementRef2(children);
      const props22 = mergeProps2(slotProps, children.props);
      if (children.type !== React2.Fragment) {
        props22.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React2.cloneElement(children, props22);
    }
    return React2.Children.count(children) > 1 ? React2.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER2 = /* @__PURE__ */ Symbol("radix.slottable");
function createSlottable2(ownerName) {
  const Slottable22 = ({ children }) => {
    return (0, import_jsx_runtime5.jsx)(import_jsx_runtime5.Fragment, { children });
  };
  Slottable22.displayName = `${ownerName}.Slottable`;
  Slottable22.__radixId = SLOTTABLE_IDENTIFIER2;
  return Slottable22;
}
var Slottable2 = createSlottable2("Slottable");
function isSlottable2(child) {
  return React2.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER2;
}
function mergeProps2(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef2(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-collection/dist/index.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
function createCollection(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope4] = createContextScope(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props2) => {
    const { scope, children } = props2;
    const ref = import_react2.default.useRef(null);
    const itemMap = import_react2.default.useRef(/* @__PURE__ */ new Map()).current;
    return (0, import_jsx_runtime6.jsx)(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot2(COLLECTION_SLOT_NAME);
  const CollectionSlot = import_react2.default.forwardRef(
    (props2, forwardedRef) => {
      const { scope, children } = props2;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return (0, import_jsx_runtime6.jsx)(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot2(ITEM_SLOT_NAME);
  const CollectionItemSlot = import_react2.default.forwardRef(
    (props2, forwardedRef) => {
      const { scope, children, ...itemData } = props2;
      const ref = import_react2.default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      import_react2.default.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return (0, import_jsx_runtime6.jsx)(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection4(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react2.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection4,
    createCollectionScope4
  ];
}

// node_modules/@radix-ui/react-direction/dist/index.mjs
var React4 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var DirectionContext = React4.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React4.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}

// node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React5 = __toESM(require_react(), 1);
var count = 0;
function useFocusGuards() {
  React5.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count++;
    return () => {
      if (count === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React6 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React6.forwardRef((props2, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props2;
  const [container, setContainer] = React6.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React6.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React6.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React6.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React6.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React6.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return (0, import_jsx_runtime9.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index = updatedArray.indexOf(item);
  if (index !== -1) {
    updatedArray.splice(index, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var React7 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS2 = { bubbles: false, cancelable: true };
var GROUP_NAME = "RovingFocusGroup";
var [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME,
  [createCollectionScope]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);
var RovingFocusGroup = React7.forwardRef(
  (props2, forwardedRef) => {
    return (0, import_jsx_runtime10.jsx)(Collection.Provider, { scope: props2.__scopeRovingFocusGroup, children: (0, import_jsx_runtime10.jsx)(Collection.Slot, { scope: props2.__scopeRovingFocusGroup, children: (0, import_jsx_runtime10.jsx)(RovingFocusGroupImpl, { ...props2, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME;
var RovingFocusGroupImpl = React7.forwardRef((props2, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props2;
  const ref = React7.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React7.useState(false);
  const handleEntryFocus = useCallbackRef(onEntryFocus);
  const getItems = useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = React7.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React7.useState(0);
  React7.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return (0, import_jsx_runtime10.jsx)(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React7.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React7.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React7.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React7.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: (0, import_jsx_runtime10.jsx)(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props2.style },
          onMouseDown: composeEventHandlers(props2.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props2.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS2);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst2(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props2.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME = "RovingFocusGroupItem";
var RovingFocusGroupItem = React7.forwardRef(
  (props2, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      children,
      ...itemProps
    } = props2;
    const autoId = useId();
    const id = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = useCollection(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
    React7.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return (0, import_jsx_runtime10.jsx)(
      Collection.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id,
        focusable,
        active,
        children: (0, import_jsx_runtime10.jsx)(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props2.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id);
            }),
            onFocus: composeEventHandlers(props2.onFocus, () => context.onItemFocus(id)),
            onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst2(candidateNodes));
              }
            }),
            children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}
var Root = RovingFocusGroup;
var Item = RovingFocusGroupItem;

// node_modules/@radix-ui/react-menu/node_modules/@radix-ui/react-slot/dist/index.mjs
var React8 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
function createSlot3(ownerName) {
  const SlotClone = createSlotClone3(ownerName);
  const Slot22 = React8.forwardRef((props2, forwardedRef) => {
    const { children, ...slotProps } = props2;
    const childrenArray = React8.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable3);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React8.Children.count(newElement) > 1) return React8.Children.only(null);
          return React8.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime11.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React8.isValidElement(newElement) ? React8.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime11.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot3 = createSlot3("Slot");
function createSlotClone3(ownerName) {
  const SlotClone = React8.forwardRef((props2, forwardedRef) => {
    const { children, ...slotProps } = props2;
    if (React8.isValidElement(children)) {
      const childrenRef = getElementRef3(children);
      const props22 = mergeProps3(slotProps, children.props);
      if (children.type !== React8.Fragment) {
        props22.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React8.cloneElement(children, props22);
    }
    return React8.Children.count(children) > 1 ? React8.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER3 = /* @__PURE__ */ Symbol("radix.slottable");
function createSlottable3(ownerName) {
  const Slottable22 = ({ children }) => {
    return (0, import_jsx_runtime11.jsx)(import_jsx_runtime11.Fragment, { children });
  };
  Slottable22.displayName = `${ownerName}.Slottable`;
  Slottable22.__radixId = SLOTTABLE_IDENTIFIER3;
  return Slottable22;
}
var Slottable3 = createSlottable3("Slottable");
function isSlottable3(child) {
  return React8.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER3;
}
function mergeProps3(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef3(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var React17 = __toESM(require_react());

// node_modules/react-remove-scroll/dist/es2015/UI.js
var React13 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react4 = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react4.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React9 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React9.useLayoutEffect : React9.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// node_modules/use-sidecar/dist/es2015/hoc.js
var React10 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/hook.js
var import_react5 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/renderProp.js
var React11 = __toESM(require_react());
var import_react6 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/exports.js
var React12 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React12.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React13.forwardRef(function(props2, parentRef) {
  var ref = React13.useRef(null);
  var _a = React13.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props2.forwardProps, children = props2.children, className = props2.className, removeScrollBar = props2.removeScrollBar, enabled2 = props2.enabled, shards = props2.shards, sideCar = props2.sideCar, noRelative = props2.noRelative, noIsolation = props2.noIsolation, inert = props2.inert, allowPinchZoom = props2.allowPinchZoom, _b = props2.as, Container2 = _b === void 0 ? "div" : _b, gapMode = props2.gapMode, rest = __rest(props2, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React13.createElement(
    React13.Fragment,
    null,
    enabled2 && React13.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React13.cloneElement(React13.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React13.createElement(Container2, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React16 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React15 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/hook.js
var React14 = __toESM(require_react());

// node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce2 = getNonce();
  if (nonce2) {
    tag.setAttribute("nonce", nonce2);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter2 = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter2 == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter2++;
    },
    remove: function() {
      counter2--;
      if (!counter2 && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React14.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter2 = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter2) ? counter2 : 0;
};
var useLockAttribute = function() {
  React15.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React15.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React15.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props2) {
  var shouldPreventQueue = React16.useRef([]);
  var touchStartRef = React16.useRef([0, 0]);
  var activeAxis = React16.useRef();
  var id = React16.useState(idCounter++)[0];
  var Style2 = React16.useState(styleSingleton)[0];
  var lastProps = React16.useRef(props2);
  React16.useEffect(function() {
    lastProps.current = props2;
  }, [props2]);
  React16.useEffect(function() {
    if (props2.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props2.lockRef.current], (props2.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props2.inert, props2.lockRef.current, props2.shards]);
  var shouldCancelEvent = React16.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var selection = window.getSelection();
    var anchorNode = selection && selection.anchorNode;
    var isTouchingSelection = anchorNode ? anchorNode === target || anchorNode.contains(target) : false;
    if (isTouchingSelection) {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React16.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React16.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React16.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React16.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props2.lockRef.current));
  }, []);
  var scrollTouchMove = React16.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props2.lockRef.current));
  }, []);
  React16.useEffect(function() {
    lockStack.push(Style2);
    props2.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props2.removeScrollBar, inert = props2.inert;
  return React16.createElement(
    React16.Fragment,
    null,
    inert ? React16.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React16.createElement(RemoveScrollBar, { noRelative: props2.noRelative, gapMode: props2.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React17.forwardRef(function(props2, ref) {
  return React17.createElement(RemoveScroll, __assign({}, props2, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/@radix-ui/react-menu/dist/index.mjs
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var SELECTION_KEYS = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection2, useCollection2, createCollectionScope2] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope2,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope = createPopperScope();
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props2) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props2;
  const popperScope = usePopperScope(__scopeMenu);
  const [content, setContent] = React18.useState(null);
  const isUsingKeyboardRef = React18.useRef(false);
  const handleOpenChange = useCallbackRef(onOpenChange);
  const direction = useDirection(dir);
  React18.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return (0, import_jsx_runtime12.jsx)(Root2, { ...popperScope, children: (0, import_jsx_runtime12.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: (0, import_jsx_runtime12.jsx)(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: React18.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME = "MenuAnchor";
var MenuAnchor = React18.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props2;
    const popperScope = usePopperScope(__scopeMenu);
    return (0, import_jsx_runtime12.jsx)(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME;
var PORTAL_NAME = "MenuPortal";
var [PortalProvider, usePortalContext] = createMenuContext(PORTAL_NAME, {
  forceMount: void 0
});
var MenuPortal = (props2) => {
  const { __scopeMenu, forceMount, children, container } = props2;
  const context = useMenuContext(PORTAL_NAME, __scopeMenu);
  return (0, import_jsx_runtime12.jsx)(PortalProvider, { scope: __scopeMenu, forceMount, children: (0, import_jsx_runtime12.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime12.jsx)(Portal, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME);
var MenuContent = React18.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props2.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props2;
    const context = useMenuContext(CONTENT_NAME, props2.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME, props2.__scopeMenu);
    return (0, import_jsx_runtime12.jsx)(Collection2.Provider, { scope: props2.__scopeMenu, children: (0, import_jsx_runtime12.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime12.jsx)(Collection2.Slot, { scope: props2.__scopeMenu, children: rootContext.modal ? (0, import_jsx_runtime12.jsx)(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime12.jsx)(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = React18.forwardRef(
  (props2, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME, props2.__scopeMenu);
    const ref = React18.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React18.useEffect(() => {
      const content = ref.current;
      if (content) return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime12.jsx)(
      MenuContentImpl,
      {
        ...props2,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props2.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = React18.forwardRef((props2, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME, props2.__scopeMenu);
  return (0, import_jsx_runtime12.jsx)(
    MenuContentImpl,
    {
      ...props2,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }
  );
});
var Slot4 = createSlot3("MenuContent.ScrollLock");
var MenuContentImpl = React18.forwardRef(
  (props2, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props2;
    const context = useMenuContext(CONTENT_NAME, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME, __scopeMenu);
    const popperScope = usePopperScope(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const getItems = useCollection2(__scopeMenu);
    const [currentItemId, setCurrentItemId] = React18.useState(null);
    const contentRef = React18.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = React18.useRef(0);
    const searchRef = React18.useRef("");
    const pointerGraceTimerRef = React18.useRef(0);
    const pointerGraceIntentRef = React18.useRef(null);
    const pointerDirRef = React18.useRef("right");
    const lastPointerXRef = React18.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? Combination_default : React18.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot4, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      const search = searchRef.current + key;
      const items = getItems().filter((item) => !item.disabled);
      const currentItem = document.activeElement;
      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;
      const values = items.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    React18.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = React18.useCallback((event) => {
      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;
      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);
    }, []);
    return (0, import_jsx_runtime12.jsx)(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: React18.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: React18.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) return;
            contentRef.current?.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: React18.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: React18.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: (0, import_jsx_runtime12.jsx)(ScrollLockWrapper, { ...scrollLockWrapperProps, children: (0, import_jsx_runtime12.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              event.preventDefault();
              contentRef.current?.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: (0, import_jsx_runtime12.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: (0, import_jsx_runtime12.jsx)(
                  Root,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: (0, import_jsx_runtime12.jsx)(
                      Content,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                          }
                          const content = contentRef.current;
                          if (event.target !== content) return;
                          if (!FIRST_LAST_KEYS.includes(event.key)) return;
                          event.preventDefault();
                          const items = getItems().filter((item) => !item.disabled);
                          const candidateNodes = items.map((item) => item.ref.current);
                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                          focusFirst3(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props2.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props2.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME;
var GROUP_NAME2 = "MenuGroup";
var MenuGroup = React18.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props2;
    return (0, import_jsx_runtime12.jsx)(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME2;
var LABEL_NAME = "MenuLabel";
var MenuLabel = React18.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props2;
    return (0, import_jsx_runtime12.jsx)(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME;
var ITEM_NAME2 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = React18.forwardRef(
  (props2, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props2;
    const ref = React18.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME2, props2.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME2, props2.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = React18.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return (0, import_jsx_runtime12.jsx)(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props2.onClick, handleSelect),
        onPointerDown: (event) => {
          props2.onPointerDown?.(event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props2.onPointerUp, (event) => {
          if (!isPointerDownRef.current) event.currentTarget?.click();
        }),
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ") return;
          if (SELECTION_KEYS.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME2;
var MenuItemImpl = React18.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props2;
    const contentContext = useMenuContentContext(ITEM_NAME2, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const ref = React18.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = React18.useState(false);
    const [textContent, setTextContent] = React18.useState("");
    React18.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return (0, import_jsx_runtime12.jsx)(
      Collection2.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: (0, import_jsx_runtime12.jsx)(Item, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: (0, import_jsx_runtime12.jsx)(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props2.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props2.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props2.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props2.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME = "MenuCheckboxItem";
var MenuCheckboxItem = React18.forwardRef(
  (props2, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props2;
    return (0, import_jsx_runtime12.jsx)(ItemIndicatorProvider, { scope: props2.__scopeMenu, checked, children: (0, import_jsx_runtime12.jsx)(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "MenuRadioGroup";
var [RadioGroupProvider, useRadioGroupContext] = createMenuContext(
  RADIO_GROUP_NAME,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = React18.forwardRef(
  (props2, forwardedRef) => {
    const { value, onValueChange, ...groupProps } = props2;
    const handleValueChange = useCallbackRef(onValueChange);
    return (0, import_jsx_runtime12.jsx)(RadioGroupProvider, { scope: props2.__scopeMenu, value, onValueChange: handleValueChange, children: (0, import_jsx_runtime12.jsx)(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "MenuRadioItem";
var MenuRadioItem = React18.forwardRef(
  (props2, forwardedRef) => {
    const { value, ...radioItemProps } = props2;
    const context = useRadioGroupContext(RADIO_ITEM_NAME, props2.__scopeMenu);
    const checked = value === context.value;
    return (0, import_jsx_runtime12.jsx)(ItemIndicatorProvider, { scope: props2.__scopeMenu, checked, children: (0, import_jsx_runtime12.jsx)(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => context.onValueChange?.(value),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME;
var ITEM_INDICATOR_NAME = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME,
  { checked: false }
);
var MenuItemIndicator = React18.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props2;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);
    return (0, import_jsx_runtime12.jsx)(
      Presence,
      {
        present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
        children: (0, import_jsx_runtime12.jsx)(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SEPARATOR_NAME = "MenuSeparator";
var MenuSeparator = React18.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props2;
    return (0, import_jsx_runtime12.jsx)(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME = "MenuArrow";
var MenuArrow = React18.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props2;
    const popperScope = usePopperScope(__scopeMenu);
    return (0, import_jsx_runtime12.jsx)(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var MenuSub = (props2) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props2;
  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);
  const popperScope = usePopperScope(__scopeMenu);
  const [trigger, setTrigger] = React18.useState(null);
  const [content, setContent] = React18.useState(null);
  const handleOpenChange = useCallbackRef(onOpenChange);
  React18.useEffect(() => {
    if (parentMenuContext.open === false) handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return (0, import_jsx_runtime12.jsx)(Root2, { ...popperScope, children: (0, import_jsx_runtime12.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: (0, import_jsx_runtime12.jsx)(
        MenuSubProvider,
        {
          scope: __scopeMenu,
          contentId: useId(),
          triggerId: useId(),
          trigger,
          onTriggerChange: setTrigger,
          children
        }
      )
    }
  ) });
};
MenuSub.displayName = SUB_NAME;
var SUB_TRIGGER_NAME = "MenuSubTrigger";
var MenuSubTrigger = React18.forwardRef(
  (props2, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME, props2.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props2.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props2.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props2.__scopeMenu);
    const openTimerRef = React18.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props2.__scopeMenu };
    const clearOpenTimer = React18.useCallback(() => {
      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    React18.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    React18.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return (0, import_jsx_runtime12.jsx)(MenuAnchor, { asChild: true, ...scope, children: (0, import_jsx_runtime12.jsx)(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context.open),
        ...props2,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          props2.onClick?.(event);
          if (props2.disabled || event.defaultPrevented) return;
          event.currentTarget.focus();
          if (!context.open) context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props2.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented) return;
            if (!props2.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props2.onPointerLeave,
          whenMouse((event) => {
            clearOpenTimer();
            const contentRect = context.content?.getBoundingClientRect();
            if (contentRect) {
              const side = context.content?.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented) return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props2.disabled || isTypingAhead && event.key === " ") return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            context.content?.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "MenuSubContent";
var MenuSubContent = React18.forwardRef(
  (props2, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props2.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props2;
    const context = useMenuContext(CONTENT_NAME, props2.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME, props2.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props2.__scopeMenu);
    const ref = React18.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return (0, import_jsx_runtime12.jsx)(Collection2.Provider, { scope: props2.__scopeMenu, children: (0, import_jsx_runtime12.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime12.jsx)(Collection2.Slot, { scope: props2.__scopeMenu, children: (0, import_jsx_runtime12.jsx)(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props2.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger) context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props2.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            subContext.trigger?.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst3(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray2(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray2(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root32 = Menu;
var Anchor2 = MenuAnchor;
var Portal3 = MenuPortal;
var Content22 = MenuContent;
var Group = MenuGroup;
var Label = MenuLabel;
var Item2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow2 = MenuArrow;
var Sub = MenuSub;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;

// node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props2) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const triggerRef = React19.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DROPDOWN_MENU_NAME
  });
  return (0, import_jsx_runtime13.jsx)(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId(),
      triggerRef,
      contentId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React19.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: (0, import_jsx_runtime13.jsx)(Root32, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME = "DropdownMenuTrigger";
var DropdownMenuTrigger = React19.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props2;
    const context = useDropdownMenuContext(TRIGGER_NAME, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime13.jsx)(Anchor2, { asChild: true, ...menuScope, children: (0, import_jsx_runtime13.jsx)(
      Primitive.button,
      {
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props2.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open) event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
          if (disabled) return;
          if (["Enter", " "].includes(event.key)) context.onOpenToggle();
          if (event.key === "ArrowDown") context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "DropdownMenuPortal";
var DropdownMenuPortal = (props2) => {
  const { __scopeDropdownMenu, ...portalProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime13.jsx)(Portal3, { ...menuScope, ...portalProps });
};
DropdownMenuPortal.displayName = PORTAL_NAME2;
var CONTENT_NAME2 = "DropdownMenuContent";
var DropdownMenuContent = React19.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props2;
    const context = useDropdownMenuContext(CONTENT_NAME2, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = React19.useRef(false);
    return (0, import_jsx_runtime13.jsx)(
      Content22,
      {
        id: context.contentId,
        "aria-labelledby": context.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props2.onCloseAutoFocus, (event) => {
          if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props2.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props2.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent.displayName = CONTENT_NAME2;
var GROUP_NAME3 = "DropdownMenuGroup";
var DropdownMenuGroup = React19.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props2;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime13.jsx)(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup.displayName = GROUP_NAME3;
var LABEL_NAME2 = "DropdownMenuLabel";
var DropdownMenuLabel = React19.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props2;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime13.jsx)(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel.displayName = LABEL_NAME2;
var ITEM_NAME3 = "DropdownMenuItem";
var DropdownMenuItem = React19.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props2;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime13.jsx)(Item2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem.displayName = ITEM_NAME3;
var CHECKBOX_ITEM_NAME2 = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem = React19.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime13.jsx)(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME2;
var RADIO_GROUP_NAME2 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup = React19.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime13.jsx)(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME2;
var RADIO_ITEM_NAME2 = "DropdownMenuRadioItem";
var DropdownMenuRadioItem = React19.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime13.jsx)(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem.displayName = RADIO_ITEM_NAME2;
var INDICATOR_NAME = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = React19.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime13.jsx)(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME;
var SEPARATOR_NAME2 = "DropdownMenuSeparator";
var DropdownMenuSeparator = React19.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime13.jsx)(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator.displayName = SEPARATOR_NAME2;
var ARROW_NAME2 = "DropdownMenuArrow";
var DropdownMenuArrow = React19.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props2;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return (0, import_jsx_runtime13.jsx)(Arrow2, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow.displayName = ARROW_NAME2;
var DropdownMenuSub = (props2) => {
  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: "DropdownMenuSub"
  });
  return (0, import_jsx_runtime13.jsx)(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
var SUB_TRIGGER_NAME2 = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = React19.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime13.jsx)(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME2;
var SUB_CONTENT_NAME2 = "DropdownMenuSubContent";
var DropdownMenuSubContent = React19.forwardRef((props2, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props2;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return (0, import_jsx_runtime13.jsx)(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props2.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME2;
var Root22 = DropdownMenu;
var Trigger2 = DropdownMenuTrigger;
var Portal22 = DropdownMenuPortal;
var Content23 = DropdownMenuContent;
var Group2 = DropdownMenuGroup;
var Label2 = DropdownMenuLabel;
var Item22 = DropdownMenuItem;
var CheckboxItem2 = DropdownMenuCheckboxItem;
var RadioGroup2 = DropdownMenuRadioGroup;
var RadioItem2 = DropdownMenuRadioItem;
var ItemIndicator2 = DropdownMenuItemIndicator;
var Separator2 = DropdownMenuSeparator;
var Sub2 = DropdownMenuSub;
var SubTrigger2 = DropdownMenuSubTrigger;
var SubContent2 = DropdownMenuSubContent;

// node_modules/@motiadev/ui/dist/components/ui/dropdown-menu.js
var DropdownMenu2 = (t0) => {
  const $ = (0, import_compiler_runtime4.c)(5);
  if ($[0] !== "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40") {
    for (let $i = 0; $i < 5; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40";
  }
  let props2;
  if ($[1] !== t0) {
    ({ ...props2 } = t0);
    $[1] = t0;
    $[2] = props2;
  } else props2 = $[2];
  let t1;
  if ($[3] !== props2) {
    t1 = (0, import_jsx_runtime14.jsx)(Root22, {
      "data-slot": "dropdown-menu",
      ...props2
    });
    $[3] = props2;
    $[4] = t1;
  } else t1 = $[4];
  return t1;
};
var DropdownMenuTrigger2 = (t0) => {
  const $ = (0, import_compiler_runtime4.c)(5);
  if ($[0] !== "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40") {
    for (let $i = 0; $i < 5; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40";
  }
  let props2;
  if ($[1] !== t0) {
    ({ ...props2 } = t0);
    $[1] = t0;
    $[2] = props2;
  } else props2 = $[2];
  let t1;
  if ($[3] !== props2) {
    t1 = (0, import_jsx_runtime14.jsx)(Trigger2, {
      "data-slot": "dropdown-menu-trigger",
      ...props2
    });
    $[3] = props2;
    $[4] = t1;
  } else t1 = $[4];
  return t1;
};
var DropdownMenuContent2 = (t0) => {
  const $ = (0, import_compiler_runtime4.c)(11);
  if ($[0] !== "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40") {
    for (let $i = 0; $i < 11; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40";
  }
  let className;
  let props2;
  let t1;
  if ($[1] !== t0) {
    ({ className, sideOffset: t1, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
    $[4] = t1;
  } else {
    className = $[2];
    props2 = $[3];
    t1 = $[4];
  }
  const sideOffset = t1 === void 0 ? 4 : t1;
  let t2;
  if ($[5] !== className) {
    t2 = cn("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md", className);
    $[5] = className;
    $[6] = t2;
  } else t2 = $[6];
  let t3;
  if ($[7] !== props2 || $[8] !== sideOffset || $[9] !== t2) {
    t3 = (0, import_jsx_runtime14.jsx)(Portal22, { children: (0, import_jsx_runtime14.jsx)(Content23, {
      "data-slot": "dropdown-menu-content",
      sideOffset,
      className: t2,
      ...props2
    }) });
    $[7] = props2;
    $[8] = sideOffset;
    $[9] = t2;
    $[10] = t3;
  } else t3 = $[10];
  return t3;
};
var DropdownMenuGroup2 = (t0) => {
  const $ = (0, import_compiler_runtime4.c)(5);
  if ($[0] !== "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40") {
    for (let $i = 0; $i < 5; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40";
  }
  let props2;
  if ($[1] !== t0) {
    ({ ...props2 } = t0);
    $[1] = t0;
    $[2] = props2;
  } else props2 = $[2];
  let t1;
  if ($[3] !== props2) {
    t1 = (0, import_jsx_runtime14.jsx)(Group2, {
      "data-slot": "dropdown-menu-group",
      ...props2
    });
    $[3] = props2;
    $[4] = t1;
  } else t1 = $[4];
  return t1;
};
var DropdownMenuItem2 = (t0) => {
  const $ = (0, import_compiler_runtime4.c)(13);
  if ($[0] !== "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40") {
    for (let $i = 0; $i < 13; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40";
  }
  let className;
  let inset;
  let props2;
  let t1;
  if ($[1] !== t0) {
    ({ className, inset, variant: t1, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = inset;
    $[4] = props2;
    $[5] = t1;
  } else {
    className = $[2];
    inset = $[3];
    props2 = $[4];
    t1 = $[5];
  }
  const variant = t1 === void 0 ? "default" : t1;
  let t2;
  if ($[6] !== className) {
    t2 = cn("focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", className);
    $[6] = className;
    $[7] = t2;
  } else t2 = $[7];
  let t3;
  if ($[8] !== inset || $[9] !== props2 || $[10] !== t2 || $[11] !== variant) {
    t3 = (0, import_jsx_runtime14.jsx)(Item22, {
      "data-slot": "dropdown-menu-item",
      "data-inset": inset,
      "data-variant": variant,
      className: t2,
      ...props2
    });
    $[8] = inset;
    $[9] = props2;
    $[10] = t2;
    $[11] = variant;
    $[12] = t3;
  } else t3 = $[12];
  return t3;
};
var DropdownMenuCheckboxItem2 = (t0) => {
  const $ = (0, import_compiler_runtime4.c)(14);
  if ($[0] !== "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40") {
    for (let $i = 0; $i < 14; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40";
  }
  let checked;
  let children;
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, children, checked, ...props2 } = t0);
    $[1] = t0;
    $[2] = checked;
    $[3] = children;
    $[4] = className;
    $[5] = props2;
  } else {
    checked = $[2];
    children = $[3];
    className = $[4];
    props2 = $[5];
  }
  let t1;
  if ($[6] !== className) {
    t1 = cn("focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", className);
    $[6] = className;
    $[7] = t1;
  } else t1 = $[7];
  let t2;
  if ($[8] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t2 = (0, import_jsx_runtime14.jsx)("span", {
      className: "pointer-events-none absolute left-2 flex size-3.5 items-center justify-center",
      children: (0, import_jsx_runtime14.jsx)(ItemIndicator2, { children: (0, import_jsx_runtime14.jsx)(import_lucide_react.CheckIcon, { className: "size-4" }) })
    });
    $[8] = t2;
  } else t2 = $[8];
  let t3;
  if ($[9] !== checked || $[10] !== children || $[11] !== props2 || $[12] !== t1) {
    t3 = (0, import_jsx_runtime14.jsxs)(CheckboxItem2, {
      "data-slot": "dropdown-menu-checkbox-item",
      className: t1,
      checked,
      ...props2,
      children: [t2, children]
    });
    $[9] = checked;
    $[10] = children;
    $[11] = props2;
    $[12] = t1;
    $[13] = t3;
  } else t3 = $[13];
  return t3;
};
var DropdownMenuRadioGroup2 = (t0) => {
  const $ = (0, import_compiler_runtime4.c)(5);
  if ($[0] !== "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40") {
    for (let $i = 0; $i < 5; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40";
  }
  let props2;
  if ($[1] !== t0) {
    ({ ...props2 } = t0);
    $[1] = t0;
    $[2] = props2;
  } else props2 = $[2];
  let t1;
  if ($[3] !== props2) {
    t1 = (0, import_jsx_runtime14.jsx)(RadioGroup2, {
      "data-slot": "dropdown-menu-radio-group",
      ...props2
    });
    $[3] = props2;
    $[4] = t1;
  } else t1 = $[4];
  return t1;
};
var DropdownMenuRadioItem2 = (t0) => {
  const $ = (0, import_compiler_runtime4.c)(12);
  if ($[0] !== "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40") {
    for (let $i = 0; $i < 12; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40";
  }
  let children;
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, children, ...props2 } = t0);
    $[1] = t0;
    $[2] = children;
    $[3] = className;
    $[4] = props2;
  } else {
    children = $[2];
    className = $[3];
    props2 = $[4];
  }
  let t1;
  if ($[5] !== className) {
    t1 = cn("focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", className);
    $[5] = className;
    $[6] = t1;
  } else t1 = $[6];
  let t2;
  if ($[7] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t2 = (0, import_jsx_runtime14.jsx)("span", {
      className: "pointer-events-none absolute left-2 flex size-3.5 items-center justify-center",
      children: (0, import_jsx_runtime14.jsx)(ItemIndicator2, { children: (0, import_jsx_runtime14.jsx)(import_lucide_react.CircleIcon, { className: "size-2 fill-current" }) })
    });
    $[7] = t2;
  } else t2 = $[7];
  let t3;
  if ($[8] !== children || $[9] !== props2 || $[10] !== t1) {
    t3 = (0, import_jsx_runtime14.jsxs)(RadioItem2, {
      "data-slot": "dropdown-menu-radio-item",
      className: t1,
      ...props2,
      children: [t2, children]
    });
    $[8] = children;
    $[9] = props2;
    $[10] = t1;
    $[11] = t3;
  } else t3 = $[11];
  return t3;
};
var DropdownMenuLabel2 = (t0) => {
  const $ = (0, import_compiler_runtime4.c)(11);
  if ($[0] !== "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40") {
    for (let $i = 0; $i < 11; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40";
  }
  let className;
  let inset;
  let props2;
  if ($[1] !== t0) {
    ({ className, inset, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = inset;
    $[4] = props2;
  } else {
    className = $[2];
    inset = $[3];
    props2 = $[4];
  }
  let t1;
  if ($[5] !== className) {
    t1 = cn("px-2 py-1.5 text-sm font-medium data-[inset]:pl-8", className);
    $[5] = className;
    $[6] = t1;
  } else t1 = $[6];
  let t2;
  if ($[7] !== inset || $[8] !== props2 || $[9] !== t1) {
    t2 = (0, import_jsx_runtime14.jsx)(Label2, {
      "data-slot": "dropdown-menu-label",
      "data-inset": inset,
      className: t1,
      ...props2
    });
    $[7] = inset;
    $[8] = props2;
    $[9] = t1;
    $[10] = t2;
  } else t2 = $[10];
  return t2;
};
var DropdownMenuSeparator2 = (t0) => {
  const $ = (0, import_compiler_runtime4.c)(9);
  if ($[0] !== "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("bg-border -mx-1 my-1 h-px", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== t1) {
    t2 = (0, import_jsx_runtime14.jsx)(Separator2, {
      "data-slot": "dropdown-menu-separator",
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = t1;
    $[8] = t2;
  } else t2 = $[8];
  return t2;
};
var DropdownMenuSub2 = (t0) => {
  const $ = (0, import_compiler_runtime4.c)(5);
  if ($[0] !== "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40") {
    for (let $i = 0; $i < 5; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40";
  }
  let props2;
  if ($[1] !== t0) {
    ({ ...props2 } = t0);
    $[1] = t0;
    $[2] = props2;
  } else props2 = $[2];
  let t1;
  if ($[3] !== props2) {
    t1 = (0, import_jsx_runtime14.jsx)(Sub2, {
      "data-slot": "dropdown-menu-sub",
      ...props2
    });
    $[3] = props2;
    $[4] = t1;
  } else t1 = $[4];
  return t1;
};
var DropdownMenuSubTrigger2 = (t0) => {
  const $ = (0, import_compiler_runtime4.c)(14);
  if ($[0] !== "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40") {
    for (let $i = 0; $i < 14; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40";
  }
  let children;
  let className;
  let inset;
  let props2;
  if ($[1] !== t0) {
    ({ className, inset, children, ...props2 } = t0);
    $[1] = t0;
    $[2] = children;
    $[3] = className;
    $[4] = inset;
    $[5] = props2;
  } else {
    children = $[2];
    className = $[3];
    inset = $[4];
    props2 = $[5];
  }
  let t1;
  if ($[6] !== className) {
    t1 = cn("focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8", className);
    $[6] = className;
    $[7] = t1;
  } else t1 = $[7];
  let t2;
  if ($[8] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t2 = (0, import_jsx_runtime14.jsx)(import_lucide_react.ChevronRightIcon, { className: "ml-auto size-4" });
    $[8] = t2;
  } else t2 = $[8];
  let t3;
  if ($[9] !== children || $[10] !== inset || $[11] !== props2 || $[12] !== t1) {
    t3 = (0, import_jsx_runtime14.jsxs)(SubTrigger2, {
      "data-slot": "dropdown-menu-sub-trigger",
      "data-inset": inset,
      className: t1,
      ...props2,
      children: [children, t2]
    });
    $[9] = children;
    $[10] = inset;
    $[11] = props2;
    $[12] = t1;
    $[13] = t3;
  } else t3 = $[13];
  return t3;
};
var DropdownMenuSubContent2 = (t0) => {
  const $ = (0, import_compiler_runtime4.c)(9);
  if ($[0] !== "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "cc5176081ffdf21e1c4aaae4b991a5a2bb0db137f11d07543b3f43f2bf26fe40";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== t1) {
    t2 = (0, import_jsx_runtime14.jsx)(SubContent2, {
      "data-slot": "dropdown-menu-sub-content",
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = t1;
    $[8] = t2;
  } else t2 = $[8];
  return t2;
};

// node_modules/@motiadev/ui/dist/components/ui/breadcrumb.js
var import_compiler_runtime5 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_lucide_react2 = __toESM(require_lucide_react(), 1);
var React$1 = __toESM(require_react(), 1);
var BreadcrumbItem = (t0) => {
  const $ = (0, import_compiler_runtime5.c)(19);
  if ($[0] !== "ce99450bed3ba349f13f3a196f9e2966c468ab2f6e5f14a8811670951dfe38e3") {
    for (let $i = 0; $i < 19; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "ce99450bed3ba349f13f3a196f9e2966c468ab2f6e5f14a8811670951dfe38e3";
  }
  const { label, onClick, isLast, dropdownItems, icon } = t0;
  if (dropdownItems?.length) {
    let t1$1;
    if ($[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
      t1$1 = (0, import_jsx_runtime15.jsx)(import_lucide_react2.ChevronsUpDown, { className: "size-4" });
      $[1] = t1$1;
    } else t1$1 = $[1];
    let t2;
    if ($[2] !== icon || $[3] !== label) {
      t2 = (0, import_jsx_runtime15.jsx)(DropdownMenuTrigger2, {
        asChild: true,
        children: (0, import_jsx_runtime15.jsxs)(Button, {
          variant: "ghost",
          size: "sm",
          className: "p-1 gap-2",
          children: [
            icon,
            label,
            " ",
            t1$1
          ]
        })
      });
      $[2] = icon;
      $[3] = label;
      $[4] = t2;
    } else t2 = $[4];
    let t3;
    if ($[5] !== dropdownItems) {
      t3 = dropdownItems.map(_temp);
      $[5] = dropdownItems;
      $[6] = t3;
    } else t3 = $[6];
    let t4;
    if ($[7] !== t3) {
      t4 = (0, import_jsx_runtime15.jsx)(DropdownMenuContent2, {
        className: "bg-background text-foreground",
        children: t3
      });
      $[7] = t3;
      $[8] = t4;
    } else t4 = $[8];
    let t5;
    if ($[9] !== t2 || $[10] !== t4) {
      t5 = (0, import_jsx_runtime15.jsxs)(DropdownMenu2, { children: [t2, t4] });
      $[9] = t2;
      $[10] = t4;
      $[11] = t5;
    } else t5 = $[11];
    return t5;
  }
  if (isLast) {
    let t1$1;
    if ($[12] !== icon || $[13] !== label) {
      t1$1 = (0, import_jsx_runtime15.jsx)(Button, {
        variant: "ghost",
        size: "sm",
        className: "cursor-default hover:bg-transparent hover:text-muted-transparent p-1",
        asChild: true,
        children: (0, import_jsx_runtime15.jsxs)("div", {
          className: "flex items-center gap-2",
          children: [icon, label]
        })
      });
      $[12] = icon;
      $[13] = label;
      $[14] = t1$1;
    } else t1$1 = $[14];
    return t1$1;
  }
  let t1;
  if ($[15] !== icon || $[16] !== label || $[17] !== onClick) {
    t1 = (0, import_jsx_runtime15.jsxs)(Button, {
      onClick,
      variant: "ghost",
      size: "sm",
      className: "p-1 gap-2",
      children: [icon, label]
    });
    $[15] = icon;
    $[16] = label;
    $[17] = onClick;
    $[18] = t1;
  } else t1 = $[18];
  return t1;
};
BreadcrumbItem.displayName = "BreadcrumbItem";
var Breadcrumb = (t0) => {
  const $ = (0, import_compiler_runtime5.c)(16);
  if ($[0] !== "ce99450bed3ba349f13f3a196f9e2966c468ab2f6e5f14a8811670951dfe38e3") {
    for (let $i = 0; $i < 16; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "ce99450bed3ba349f13f3a196f9e2966c468ab2f6e5f14a8811670951dfe38e3";
  }
  let className;
  let items;
  let props2;
  if ($[1] !== t0) {
    ({ className, items, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = items;
    $[4] = props2;
  } else {
    className = $[2];
    items = $[3];
    props2 = $[4];
  }
  const lastIndex = items.length - 1;
  let t1;
  if ($[5] !== className) {
    t1 = cn("flex items-center", className);
    $[5] = className;
    $[6] = t1;
  } else t1 = $[6];
  let t2;
  if ($[7] !== items || $[8] !== lastIndex) {
    let t3$1;
    if ($[10] !== lastIndex) {
      t3$1 = (item, index) => (0, import_jsx_runtime15.jsxs)(React$1.Fragment, { children: [index !== 0 && (0, import_jsx_runtime15.jsx)("span", {
        className: "mx-1.5 text-muted-foreground",
        children: "/"
      }, `${item.label}-separator`), (0, import_jsx_runtime15.jsx)(BreadcrumbItem, {
        label: item.label,
        icon: item.icon,
        isLast: index === lastIndex,
        dropdownItems: item.dropdownItems
      }, `${item.label}-item`)] }, `${item.label}-fragment`);
      $[10] = lastIndex;
      $[11] = t3$1;
    } else t3$1 = $[11];
    t2 = items.map(t3$1);
    $[7] = items;
    $[8] = lastIndex;
    $[9] = t2;
  } else t2 = $[9];
  let t3;
  if ($[12] !== props2 || $[13] !== t1 || $[14] !== t2) {
    t3 = (0, import_jsx_runtime15.jsx)("div", {
      className: t1,
      ...props2,
      children: t2
    });
    $[12] = props2;
    $[13] = t1;
    $[14] = t2;
    $[15] = t3;
  } else t3 = $[15];
  return t3;
};
Breadcrumb.displayName = "Breadcrumb";
function _temp(item) {
  return (0, import_jsx_runtime15.jsxs)(DropdownMenuItem2, {
    className: "cursor-pointer gap-2",
    onClick: item.onClick,
    children: [item.icon, item.label]
  }, `dropdown-${item.label}`);
}

// node_modules/@motiadev/ui/dist/components/ui/checkbox.js
var import_compiler_runtime6 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_lucide_react3 = __toESM(require_lucide_react(), 1);

// node_modules/@radix-ui/react-checkbox/dist/index.mjs
var React21 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-previous/dist/index.mjs
var React20 = __toESM(require_react(), 1);
function usePrevious(value) {
  const ref = React20.useRef({ value, previous: value });
  return React20.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}

// node_modules/@radix-ui/react-checkbox/dist/index.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);
var [CheckboxProviderImpl, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
function CheckboxProvider(props2) {
  const {
    __scopeCheckbox,
    checked: checkedProp,
    children,
    defaultChecked,
    disabled,
    form,
    name,
    onCheckedChange,
    required,
    value = "on",
    // @ts-expect-error
    internal_do_not_use_render
  } = props2;
  const [checked, setChecked] = useControllableState({
    prop: checkedProp,
    defaultProp: defaultChecked ?? false,
    onChange: onCheckedChange,
    caller: CHECKBOX_NAME
  });
  const [control, setControl] = React21.useState(null);
  const [bubbleInput, setBubbleInput] = React21.useState(null);
  const hasConsumerStoppedPropagationRef = React21.useRef(false);
  const isFormControl = control ? !!form || !!control.closest("form") : (
    // We set this to true by default so that events bubble to forms without JS (SSR)
    true
  );
  const context = {
    checked,
    disabled,
    setChecked,
    control,
    setControl,
    name,
    form,
    value,
    hasConsumerStoppedPropagationRef,
    required,
    defaultChecked: isIndeterminate2(defaultChecked) ? false : defaultChecked,
    isFormControl,
    bubbleInput,
    setBubbleInput
  };
  return (0, import_jsx_runtime16.jsx)(
    CheckboxProviderImpl,
    {
      scope: __scopeCheckbox,
      ...context,
      children: isFunction(internal_do_not_use_render) ? internal_do_not_use_render(context) : children
    }
  );
}
var TRIGGER_NAME2 = "CheckboxTrigger";
var CheckboxTrigger = React21.forwardRef(
  ({ __scopeCheckbox, onKeyDown, onClick, ...checkboxProps }, forwardedRef) => {
    const {
      control,
      value,
      disabled,
      checked,
      required,
      setControl,
      setChecked,
      hasConsumerStoppedPropagationRef,
      isFormControl,
      bubbleInput
    } = useCheckboxContext(TRIGGER_NAME2, __scopeCheckbox);
    const composedRefs = useComposedRefs(forwardedRef, setControl);
    const initialCheckedStateRef = React21.useRef(checked);
    React21.useEffect(() => {
      const form = control?.form;
      if (form) {
        const reset = () => setChecked(initialCheckedStateRef.current);
        form.addEventListener("reset", reset);
        return () => form.removeEventListener("reset", reset);
      }
    }, [control, setChecked]);
    return (0, import_jsx_runtime16.jsx)(
      Primitive.button,
      {
        type: "button",
        role: "checkbox",
        "aria-checked": isIndeterminate2(checked) ? "mixed" : checked,
        "aria-required": required,
        "data-state": getState(checked),
        "data-disabled": disabled ? "" : void 0,
        disabled,
        value,
        ...checkboxProps,
        ref: composedRefs,
        onKeyDown: composeEventHandlers(onKeyDown, (event) => {
          if (event.key === "Enter") event.preventDefault();
        }),
        onClick: composeEventHandlers(onClick, (event) => {
          setChecked((prevChecked) => isIndeterminate2(prevChecked) ? true : !prevChecked);
          if (bubbleInput && isFormControl) {
            hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
            if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
          }
        })
      }
    );
  }
);
CheckboxTrigger.displayName = TRIGGER_NAME2;
var Checkbox = React21.forwardRef(
  (props2, forwardedRef) => {
    const {
      __scopeCheckbox,
      name,
      checked,
      defaultChecked,
      required,
      disabled,
      value,
      onCheckedChange,
      form,
      ...checkboxProps
    } = props2;
    return (0, import_jsx_runtime16.jsx)(
      CheckboxProvider,
      {
        __scopeCheckbox,
        checked,
        defaultChecked,
        disabled,
        required,
        onCheckedChange,
        name,
        form,
        value,
        internal_do_not_use_render: ({ isFormControl }) => (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, { children: [
          (0, import_jsx_runtime16.jsx)(
            CheckboxTrigger,
            {
              ...checkboxProps,
              ref: forwardedRef,
              __scopeCheckbox
            }
          ),
          isFormControl && (0, import_jsx_runtime16.jsx)(
            CheckboxBubbleInput,
            {
              __scopeCheckbox
            }
          )
        ] })
      }
    );
  }
);
Checkbox.displayName = CHECKBOX_NAME;
var INDICATOR_NAME2 = "CheckboxIndicator";
var CheckboxIndicator = React21.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeCheckbox, forceMount, ...indicatorProps } = props2;
    const context = useCheckboxContext(INDICATOR_NAME2, __scopeCheckbox);
    return (0, import_jsx_runtime16.jsx)(
      Presence,
      {
        present: forceMount || isIndeterminate2(context.checked) || context.checked === true,
        children: (0, import_jsx_runtime16.jsx)(
          Primitive.span,
          {
            "data-state": getState(context.checked),
            "data-disabled": context.disabled ? "" : void 0,
            ...indicatorProps,
            ref: forwardedRef,
            style: { pointerEvents: "none", ...props2.style }
          }
        )
      }
    );
  }
);
CheckboxIndicator.displayName = INDICATOR_NAME2;
var BUBBLE_INPUT_NAME = "CheckboxBubbleInput";
var CheckboxBubbleInput = React21.forwardRef(
  ({ __scopeCheckbox, ...props2 }, forwardedRef) => {
    const {
      control,
      hasConsumerStoppedPropagationRef,
      checked,
      defaultChecked,
      required,
      disabled,
      name,
      value,
      form,
      bubbleInput,
      setBubbleInput
    } = useCheckboxContext(BUBBLE_INPUT_NAME, __scopeCheckbox);
    const composedRefs = useComposedRefs(forwardedRef, setBubbleInput);
    const prevChecked = usePrevious(checked);
    const controlSize = useSize(control);
    React21.useEffect(() => {
      const input = bubbleInput;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      const bubbles = !hasConsumerStoppedPropagationRef.current;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        input.indeterminate = isIndeterminate2(checked);
        setChecked.call(input, isIndeterminate2(checked) ? false : checked);
        input.dispatchEvent(event);
      }
    }, [bubbleInput, prevChecked, checked, hasConsumerStoppedPropagationRef]);
    const defaultCheckedRef = React21.useRef(isIndeterminate2(checked) ? false : checked);
    return (0, import_jsx_runtime16.jsx)(
      Primitive.input,
      {
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: defaultChecked ?? defaultCheckedRef.current,
        required,
        disabled,
        name,
        value,
        form,
        ...props2,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props2.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0,
          // We transform because the input is absolutely positioned but we have
          // rendered it **after** the button. This pulls it back to sit on top
          // of the button.
          transform: "translateX(-100%)"
        }
      }
    );
  }
);
CheckboxBubbleInput.displayName = BUBBLE_INPUT_NAME;
function isFunction(value) {
  return typeof value === "function";
}
function isIndeterminate2(checked) {
  return checked === "indeterminate";
}
function getState(checked) {
  return isIndeterminate2(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}

// node_modules/@motiadev/ui/dist/components/ui/checkbox.js
var Checkbox2 = (t0) => {
  const $ = (0, import_compiler_runtime6.c)(10);
  if ($[0] !== "5168a54f61482e8bc426eb511b26efdd2b782bce3d75ba4a7ace2f9081dc75c9") {
    for (let $i = 0; $i < 10; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "5168a54f61482e8bc426eb511b26efdd2b782bce3d75ba4a7ace2f9081dc75c9";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("cursor-pointer peer border-border dark:bg-input data-[state=checked]:bg-primary data-[state=checked]:text-white dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t2 = (0, import_jsx_runtime17.jsx)(CheckboxIndicator, {
      "data-slot": "checkbox-indicator",
      className: "flex items-center justify-center text-current transition-none",
      children: (0, import_jsx_runtime17.jsx)(import_lucide_react3.CheckIcon, { className: "size-3.5" })
    });
    $[6] = t2;
  } else t2 = $[6];
  let t3;
  if ($[7] !== props2 || $[8] !== t1) {
    t3 = (0, import_jsx_runtime17.jsx)(Checkbox, {
      "data-slot": "checkbox",
      className: t1,
      ...props2,
      children: t2
    });
    $[7] = props2;
    $[8] = t1;
    $[9] = t3;
  } else t3 = $[9];
  return t3;
};

// node_modules/@motiadev/ui/dist/components/ui/container.js
var import_compiler_runtime7 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var Container = (0, import_react7.forwardRef)((t0, ref) => {
  const $ = (0, import_compiler_runtime7.c)(12);
  if ($[0] !== "8800013f57da6767f5e0125610a795ba251523cf41afeeea0834c2ee7f15f882") {
    for (let $i = 0; $i < 12; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "8800013f57da6767f5e0125610a795ba251523cf41afeeea0834c2ee7f15f882";
  }
  let children;
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, children, ...props2 } = t0);
    $[1] = t0;
    $[2] = children;
    $[3] = className;
    $[4] = props2;
  } else {
    children = $[2];
    className = $[3];
    props2 = $[4];
  }
  let t1;
  if ($[5] !== className) {
    t1 = cn("relative border border-border text-foreground rounded-lg overflow-hidden flex flex-col h-full", className);
    $[5] = className;
    $[6] = t1;
  } else t1 = $[6];
  let t2;
  if ($[7] !== children || $[8] !== props2 || $[9] !== ref || $[10] !== t1) {
    t2 = (0, import_jsx_runtime18.jsx)("div", {
      ref,
      className: t1,
      ...props2,
      children
    });
    $[7] = children;
    $[8] = props2;
    $[9] = ref;
    $[10] = t1;
    $[11] = t2;
  } else t2 = $[11];
  return t2;
});
Container.displayName = "Container";
var containerHeaderVariants = cva("isolate w-full bg-card flex min-h-10 items-center", {
  variants: { variant: {
    default: "px-5 py-2 items-center",
    tabs: "p-0"
  } },
  defaultVariants: { variant: "default" }
});
var ContainerHeader = (0, import_react7.forwardRef)((t0, ref) => {
  const $ = (0, import_compiler_runtime7.c)(15);
  if ($[0] !== "8800013f57da6767f5e0125610a795ba251523cf41afeeea0834c2ee7f15f882") {
    for (let $i = 0; $i < 15; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "8800013f57da6767f5e0125610a795ba251523cf41afeeea0834c2ee7f15f882";
  }
  let children;
  let className;
  let props2;
  let variant;
  if ($[1] !== t0) {
    ({ className, variant, children, ...props2 } = t0);
    $[1] = t0;
    $[2] = children;
    $[3] = className;
    $[4] = props2;
    $[5] = variant;
  } else {
    children = $[2];
    className = $[3];
    props2 = $[4];
    variant = $[5];
  }
  let t1;
  if ($[6] !== className || $[7] !== variant) {
    t1 = cn(containerHeaderVariants({
      variant,
      className
    }));
    $[6] = className;
    $[7] = variant;
    $[8] = t1;
  } else t1 = $[8];
  let t2;
  if ($[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t2 = (0, import_jsx_runtime18.jsx)(BackgroundEffect, {});
    $[9] = t2;
  } else t2 = $[9];
  let t3;
  if ($[10] !== children || $[11] !== props2 || $[12] !== ref || $[13] !== t1) {
    t3 = (0, import_jsx_runtime18.jsxs)("div", {
      ref,
      className: t1,
      ...props2,
      children: [t2, children]
    });
    $[10] = children;
    $[11] = props2;
    $[12] = ref;
    $[13] = t1;
    $[14] = t3;
  } else t3 = $[14];
  return t3;
});
ContainerHeader.displayName = "ContainerHeader";
var ContainerContent = (0, import_react7.forwardRef)((t0, ref) => {
  const $ = (0, import_compiler_runtime7.c)(10);
  if ($[0] !== "8800013f57da6767f5e0125610a795ba251523cf41afeeea0834c2ee7f15f882") {
    for (let $i = 0; $i < 10; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "8800013f57da6767f5e0125610a795ba251523cf41afeeea0834c2ee7f15f882";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("flex-1 overflow-auto bg-default border-border border-t", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== ref || $[8] !== t1) {
    t2 = (0, import_jsx_runtime18.jsx)("div", {
      ref,
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = ref;
    $[8] = t1;
    $[9] = t2;
  } else t2 = $[9];
  return t2;
});
ContainerContent.displayName = "ContainerContent";

// node_modules/@motiadev/ui/dist/components/ui/tabs.js
var import_compiler_runtime8 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-tabs/dist/index.mjs
var React23 = __toESM(require_react(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope2 = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs = React23.forwardRef(
  (props2, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props2;
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue ?? "",
      caller: TABS_NAME
    });
    return (0, import_jsx_runtime19.jsx)(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: (0, import_jsx_runtime19.jsx)(
          Primitive.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList = React23.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props2;
    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeTabs);
    return (0, import_jsx_runtime19.jsx)(
      Root,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context.orientation,
        dir: context.dir,
        loop,
        children: (0, import_jsx_runtime19.jsx)(
          Primitive.div,
          {
            role: "tablist",
            "aria-orientation": context.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList.displayName = TAB_LIST_NAME;
var TRIGGER_NAME3 = "TabsTrigger";
var TabsTrigger = React23.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props2;
    const context = useTabsContext(TRIGGER_NAME3, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    return (0, import_jsx_runtime19.jsx)(
      Item,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: (0, import_jsx_runtime19.jsx)(
          Primitive.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props2.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers(props2.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key)) context.onValueChange(value);
            }),
            onFocus: composeEventHandlers(props2.onFocus, () => {
              const isAutomaticActivation = context.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context.onValueChange(value);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger.displayName = TRIGGER_NAME3;
var CONTENT_NAME3 = "TabsContent";
var TabsContent = React23.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props2;
    const context = useTabsContext(CONTENT_NAME3, __scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    const isMountAnimationPreventedRef = React23.useRef(isSelected);
    React23.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return (0, import_jsx_runtime19.jsx)(Presence, { present: forceMount || isSelected, children: ({ present }) => (0, import_jsx_runtime19.jsx)(
      Primitive.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props2.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent.displayName = CONTENT_NAME3;
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Root23 = Tabs;
var List = TabsList;
var Trigger3 = TabsTrigger;
var Content3 = TabsContent;

// node_modules/@motiadev/ui/dist/components/ui/tabs.js
var Tabs2 = (t0) => {
  const $ = (0, import_compiler_runtime8.c)(9);
  if ($[0] !== "d8cfe3001ea08840f65a3b48e54865b84719dd8dead7f2d80e883e2deeeb4d1f") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "d8cfe3001ea08840f65a3b48e54865b84719dd8dead7f2d80e883e2deeeb4d1f";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("flex flex-col h-full", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== t1) {
    t2 = (0, import_jsx_runtime20.jsx)(Root23, {
      "data-slot": "tabs",
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = t1;
    $[8] = t2;
  } else t2 = $[8];
  return t2;
};
Tabs2.displayName = "Tabs";
var TabsList2 = (t0) => {
  const $ = (0, import_compiler_runtime8.c)(9);
  if ($[0] !== "d8cfe3001ea08840f65a3b48e54865b84719dd8dead7f2d80e883e2deeeb4d1f") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "d8cfe3001ea08840f65a3b48e54865b84719dd8dead7f2d80e883e2deeeb4d1f";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("inline-flex rounded-none bg-transparent p-0 min-h-10", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== t1) {
    t2 = (0, import_jsx_runtime20.jsx)(List, {
      "data-slot": "tabs-list",
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = t1;
    $[8] = t2;
  } else t2 = $[8];
  return t2;
};
TabsList2.displayName = "TabsList";
var TabsTrigger2 = (t0) => {
  const $ = (0, import_compiler_runtime8.c)(9);
  if ($[0] !== "d8cfe3001ea08840f65a3b48e54865b84719dd8dead7f2d80e883e2deeeb4d1f") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "d8cfe3001ea08840f65a3b48e54865b84719dd8dead7f2d80e883e2deeeb4d1f";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("inline-flex items-center justify-center whitespace-nowrap rounded-none px-4 py-2 text-sm font-medium text-muted-foreground ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=active]:text-foreground gap-1.5 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 relative data-[state=active]:after:absolute data-[state=active]:after:bottom-0 data-[state=active]:after:left-1/2 data-[state=active]:after:-translate-x-1/2 data-[state=active]:after:h-0.5 data-[state=active]:after:w-[calc(100%-2.5rem)] data-[state=active]:after:bg-foreground data-[state=active]:after:rounded-full", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== t1) {
    t2 = (0, import_jsx_runtime20.jsx)(Trigger3, {
      "data-slot": "tabs-trigger",
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = t1;
    $[8] = t2;
  } else t2 = $[8];
  return t2;
};
TabsTrigger2.displayName = "TabsTrigger";
var TabsContent2 = (t0) => {
  const $ = (0, import_compiler_runtime8.c)(9);
  if ($[0] !== "d8cfe3001ea08840f65a3b48e54865b84719dd8dead7f2d80e883e2deeeb4d1f") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "d8cfe3001ea08840f65a3b48e54865b84719dd8dead7f2d80e883e2deeeb4d1f";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("flex-1 outline-none text-foreground", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== t1) {
    t2 = (0, import_jsx_runtime20.jsx)(Content3, {
      "data-slot": "tabs-content",
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = t1;
    $[8] = t2;
  } else t2 = $[8];
  return t2;
};
TabsContent2.displayName = "TabsContent";

// node_modules/@motiadev/ui/dist/components/ui/collapsible-panel.js
var import_compiler_runtime9 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_lucide_react4 = __toESM(require_lucide_react(), 1);
var import_react9 = __toESM(require_react(), 1);

// node_modules/react-resizable-panels/dist/react-resizable-panels.browser.development.js
var React24 = __toESM(require_react());
var import_react8 = __toESM(require_react());
var PanelGroupContext = (0, import_react8.createContext)(null);
PanelGroupContext.displayName = "PanelGroupContext";
var DATA_ATTRIBUTES = {
  group: "data-panel-group",
  groupDirection: "data-panel-group-direction",
  groupId: "data-panel-group-id",
  panel: "data-panel",
  panelCollapsible: "data-panel-collapsible",
  panelId: "data-panel-id",
  panelSize: "data-panel-size",
  resizeHandle: "data-resize-handle",
  resizeHandleActive: "data-resize-handle-active",
  resizeHandleEnabled: "data-panel-resize-handle-enabled",
  resizeHandleId: "data-panel-resize-handle-id",
  resizeHandleState: "data-resize-handle-state"
};
var PRECISION = 10;
var useIsomorphicLayoutEffect2 = import_react8.useLayoutEffect;
var useId2 = React24["useId".toString()];
var wrappedUseId = typeof useId2 === "function" ? useId2 : () => null;
var counter = 0;
function useUniqueId(idFromParams = null) {
  const idFromUseId = wrappedUseId();
  const idRef = (0, import_react8.useRef)(idFromParams || idFromUseId || null);
  if (idRef.current === null) {
    idRef.current = "" + counter++;
  }
  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;
}
function PanelWithForwardedRef({
  children,
  className: classNameFromProps = "",
  collapsedSize,
  collapsible,
  defaultSize,
  forwardedRef,
  id: idFromProps,
  maxSize,
  minSize,
  onCollapse,
  onExpand,
  onResize,
  order,
  style: styleFromProps,
  tagName: Type = "div",
  ...rest
}) {
  const context = (0, import_react8.useContext)(PanelGroupContext);
  if (context === null) {
    throw Error(`Panel components must be rendered within a PanelGroup container`);
  }
  const {
    collapsePanel,
    expandPanel,
    getPanelSize,
    getPanelStyle,
    groupId,
    isPanelCollapsed,
    reevaluatePanelConstraints,
    registerPanel,
    resizePanel: resizePanel2,
    unregisterPanel
  } = context;
  const panelId = useUniqueId(idFromProps);
  const panelDataRef = (0, import_react8.useRef)({
    callbacks: {
      onCollapse,
      onExpand,
      onResize
    },
    constraints: {
      collapsedSize,
      collapsible,
      defaultSize,
      maxSize,
      minSize
    },
    id: panelId,
    idIsFromProps: idFromProps !== void 0,
    order
  });
  const devWarningsRef = (0, import_react8.useRef)({
    didLogMissingDefaultSizeWarning: false
  });
  {
    if (!devWarningsRef.current.didLogMissingDefaultSizeWarning) ;
  }
  useIsomorphicLayoutEffect2(() => {
    const {
      callbacks,
      constraints
    } = panelDataRef.current;
    const prevConstraints = {
      ...constraints
    };
    panelDataRef.current.id = panelId;
    panelDataRef.current.idIsFromProps = idFromProps !== void 0;
    panelDataRef.current.order = order;
    callbacks.onCollapse = onCollapse;
    callbacks.onExpand = onExpand;
    callbacks.onResize = onResize;
    constraints.collapsedSize = collapsedSize;
    constraints.collapsible = collapsible;
    constraints.defaultSize = defaultSize;
    constraints.maxSize = maxSize;
    constraints.minSize = minSize;
    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {
      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);
    }
  });
  useIsomorphicLayoutEffect2(() => {
    const panelData = panelDataRef.current;
    registerPanel(panelData);
    return () => {
      unregisterPanel(panelData);
    };
  }, [order, panelId, registerPanel, unregisterPanel]);
  (0, import_react8.useImperativeHandle)(forwardedRef, () => ({
    collapse: () => {
      collapsePanel(panelDataRef.current);
    },
    expand: (minSize2) => {
      expandPanel(panelDataRef.current, minSize2);
    },
    getId() {
      return panelId;
    },
    getSize() {
      return getPanelSize(panelDataRef.current);
    },
    isCollapsed() {
      return isPanelCollapsed(panelDataRef.current);
    },
    isExpanded() {
      return !isPanelCollapsed(panelDataRef.current);
    },
    resize: (size) => {
      resizePanel2(panelDataRef.current, size);
    }
  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel2]);
  const style = getPanelStyle(panelDataRef.current, defaultSize);
  return (0, import_react8.createElement)(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: panelId,
    style: {
      ...style,
      ...styleFromProps
    },
    // CSS selectors
    [DATA_ATTRIBUTES.groupId]: groupId,
    [DATA_ATTRIBUTES.panel]: "",
    [DATA_ATTRIBUTES.panelCollapsible]: collapsible || void 0,
    [DATA_ATTRIBUTES.panelId]: panelId,
    [DATA_ATTRIBUTES.panelSize]: parseFloat("" + style.flexGrow).toFixed(1)
  });
}
var Panel = (0, import_react8.forwardRef)((props2, ref) => (0, import_react8.createElement)(PanelWithForwardedRef, {
  ...props2,
  forwardedRef: ref
}));
PanelWithForwardedRef.displayName = "Panel";
Panel.displayName = "forwardRef(Panel)";
var nonce;
function getNonce2() {
  return nonce;
}
var currentCursorStyle = null;
var enabled = true;
var getCustomCursorStyleFunction = null;
var prevRuleIndex = -1;
var styleElement = null;
function getCursorStyle(state, constraintFlags, isPointerDown2) {
  const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;
  const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;
  const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;
  const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;
  if (getCustomCursorStyleFunction) {
    return getCustomCursorStyleFunction({
      exceedsHorizontalMaximum: horizontalMax,
      exceedsHorizontalMinimum: horizontalMin,
      exceedsVerticalMaximum: verticalMax,
      exceedsVerticalMinimum: verticalMin,
      intersectsHorizontalDragHandle: state === "horizontal" || state === "intersection",
      intersectsVerticalDragHandle: state === "vertical" || state === "intersection",
      isPointerDown: isPointerDown2
    });
  }
  if (constraintFlags) {
    if (horizontalMin) {
      if (verticalMin) {
        return "se-resize";
      } else if (verticalMax) {
        return "ne-resize";
      } else {
        return "e-resize";
      }
    } else if (horizontalMax) {
      if (verticalMin) {
        return "sw-resize";
      } else if (verticalMax) {
        return "nw-resize";
      } else {
        return "w-resize";
      }
    } else if (verticalMin) {
      return "s-resize";
    } else if (verticalMax) {
      return "n-resize";
    }
  }
  switch (state) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function resetGlobalCursorStyle() {
  if (styleElement !== null) {
    document.head.removeChild(styleElement);
    currentCursorStyle = null;
    styleElement = null;
    prevRuleIndex = -1;
  }
}
function setGlobalCursorStyle(state, constraintFlags, isPointerDown2) {
  var _styleElement$sheet$i, _styleElement$sheet2;
  if (!enabled) {
    return;
  }
  const style = getCursorStyle(state, constraintFlags, isPointerDown2);
  if (currentCursorStyle === style) {
    return;
  }
  currentCursorStyle = style;
  if (styleElement === null) {
    styleElement = document.createElement("style");
    const nonce2 = getNonce2();
    if (nonce2) {
      styleElement.setAttribute("nonce", nonce2);
    }
    document.head.appendChild(styleElement);
  }
  if (prevRuleIndex >= 0) {
    var _styleElement$sheet;
    (_styleElement$sheet = styleElement.sheet) === null || _styleElement$sheet === void 0 ? void 0 : _styleElement$sheet.removeRule(prevRuleIndex);
  }
  prevRuleIndex = (_styleElement$sheet$i = (_styleElement$sheet2 = styleElement.sheet) === null || _styleElement$sheet2 === void 0 ? void 0 : _styleElement$sheet2.insertRule(`*{cursor: ${style} !important;}`)) !== null && _styleElement$sheet$i !== void 0 ? _styleElement$sheet$i : -1;
}
function isKeyDown(event) {
  return event.type === "keydown";
}
function isPointerEvent(event) {
  return event.type.startsWith("pointer");
}
function isMouseEvent(event) {
  return event.type.startsWith("mouse");
}
function getResizeEventCoordinates(event) {
  if (isPointerEvent(event)) {
    if (event.isPrimary) {
      return {
        x: event.clientX,
        y: event.clientY
      };
    }
  } else if (isMouseEvent(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  return {
    x: Infinity,
    y: Infinity
  };
}
function getInputType() {
  if (typeof matchMedia === "function") {
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
  }
}
function intersects(rectOne, rectTwo, strict) {
  if (strict) {
    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;
  } else {
    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;
  }
}
function compare(a, b) {
  if (a === b) throw new Error("Cannot compare node with itself");
  const ancestors = {
    a: get_ancestors(a),
    b: get_ancestors(b)
  };
  let common_ancestor;
  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {
    a = ancestors.a.pop();
    b = ancestors.b.pop();
    common_ancestor = a;
  }
  assert(common_ancestor, "Stacking order can only be calculated for elements with a common ancestor");
  const z_indexes = {
    a: get_z_index(find_stacking_context(ancestors.a)),
    b: get_z_index(find_stacking_context(ancestors.b))
  };
  if (z_indexes.a === z_indexes.b) {
    const children = common_ancestor.childNodes;
    const furthest_ancestors = {
      a: ancestors.a.at(-1),
      b: ancestors.b.at(-1)
    };
    let i = children.length;
    while (i--) {
      const child = children[i];
      if (child === furthest_ancestors.a) return 1;
      if (child === furthest_ancestors.b) return -1;
    }
  }
  return Math.sign(z_indexes.a - z_indexes.b);
}
var props = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function is_flex_item(node) {
  var _get_parent;
  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;
  return display === "flex" || display === "inline-flex";
}
function creates_stacking_context(node) {
  const style = getComputedStyle(node);
  if (style.position === "fixed") return true;
  if (style.zIndex !== "auto" && (style.position !== "static" || is_flex_item(node))) return true;
  if (+style.opacity < 1) return true;
  if ("transform" in style && style.transform !== "none") return true;
  if ("webkitTransform" in style && style.webkitTransform !== "none") return true;
  if ("mixBlendMode" in style && style.mixBlendMode !== "normal") return true;
  if ("filter" in style && style.filter !== "none") return true;
  if ("webkitFilter" in style && style.webkitFilter !== "none") return true;
  if ("isolation" in style && style.isolation === "isolate") return true;
  if (props.test(style.willChange)) return true;
  if (style.webkitOverflowScrolling === "touch") return true;
  return false;
}
function find_stacking_context(nodes) {
  let i = nodes.length;
  while (i--) {
    const node = nodes[i];
    assert(node, "Missing node");
    if (creates_stacking_context(node)) return node;
  }
  return null;
}
function get_z_index(node) {
  return node && Number(getComputedStyle(node).zIndex) || 0;
}
function get_ancestors(node) {
  const ancestors = [];
  while (node) {
    ancestors.push(node);
    node = get_parent(node);
  }
  return ancestors;
}
function get_parent(node) {
  const {
    parentNode
  } = node;
  if (parentNode && parentNode instanceof ShadowRoot) {
    return parentNode.host;
  }
  return parentNode;
}
var EXCEEDED_HORIZONTAL_MIN = 1;
var EXCEEDED_HORIZONTAL_MAX = 2;
var EXCEEDED_VERTICAL_MIN = 4;
var EXCEEDED_VERTICAL_MAX = 8;
var isCoarsePointer = getInputType() === "coarse";
var intersectingHandles = [];
var isPointerDown = false;
var ownerDocumentCounts = /* @__PURE__ */ new Map();
var panelConstraintFlags = /* @__PURE__ */ new Map();
var registeredResizeHandlers = /* @__PURE__ */ new Set();
function registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {
  var _ownerDocumentCounts$;
  const {
    ownerDocument
  } = element;
  const data = {
    direction,
    element,
    hitAreaMargins,
    setResizeHandlerState
  };
  const count2 = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;
  ownerDocumentCounts.set(ownerDocument, count2 + 1);
  registeredResizeHandlers.add(data);
  updateListeners();
  return function unregisterResizeHandle() {
    var _ownerDocumentCounts$2;
    panelConstraintFlags.delete(resizeHandleId);
    registeredResizeHandlers.delete(data);
    const count3 = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;
    ownerDocumentCounts.set(ownerDocument, count3 - 1);
    updateListeners();
    if (count3 === 1) {
      ownerDocumentCounts.delete(ownerDocument);
    }
    if (intersectingHandles.includes(data)) {
      const index = intersectingHandles.indexOf(data);
      if (index >= 0) {
        intersectingHandles.splice(index, 1);
      }
      updateCursor();
      setResizeHandlerState("up", true, null);
    }
  };
}
function handlePointerDown(event) {
  const {
    target
  } = event;
  const {
    x,
    y
  } = getResizeEventCoordinates(event);
  isPointerDown = true;
  recalculateIntersectingHandles({
    target,
    x,
    y
  });
  updateListeners();
  if (intersectingHandles.length > 0) {
    updateResizeHandlerStates("down", event);
    updateCursor();
    event.preventDefault();
    if (!isWithinResizeHandle(target)) {
      event.stopImmediatePropagation();
    }
  }
}
function handlePointerMove(event) {
  const {
    x,
    y
  } = getResizeEventCoordinates(event);
  if (isPointerDown && // Skip this check for "pointerleave" events, else Firefox triggers a false positive (see #514)
  event.type !== "pointerleave" && event.buttons === 0) {
    isPointerDown = false;
    updateResizeHandlerStates("up", event);
  }
  if (!isPointerDown) {
    const {
      target
    } = event;
    recalculateIntersectingHandles({
      target,
      x,
      y
    });
  }
  updateResizeHandlerStates("move", event);
  updateCursor();
  if (intersectingHandles.length > 0) {
    event.preventDefault();
  }
}
function handlePointerUp(event) {
  const {
    target
  } = event;
  const {
    x,
    y
  } = getResizeEventCoordinates(event);
  panelConstraintFlags.clear();
  isPointerDown = false;
  if (intersectingHandles.length > 0) {
    event.preventDefault();
    if (!isWithinResizeHandle(target)) {
      event.stopImmediatePropagation();
    }
  }
  updateResizeHandlerStates("up", event);
  recalculateIntersectingHandles({
    target,
    x,
    y
  });
  updateCursor();
  updateListeners();
}
function isWithinResizeHandle(element) {
  let currentElement = element;
  while (currentElement) {
    if (currentElement.hasAttribute(DATA_ATTRIBUTES.resizeHandle)) {
      return true;
    }
    currentElement = currentElement.parentElement;
  }
  return false;
}
function recalculateIntersectingHandles({
  target,
  x,
  y
}) {
  intersectingHandles.splice(0);
  let targetElement = null;
  if (target instanceof HTMLElement || target instanceof SVGElement) {
    targetElement = target;
  }
  registeredResizeHandlers.forEach((data) => {
    const {
      element: dragHandleElement,
      hitAreaMargins
    } = data;
    const dragHandleRect = dragHandleElement.getBoundingClientRect();
    const {
      bottom,
      left,
      right,
      top
    } = dragHandleRect;
    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;
    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;
    if (eventIntersects) {
      if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      compare(targetElement, dragHandleElement) > 0) {
        let currentElement = targetElement;
        let didIntersect = false;
        while (currentElement) {
          if (currentElement.contains(dragHandleElement)) {
            break;
          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {
            didIntersect = true;
            break;
          }
          currentElement = currentElement.parentElement;
        }
        if (didIntersect) {
          return;
        }
      }
      intersectingHandles.push(data);
    }
  });
}
function reportConstraintsViolation(resizeHandleId, flag) {
  panelConstraintFlags.set(resizeHandleId, flag);
}
function updateCursor() {
  let intersectsHorizontal = false;
  let intersectsVertical = false;
  intersectingHandles.forEach((data) => {
    const {
      direction
    } = data;
    if (direction === "horizontal") {
      intersectsHorizontal = true;
    } else {
      intersectsVertical = true;
    }
  });
  let constraintFlags = 0;
  panelConstraintFlags.forEach((flag) => {
    constraintFlags |= flag;
  });
  if (intersectsHorizontal && intersectsVertical) {
    setGlobalCursorStyle("intersection", constraintFlags, isPointerDown);
  } else if (intersectsHorizontal) {
    setGlobalCursorStyle("horizontal", constraintFlags, isPointerDown);
  } else if (intersectsVertical) {
    setGlobalCursorStyle("vertical", constraintFlags, isPointerDown);
  } else {
    resetGlobalCursorStyle();
  }
}
var listenersAbortController;
function updateListeners() {
  var _listenersAbortContro;
  (_listenersAbortContro = listenersAbortController) === null || _listenersAbortContro === void 0 ? void 0 : _listenersAbortContro.abort();
  listenersAbortController = new AbortController();
  const options = {
    capture: true,
    signal: listenersAbortController.signal
  };
  if (!registeredResizeHandlers.size) {
    return;
  }
  if (isPointerDown) {
    if (intersectingHandles.length > 0) {
      ownerDocumentCounts.forEach((count2, ownerDocument) => {
        const {
          body
        } = ownerDocument;
        if (count2 > 0) {
          body.addEventListener("contextmenu", handlePointerUp, options);
          body.addEventListener("pointerleave", handlePointerMove, options);
          body.addEventListener("pointermove", handlePointerMove, options);
        }
      });
    }
    ownerDocumentCounts.forEach((_, ownerDocument) => {
      const {
        body
      } = ownerDocument;
      body.addEventListener("pointerup", handlePointerUp, options);
      body.addEventListener("pointercancel", handlePointerUp, options);
    });
  } else {
    ownerDocumentCounts.forEach((count2, ownerDocument) => {
      const {
        body
      } = ownerDocument;
      if (count2 > 0) {
        body.addEventListener("pointerdown", handlePointerDown, options);
        body.addEventListener("pointermove", handlePointerMove, options);
      }
    });
  }
}
function updateResizeHandlerStates(action, event) {
  registeredResizeHandlers.forEach((data) => {
    const {
      setResizeHandlerState
    } = data;
    const isActive = intersectingHandles.includes(data);
    setResizeHandlerState(action, isActive, event);
  });
}
function useForceUpdate() {
  const [_, setCount] = (0, import_react8.useState)(0);
  return (0, import_react8.useCallback)(() => setCount((prevCount) => prevCount + 1), []);
}
function assert(expectedCondition, message) {
  if (!expectedCondition) {
    console.error(message);
    throw Error(message);
  }
}
function fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {
  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {
    return 0;
  } else {
    return actual > expected ? 1 : -1;
  }
}
function fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}
function fuzzyNumbersEqual(actual, expected, fractionDigits) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}
function fuzzyLayoutsEqual(actual, expected, fractionDigits) {
  if (actual.length !== expected.length) {
    return false;
  }
  for (let index = 0; index < actual.length; index++) {
    const actualSize = actual[index];
    const expectedSize = expected[index];
    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {
      return false;
    }
  }
  return true;
}
function resizePanel({
  panelConstraints: panelConstraintsArray,
  panelIndex,
  size
}) {
  const panelConstraints = panelConstraintsArray[panelIndex];
  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);
  let {
    collapsedSize = 0,
    collapsible,
    maxSize = 100,
    minSize = 0
  } = panelConstraints;
  if (fuzzyCompareNumbers(size, minSize) < 0) {
    if (collapsible) {
      const halfwayPoint = (collapsedSize + minSize) / 2;
      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {
        size = collapsedSize;
      } else {
        size = minSize;
      }
    } else {
      size = minSize;
    }
  }
  size = Math.min(maxSize, size);
  size = parseFloat(size.toFixed(PRECISION));
  return size;
}
function adjustLayoutByDelta({
  delta,
  initialLayout,
  panelConstraints: panelConstraintsArray,
  pivotIndices,
  prevLayout,
  trigger
}) {
  if (fuzzyNumbersEqual(delta, 0)) {
    return initialLayout;
  }
  const nextLayout = [...initialLayout];
  const [firstPivotIndex, secondPivotIndex] = pivotIndices;
  assert(firstPivotIndex != null, "Invalid first pivot index");
  assert(secondPivotIndex != null, "Invalid second pivot index");
  let deltaApplied = 0;
  {
    if (trigger === "keyboard") {
      {
        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;
        const panelConstraints = panelConstraintsArray[index];
        assert(panelConstraints, `Panel constraints not found for index ${index}`);
        const {
          collapsedSize = 0,
          collapsible,
          minSize = 0
        } = panelConstraints;
        if (collapsible) {
          const prevSize = initialLayout[index];
          assert(prevSize != null, `Previous layout not found for panel index ${index}`);
          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {
            const localDelta = minSize - prevSize;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
      {
        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;
        const panelConstraints = panelConstraintsArray[index];
        assert(panelConstraints, `No panel constraints found for index ${index}`);
        const {
          collapsedSize = 0,
          collapsible,
          minSize = 0
        } = panelConstraints;
        if (collapsible) {
          const prevSize = initialLayout[index];
          assert(prevSize != null, `Previous layout not found for panel index ${index}`);
          if (fuzzyNumbersEqual(prevSize, minSize)) {
            const localDelta = prevSize - collapsedSize;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
    }
  }
  {
    const increment = delta < 0 ? 1 : -1;
    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;
    let maxAvailableDelta = 0;
    while (true) {
      const prevSize = initialLayout[index];
      assert(prevSize != null, `Previous layout not found for panel index ${index}`);
      const maxSafeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index,
        size: 100
      });
      const delta2 = maxSafeSize - prevSize;
      maxAvailableDelta += delta2;
      index += increment;
      if (index < 0 || index >= panelConstraintsArray.length) {
        break;
      }
    }
    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));
    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;
  }
  {
    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;
    let index = pivotIndex;
    while (index >= 0 && index < panelConstraintsArray.length) {
      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);
      const prevSize = initialLayout[index];
      assert(prevSize != null, `Previous layout not found for panel index ${index}`);
      const unsafeSize = prevSize - deltaRemaining;
      const safeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index,
        size: unsafeSize
      });
      if (!fuzzyNumbersEqual(prevSize, safeSize)) {
        deltaApplied += prevSize - safeSize;
        nextLayout[index] = safeSize;
        if (deltaApplied.toFixed(3).localeCompare(Math.abs(delta).toFixed(3), void 0, {
          numeric: true
        }) >= 0) {
          break;
        }
      }
      if (delta < 0) {
        index--;
      } else {
        index++;
      }
    }
  }
  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {
    return prevLayout;
  }
  {
    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;
    const prevSize = initialLayout[pivotIndex];
    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);
    const unsafeSize = prevSize + deltaApplied;
    const safeSize = resizePanel({
      panelConstraints: panelConstraintsArray,
      panelIndex: pivotIndex,
      size: unsafeSize
    });
    nextLayout[pivotIndex] = safeSize;
    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {
      let deltaRemaining = unsafeSize - safeSize;
      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
      let index = pivotIndex2;
      while (index >= 0 && index < panelConstraintsArray.length) {
        const prevSize2 = nextLayout[index];
        assert(prevSize2 != null, `Previous layout not found for panel index ${index}`);
        const unsafeSize2 = prevSize2 + deltaRemaining;
        const safeSize2 = resizePanel({
          panelConstraints: panelConstraintsArray,
          panelIndex: index,
          size: unsafeSize2
        });
        if (!fuzzyNumbersEqual(prevSize2, safeSize2)) {
          deltaRemaining -= safeSize2 - prevSize2;
          nextLayout[index] = safeSize2;
        }
        if (fuzzyNumbersEqual(deltaRemaining, 0)) {
          break;
        }
        if (delta > 0) {
          index--;
        } else {
          index++;
        }
      }
    }
  }
  const totalSize = nextLayout.reduce((total, size) => size + total, 0);
  if (!fuzzyNumbersEqual(totalSize, 100)) {
    return prevLayout;
  }
  return nextLayout;
}
function calculateAriaValues({
  layout,
  panelsArray,
  pivotIndices
}) {
  let currentMinSize = 0;
  let currentMaxSize = 100;
  let totalMinSize = 0;
  let totalMaxSize = 0;
  const firstIndex = pivotIndices[0];
  assert(firstIndex != null, "No pivot index found");
  panelsArray.forEach((panelData, index) => {
    const {
      constraints
    } = panelData;
    const {
      maxSize = 100,
      minSize = 0
    } = constraints;
    if (index === firstIndex) {
      currentMinSize = minSize;
      currentMaxSize = maxSize;
    } else {
      totalMinSize += minSize;
      totalMaxSize += maxSize;
    }
  });
  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);
  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);
  const valueNow = layout[firstIndex];
  return {
    valueMax,
    valueMin,
    valueNow
  };
}
function getResizeHandleElementsForGroup(groupId, scope = document) {
  return Array.from(scope.querySelectorAll(`[${DATA_ATTRIBUTES.resizeHandleId}][data-panel-group-id="${groupId}"]`));
}
function getResizeHandleElementIndex(groupId, id, scope = document) {
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index = handles.findIndex((handle) => handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId) === id);
  return index !== null && index !== void 0 ? index : null;
}
function determinePivotIndices(groupId, dragHandleId, panelGroupElement) {
  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);
  return index != null ? [index, index + 1] : [-1, -1];
}
function isHTMLElement(target) {
  if (target instanceof HTMLElement) {
    return true;
  }
  return typeof target === "object" && target !== null && "tagName" in target && "getAttribute" in target;
}
function getPanelGroupElement(id, rootElement = document) {
  if (isHTMLElement(rootElement) && rootElement.dataset.panelGroupId == id) {
    return rootElement;
  }
  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id="${id}"]`);
  if (element) {
    return element;
  }
  return null;
}
function getResizeHandleElement(id, scope = document) {
  const element = scope.querySelector(`[${DATA_ATTRIBUTES.resizeHandleId}="${id}"]`);
  if (element) {
    return element;
  }
  return null;
}
function getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {
  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;
  const handle = getResizeHandleElement(handleId, scope);
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index = handle ? handles.indexOf(handle) : -1;
  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;
  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;
  return [idBefore, idAfter];
}
function useWindowSplitterPanelGroupBehavior({
  committedValuesRef,
  eagerValuesRef,
  groupId,
  layout,
  panelDataArray,
  panelGroupElement,
  setLayout
}) {
  const devWarningsRef = (0, import_react8.useRef)({
    didWarnAboutMissingResizeHandle: false
  });
  useIsomorphicLayoutEffect2(() => {
    if (!panelGroupElement) {
      return;
    }
    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);
    for (let index = 0; index < panelDataArray.length - 1; index++) {
      const {
        valueMax,
        valueMin,
        valueNow
      } = calculateAriaValues({
        layout,
        panelsArray: panelDataArray,
        pivotIndices: [index, index + 1]
      });
      const resizeHandleElement = resizeHandleElements[index];
      if (resizeHandleElement == null) {
        {
          const {
            didWarnAboutMissingResizeHandle
          } = devWarningsRef.current;
          if (!didWarnAboutMissingResizeHandle) {
            devWarningsRef.current.didWarnAboutMissingResizeHandle = true;
            console.warn(`WARNING: Missing resize handle for PanelGroup "${groupId}"`);
          }
        }
      } else {
        const panelData = panelDataArray[index];
        assert(panelData, `No panel data found for index "${index}"`);
        resizeHandleElement.setAttribute("aria-controls", panelData.id);
        resizeHandleElement.setAttribute("aria-valuemax", "" + Math.round(valueMax));
        resizeHandleElement.setAttribute("aria-valuemin", "" + Math.round(valueMin));
        resizeHandleElement.setAttribute("aria-valuenow", valueNow != null ? "" + Math.round(valueNow) : "");
      }
    }
    return () => {
      resizeHandleElements.forEach((resizeHandleElement, index) => {
        resizeHandleElement.removeAttribute("aria-controls");
        resizeHandleElement.removeAttribute("aria-valuemax");
        resizeHandleElement.removeAttribute("aria-valuemin");
        resizeHandleElement.removeAttribute("aria-valuenow");
      });
    };
  }, [groupId, layout, panelDataArray, panelGroupElement]);
  (0, import_react8.useEffect)(() => {
    if (!panelGroupElement) {
      return;
    }
    const eagerValues = eagerValuesRef.current;
    assert(eagerValues, `Eager values not found`);
    const {
      panelDataArray: panelDataArray2
    } = eagerValues;
    const groupElement = getPanelGroupElement(groupId, panelGroupElement);
    assert(groupElement != null, `No group found for id "${groupId}"`);
    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);
    assert(handles, `No resize handles found for group id "${groupId}"`);
    const cleanupFunctions = handles.map((handle) => {
      const handleId = handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId);
      assert(handleId, `Resize handle element has no handle id attribute`);
      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray2, panelGroupElement);
      if (idBefore == null || idAfter == null) {
        return () => {
        };
      }
      const onKeyDown = (event) => {
        if (event.defaultPrevented) {
          return;
        }
        switch (event.key) {
          case "Enter": {
            event.preventDefault();
            const index = panelDataArray2.findIndex((panelData) => panelData.id === idBefore);
            if (index >= 0) {
              const panelData = panelDataArray2[index];
              assert(panelData, `No panel data found for index ${index}`);
              const size = layout[index];
              const {
                collapsedSize = 0,
                collapsible,
                minSize = 0
              } = panelData.constraints;
              if (size != null && collapsible) {
                const nextLayout = adjustLayoutByDelta({
                  delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,
                  initialLayout: layout,
                  panelConstraints: panelDataArray2.map((panelData2) => panelData2.constraints),
                  pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),
                  prevLayout: layout,
                  trigger: "keyboard"
                });
                if (layout !== nextLayout) {
                  setLayout(nextLayout);
                }
              }
            }
            break;
          }
        }
      };
      handle.addEventListener("keydown", onKeyDown);
      return () => {
        handle.removeEventListener("keydown", onKeyDown);
      };
    });
    return () => {
      cleanupFunctions.forEach((cleanupFunction) => cleanupFunction());
    };
  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);
}
function areEqual(arrayA, arrayB) {
  if (arrayA.length !== arrayB.length) {
    return false;
  }
  for (let index = 0; index < arrayA.length; index++) {
    if (arrayA[index] !== arrayB[index]) {
      return false;
    }
  }
  return true;
}
function getResizeEventCursorPosition(direction, event) {
  const isHorizontal = direction === "horizontal";
  const {
    x,
    y
  } = getResizeEventCoordinates(event);
  return isHorizontal ? x : y;
}
function calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {
  const isHorizontal = direction === "horizontal";
  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);
  assert(handleElement, `No resize handle element found for id "${dragHandleId}"`);
  const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);
  assert(groupId, `Resize handle element has no group id attribute`);
  let {
    initialCursorPosition
  } = initialDragState;
  const cursorPosition = getResizeEventCursorPosition(direction, event);
  const groupElement = getPanelGroupElement(groupId, panelGroupElement);
  assert(groupElement, `No group element found for id "${groupId}"`);
  const groupRect = groupElement.getBoundingClientRect();
  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;
  const offsetPixels = cursorPosition - initialCursorPosition;
  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;
  return offsetPercentage;
}
function calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {
  if (isKeyDown(event)) {
    const isHorizontal = direction === "horizontal";
    let delta = 0;
    if (event.shiftKey) {
      delta = 100;
    } else if (keyboardResizeBy != null) {
      delta = keyboardResizeBy;
    } else {
      delta = 10;
    }
    let movement = 0;
    switch (event.key) {
      case "ArrowDown":
        movement = isHorizontal ? 0 : delta;
        break;
      case "ArrowLeft":
        movement = isHorizontal ? -delta : 0;
        break;
      case "ArrowRight":
        movement = isHorizontal ? delta : 0;
        break;
      case "ArrowUp":
        movement = isHorizontal ? 0 : -delta;
        break;
      case "End":
        movement = 100;
        break;
      case "Home":
        movement = -100;
        break;
    }
    return movement;
  } else {
    if (initialDragState == null) {
      return 0;
    }
    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);
  }
}
function calculateUnsafeDefaultLayout({
  panelDataArray
}) {
  const layout = Array(panelDataArray.length);
  const panelConstraintsArray = panelDataArray.map((panelData) => panelData.constraints);
  let numPanelsWithSizes = 0;
  let remainingSize = 100;
  for (let index = 0; index < panelDataArray.length; index++) {
    const panelConstraints = panelConstraintsArray[index];
    assert(panelConstraints, `Panel constraints not found for index ${index}`);
    const {
      defaultSize
    } = panelConstraints;
    if (defaultSize != null) {
      numPanelsWithSizes++;
      layout[index] = defaultSize;
      remainingSize -= defaultSize;
    }
  }
  for (let index = 0; index < panelDataArray.length; index++) {
    const panelConstraints = panelConstraintsArray[index];
    assert(panelConstraints, `Panel constraints not found for index ${index}`);
    const {
      defaultSize
    } = panelConstraints;
    if (defaultSize != null) {
      continue;
    }
    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;
    const size = remainingSize / numRemainingPanels;
    numPanelsWithSizes++;
    layout[index] = size;
    remainingSize -= size;
  }
  return layout;
}
function callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {
  layout.forEach((size, index) => {
    const panelData = panelsArray[index];
    assert(panelData, `Panel data not found for index ${index}`);
    const {
      callbacks,
      constraints,
      id: panelId
    } = panelData;
    const {
      collapsedSize = 0,
      collapsible
    } = constraints;
    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];
    if (lastNotifiedSize == null || size !== lastNotifiedSize) {
      panelIdToLastNotifiedSizeMap[panelId] = size;
      const {
        onCollapse,
        onExpand,
        onResize
      } = callbacks;
      if (onResize) {
        onResize(size, lastNotifiedSize);
      }
      if (collapsible && (onCollapse || onExpand)) {
        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {
          onExpand();
        }
        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {
          onCollapse();
        }
      }
    }
  });
}
function compareLayouts(a, b) {
  if (a.length !== b.length) {
    return false;
  } else {
    for (let index = 0; index < a.length; index++) {
      if (a[index] != b[index]) {
        return false;
      }
    }
  }
  return true;
}
function computePanelFlexBoxStyle({
  defaultSize,
  dragState,
  layout,
  panelData,
  panelIndex,
  precision = 3
}) {
  const size = layout[panelIndex];
  let flexGrow;
  if (size == null) {
    flexGrow = defaultSize != void 0 ? defaultSize.toFixed(precision) : "1";
  } else if (panelData.length === 1) {
    flexGrow = "1";
  } else {
    flexGrow = size.toFixed(precision);
  }
  return {
    flexBasis: 0,
    flexGrow,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: dragState !== null ? "none" : void 0
  };
}
function debounce(callback, durationMs = 10) {
  let timeoutId = null;
  let callable = (...args) => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      callback(...args);
    }, durationMs);
  };
  return callable;
}
function initializeDefaultStorage(storageObject) {
  try {
    if (typeof localStorage !== "undefined") {
      storageObject.getItem = (name) => {
        return localStorage.getItem(name);
      };
      storageObject.setItem = (name, value) => {
        localStorage.setItem(name, value);
      };
    } else {
      throw new Error("localStorage not supported in this environment");
    }
  } catch (error) {
    console.error(error);
    storageObject.getItem = () => null;
    storageObject.setItem = () => {
    };
  }
}
function getPanelGroupKey(autoSaveId) {
  return `react-resizable-panels:${autoSaveId}`;
}
function getPanelKey(panels) {
  return panels.map((panel) => {
    const {
      constraints,
      id,
      idIsFromProps,
      order
    } = panel;
    if (idIsFromProps) {
      return id;
    } else {
      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);
    }
  }).sort((a, b) => a.localeCompare(b)).join(",");
}
function loadSerializedPanelGroupState(autoSaveId, storage) {
  try {
    const panelGroupKey = getPanelGroupKey(autoSaveId);
    const serialized = storage.getItem(panelGroupKey);
    if (serialized) {
      const parsed = JSON.parse(serialized);
      if (typeof parsed === "object" && parsed != null) {
        return parsed;
      }
    }
  } catch (error) {
  }
  return null;
}
function loadPanelGroupState(autoSaveId, panels, storage) {
  var _loadSerializedPanelG, _state$panelKey;
  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};
  const panelKey = getPanelKey(panels);
  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;
}
function savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {
  var _loadSerializedPanelG2;
  const panelGroupKey = getPanelGroupKey(autoSaveId);
  const panelKey = getPanelKey(panels);
  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};
  state[panelKey] = {
    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),
    layout: sizes
  };
  try {
    storage.setItem(panelGroupKey, JSON.stringify(state));
  } catch (error) {
    console.error(error);
  }
}
function validatePanelConstraints({
  panelConstraints: panelConstraintsArray,
  panelId,
  panelIndex
}) {
  {
    const warnings = [];
    const panelConstraints = panelConstraintsArray[panelIndex];
    assert(panelConstraints, `No panel constraints found for index ${panelIndex}`);
    const {
      collapsedSize = 0,
      collapsible = false,
      defaultSize,
      maxSize = 100,
      minSize = 0
    } = panelConstraints;
    if (minSize > maxSize) {
      warnings.push(`min size (${minSize}%) should not be greater than max size (${maxSize}%)`);
    }
    if (defaultSize != null) {
      if (defaultSize < 0) {
        warnings.push("default size should not be less than 0");
      } else if (defaultSize < minSize && (!collapsible || defaultSize !== collapsedSize)) {
        warnings.push("default size should not be less than min size");
      }
      if (defaultSize > 100) {
        warnings.push("default size should not be greater than 100");
      } else if (defaultSize > maxSize) {
        warnings.push("default size should not be greater than max size");
      }
    }
    if (collapsedSize > minSize) {
      warnings.push("collapsed size should not be greater than min size");
    }
    if (warnings.length > 0) {
      const name = panelId != null ? `Panel "${panelId}"` : "Panel";
      console.warn(`${name} has an invalid configuration:

${warnings.join("\n")}`);
      return false;
    }
  }
  return true;
}
function validatePanelGroupLayout({
  layout: prevLayout,
  panelConstraints
}) {
  const nextLayout = [...prevLayout];
  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);
  if (nextLayout.length !== panelConstraints.length) {
    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map((size) => `${size}%`).join(", ")}`);
  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0) {
    {
      console.warn(`WARNING: Invalid layout total size: ${nextLayout.map((size) => `${size}%`).join(", ")}. Layout normalization will be applied.`);
    }
    for (let index = 0; index < panelConstraints.length; index++) {
      const unsafeSize = nextLayout[index];
      assert(unsafeSize != null, `No layout data found for index ${index}`);
      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;
      nextLayout[index] = safeSize;
    }
  }
  let remainingSize = 0;
  for (let index = 0; index < panelConstraints.length; index++) {
    const unsafeSize = nextLayout[index];
    assert(unsafeSize != null, `No layout data found for index ${index}`);
    const safeSize = resizePanel({
      panelConstraints,
      panelIndex: index,
      size: unsafeSize
    });
    if (unsafeSize != safeSize) {
      remainingSize += unsafeSize - safeSize;
      nextLayout[index] = safeSize;
    }
  }
  if (!fuzzyNumbersEqual(remainingSize, 0)) {
    for (let index = 0; index < panelConstraints.length; index++) {
      const prevSize = nextLayout[index];
      assert(prevSize != null, `No layout data found for index ${index}`);
      const unsafeSize = prevSize + remainingSize;
      const safeSize = resizePanel({
        panelConstraints,
        panelIndex: index,
        size: unsafeSize
      });
      if (prevSize !== safeSize) {
        remainingSize -= safeSize - prevSize;
        nextLayout[index] = safeSize;
        if (fuzzyNumbersEqual(remainingSize, 0)) {
          break;
        }
      }
    }
  }
  return nextLayout;
}
var LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;
var defaultStorage = {
  getItem: (name) => {
    initializeDefaultStorage(defaultStorage);
    return defaultStorage.getItem(name);
  },
  setItem: (name, value) => {
    initializeDefaultStorage(defaultStorage);
    defaultStorage.setItem(name, value);
  }
};
var debounceMap = {};
function PanelGroupWithForwardedRef({
  autoSaveId = null,
  children,
  className: classNameFromProps = "",
  direction,
  forwardedRef,
  id: idFromProps = null,
  onLayout = null,
  keyboardResizeBy = null,
  storage = defaultStorage,
  style: styleFromProps,
  tagName: Type = "div",
  ...rest
}) {
  const groupId = useUniqueId(idFromProps);
  const panelGroupElementRef = (0, import_react8.useRef)(null);
  const [dragState, setDragState] = (0, import_react8.useState)(null);
  const [layout, setLayout] = (0, import_react8.useState)([]);
  const forceUpdate = useForceUpdate();
  const panelIdToLastNotifiedSizeMapRef = (0, import_react8.useRef)({});
  const panelSizeBeforeCollapseRef = (0, import_react8.useRef)(/* @__PURE__ */ new Map());
  const prevDeltaRef = (0, import_react8.useRef)(0);
  const committedValuesRef = (0, import_react8.useRef)({
    autoSaveId,
    direction,
    dragState,
    id: groupId,
    keyboardResizeBy,
    onLayout,
    storage
  });
  const eagerValuesRef = (0, import_react8.useRef)({
    layout,
    panelDataArray: [],
    panelDataArrayChanged: false
  });
  const devWarningsRef = (0, import_react8.useRef)({
    didLogIdAndOrderWarning: false,
    didLogPanelConstraintsWarning: false,
    prevPanelIds: []
  });
  (0, import_react8.useImperativeHandle)(forwardedRef, () => ({
    getId: () => committedValuesRef.current.id,
    getLayout: () => {
      const {
        layout: layout2
      } = eagerValuesRef.current;
      return layout2;
    },
    setLayout: (unsafeLayout) => {
      const {
        onLayout: onLayout2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      const safeLayout = validatePanelGroupLayout({
        layout: unsafeLayout,
        panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
      });
      if (!areEqual(prevLayout, safeLayout)) {
        setLayout(safeLayout);
        eagerValuesRef.current.layout = safeLayout;
        if (onLayout2) {
          onLayout2(safeLayout);
        }
        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    }
  }), []);
  useIsomorphicLayoutEffect2(() => {
    committedValuesRef.current.autoSaveId = autoSaveId;
    committedValuesRef.current.direction = direction;
    committedValuesRef.current.dragState = dragState;
    committedValuesRef.current.id = groupId;
    committedValuesRef.current.onLayout = onLayout;
    committedValuesRef.current.storage = storage;
  });
  useWindowSplitterPanelGroupBehavior({
    committedValuesRef,
    eagerValuesRef,
    groupId,
    layout,
    panelDataArray: eagerValuesRef.current.panelDataArray,
    setLayout,
    panelGroupElement: panelGroupElementRef.current
  });
  (0, import_react8.useEffect)(() => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    if (autoSaveId) {
      if (layout.length === 0 || layout.length !== panelDataArray.length) {
        return;
      }
      let debouncedSave = debounceMap[autoSaveId];
      if (debouncedSave == null) {
        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);
        debounceMap[autoSaveId] = debouncedSave;
      }
      const clonedPanelDataArray = [...panelDataArray];
      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);
      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);
    }
  }, [autoSaveId, layout, storage]);
  (0, import_react8.useEffect)(() => {
    {
      const {
        panelDataArray
      } = eagerValuesRef.current;
      const {
        didLogIdAndOrderWarning,
        didLogPanelConstraintsWarning,
        prevPanelIds
      } = devWarningsRef.current;
      if (!didLogIdAndOrderWarning) {
        const panelIds = panelDataArray.map(({
          id
        }) => id);
        devWarningsRef.current.prevPanelIds = panelIds;
        const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);
        if (panelsHaveChanged) {
          if (panelDataArray.find(({
            idIsFromProps,
            order
          }) => !idIsFromProps || order == null)) {
            devWarningsRef.current.didLogIdAndOrderWarning = true;
            console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);
          }
        }
      }
      if (!didLogPanelConstraintsWarning) {
        const panelConstraints = panelDataArray.map((panelData) => panelData.constraints);
        for (let panelIndex = 0; panelIndex < panelConstraints.length; panelIndex++) {
          const panelData = panelDataArray[panelIndex];
          assert(panelData, `Panel data not found for index ${panelIndex}`);
          const isValid = validatePanelConstraints({
            panelConstraints,
            panelId: panelData.id,
            panelIndex
          });
          if (!isValid) {
            devWarningsRef.current.didLogPanelConstraintsWarning = true;
            break;
          }
        }
      }
    }
  });
  const collapsePanel = (0, import_react8.useCallback)((panelData) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    if (panelData.constraints.collapsible) {
      const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
      const {
        collapsedSize = 0,
        panelSize,
        pivotIndices
      } = panelDataHelper(panelDataArray, panelData, prevLayout);
      assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);
        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;
        const nextLayout = adjustLayoutByDelta({
          delta,
          initialLayout: prevLayout,
          panelConstraints: panelConstraintsArray,
          pivotIndices,
          prevLayout,
          trigger: "imperative-api"
        });
        if (!compareLayouts(prevLayout, nextLayout)) {
          setLayout(nextLayout);
          eagerValuesRef.current.layout = nextLayout;
          if (onLayout2) {
            onLayout2(nextLayout);
          }
          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
        }
      }
    }
  }, []);
  const expandPanel = (0, import_react8.useCallback)((panelData, minSizeOverride) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    if (panelData.constraints.collapsible) {
      const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
      const {
        collapsedSize = 0,
        panelSize = 0,
        minSize: minSizeFromProps = 0,
        pivotIndices
      } = panelDataHelper(panelDataArray, panelData, prevLayout);
      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;
      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);
        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;
        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;
        const nextLayout = adjustLayoutByDelta({
          delta,
          initialLayout: prevLayout,
          panelConstraints: panelConstraintsArray,
          pivotIndices,
          prevLayout,
          trigger: "imperative-api"
        });
        if (!compareLayouts(prevLayout, nextLayout)) {
          setLayout(nextLayout);
          eagerValuesRef.current.layout = nextLayout;
          if (onLayout2) {
            onLayout2(nextLayout);
          }
          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
        }
      }
    }
  }, []);
  const getPanelSize = (0, import_react8.useCallback)((panelData) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return panelSize;
  }, []);
  const getPanelStyle = (0, import_react8.useCallback)((panelData, defaultSize) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    const panelIndex = findPanelDataIndex(panelDataArray, panelData);
    return computePanelFlexBoxStyle({
      defaultSize,
      dragState,
      layout,
      panelData: panelDataArray,
      panelIndex
    });
  }, [dragState, layout]);
  const isPanelCollapsed = (0, import_react8.useCallback)((panelData) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize = 0,
      collapsible,
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);
  }, []);
  const isPanelExpanded = (0, import_react8.useCallback)((panelData) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize = 0,
      collapsible,
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;
  }, []);
  const registerPanel = (0, import_react8.useCallback)((panelData) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    panelDataArray.push(panelData);
    panelDataArray.sort((panelA, panelB) => {
      const orderA = panelA.order;
      const orderB = panelB.order;
      if (orderA == null && orderB == null) {
        return 0;
      } else if (orderA == null) {
        return -1;
      } else if (orderB == null) {
        return 1;
      } else {
        return orderA - orderB;
      }
    });
    eagerValuesRef.current.panelDataArrayChanged = true;
    forceUpdate();
  }, [forceUpdate]);
  useIsomorphicLayoutEffect2(() => {
    if (eagerValuesRef.current.panelDataArrayChanged) {
      eagerValuesRef.current.panelDataArrayChanged = false;
      const {
        autoSaveId: autoSaveId2,
        onLayout: onLayout2,
        storage: storage2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      let unsafeLayout = null;
      if (autoSaveId2) {
        const state = loadPanelGroupState(autoSaveId2, panelDataArray, storage2);
        if (state) {
          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));
          unsafeLayout = state.layout;
        }
      }
      if (unsafeLayout == null) {
        unsafeLayout = calculateUnsafeDefaultLayout({
          panelDataArray
        });
      }
      const nextLayout = validatePanelGroupLayout({
        layout: unsafeLayout,
        panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
      });
      if (!areEqual(prevLayout, nextLayout)) {
        setLayout(nextLayout);
        eagerValuesRef.current.layout = nextLayout;
        if (onLayout2) {
          onLayout2(nextLayout);
        }
        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    }
  });
  useIsomorphicLayoutEffect2(() => {
    const eagerValues = eagerValuesRef.current;
    return () => {
      eagerValues.layout = [];
    };
  }, []);
  const registerResizeHandle2 = (0, import_react8.useCallback)((dragHandleId) => {
    let isRTL = false;
    const panelGroupElement = panelGroupElementRef.current;
    if (panelGroupElement) {
      const style2 = window.getComputedStyle(panelGroupElement, null);
      if (style2.getPropertyValue("direction") === "rtl") {
        isRTL = true;
      }
    }
    return function resizeHandler(event) {
      event.preventDefault();
      const panelGroupElement2 = panelGroupElementRef.current;
      if (!panelGroupElement2) {
        return () => null;
      }
      const {
        direction: direction2,
        dragState: dragState2,
        id: groupId2,
        keyboardResizeBy: keyboardResizeBy2,
        onLayout: onLayout2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      const {
        initialLayout
      } = dragState2 !== null && dragState2 !== void 0 ? dragState2 : {};
      const pivotIndices = determinePivotIndices(groupId2, dragHandleId, panelGroupElement2);
      let delta = calculateDeltaPercentage(event, dragHandleId, direction2, dragState2, keyboardResizeBy2, panelGroupElement2);
      const isHorizontal = direction2 === "horizontal";
      if (isHorizontal && isRTL) {
        delta = -delta;
      }
      const panelConstraints = panelDataArray.map((panelData) => panelData.constraints);
      const nextLayout = adjustLayoutByDelta({
        delta,
        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,
        panelConstraints,
        pivotIndices,
        prevLayout,
        trigger: isKeyDown(event) ? "keyboard" : "mouse-or-touch"
      });
      const layoutChanged = !compareLayouts(prevLayout, nextLayout);
      if (isPointerEvent(event) || isMouseEvent(event)) {
        if (prevDeltaRef.current != delta) {
          prevDeltaRef.current = delta;
          if (!layoutChanged && delta !== 0) {
            if (isHorizontal) {
              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);
            } else {
              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);
            }
          } else {
            reportConstraintsViolation(dragHandleId, 0);
          }
        }
      }
      if (layoutChanged) {
        setLayout(nextLayout);
        eagerValuesRef.current.layout = nextLayout;
        if (onLayout2) {
          onLayout2(nextLayout);
        }
        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    };
  }, []);
  const resizePanel2 = (0, import_react8.useCallback)((panelData, unsafePanelSize) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
    const {
      panelSize,
      pivotIndices
    } = panelDataHelper(panelDataArray, panelData, prevLayout);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;
    const nextLayout = adjustLayoutByDelta({
      delta,
      initialLayout: prevLayout,
      panelConstraints: panelConstraintsArray,
      pivotIndices,
      prevLayout,
      trigger: "imperative-api"
    });
    if (!compareLayouts(prevLayout, nextLayout)) {
      setLayout(nextLayout);
      eagerValuesRef.current.layout = nextLayout;
      if (onLayout2) {
        onLayout2(nextLayout);
      }
      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
    }
  }, []);
  const reevaluatePanelConstraints = (0, import_react8.useCallback)((panelData, prevConstraints) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize: prevCollapsedSize = 0,
      collapsible: prevCollapsible
    } = prevConstraints;
    const {
      collapsedSize: nextCollapsedSize = 0,
      collapsible: nextCollapsible,
      maxSize: nextMaxSize = 100,
      minSize: nextMinSize = 0
    } = panelData.constraints;
    const {
      panelSize: prevPanelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    if (prevPanelSize == null) {
      return;
    }
    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {
      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {
        resizePanel2(panelData, nextCollapsedSize);
      }
    } else if (prevPanelSize < nextMinSize) {
      resizePanel2(panelData, nextMinSize);
    } else if (prevPanelSize > nextMaxSize) {
      resizePanel2(panelData, nextMaxSize);
    }
  }, [resizePanel2]);
  const startDragging = (0, import_react8.useCallback)((dragHandleId, event) => {
    const {
      direction: direction2
    } = committedValuesRef.current;
    const {
      layout: layout2
    } = eagerValuesRef.current;
    if (!panelGroupElementRef.current) {
      return;
    }
    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);
    assert(handleElement, `Drag handle element not found for id "${dragHandleId}"`);
    const initialCursorPosition = getResizeEventCursorPosition(direction2, event);
    setDragState({
      dragHandleId,
      dragHandleRect: handleElement.getBoundingClientRect(),
      initialCursorPosition,
      initialLayout: layout2
    });
  }, []);
  const stopDragging = (0, import_react8.useCallback)(() => {
    setDragState(null);
  }, []);
  const unregisterPanel = (0, import_react8.useCallback)((panelData) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    const index = findPanelDataIndex(panelDataArray, panelData);
    if (index >= 0) {
      panelDataArray.splice(index, 1);
      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];
      eagerValuesRef.current.panelDataArrayChanged = true;
      forceUpdate();
    }
  }, [forceUpdate]);
  const context = (0, import_react8.useMemo)(() => ({
    collapsePanel,
    direction,
    dragState,
    expandPanel,
    getPanelSize,
    getPanelStyle,
    groupId,
    isPanelCollapsed,
    isPanelExpanded,
    reevaluatePanelConstraints,
    registerPanel,
    registerResizeHandle: registerResizeHandle2,
    resizePanel: resizePanel2,
    startDragging,
    stopDragging,
    unregisterPanel,
    panelGroupElement: panelGroupElementRef.current
  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle2, resizePanel2, startDragging, stopDragging, unregisterPanel]);
  const style = {
    display: "flex",
    flexDirection: direction === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return (0, import_react8.createElement)(PanelGroupContext.Provider, {
    value: context
  }, (0, import_react8.createElement)(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: idFromProps,
    ref: panelGroupElementRef,
    style: {
      ...style,
      ...styleFromProps
    },
    // CSS selectors
    [DATA_ATTRIBUTES.group]: "",
    [DATA_ATTRIBUTES.groupDirection]: direction,
    [DATA_ATTRIBUTES.groupId]: groupId
  }));
}
var PanelGroup = (0, import_react8.forwardRef)((props2, ref) => (0, import_react8.createElement)(PanelGroupWithForwardedRef, {
  ...props2,
  forwardedRef: ref
}));
PanelGroupWithForwardedRef.displayName = "PanelGroup";
PanelGroup.displayName = "forwardRef(PanelGroup)";
function findPanelDataIndex(panelDataArray, panelData) {
  return panelDataArray.findIndex((prevPanelData) => prevPanelData === panelData || prevPanelData.id === panelData.id);
}
function panelDataHelper(panelDataArray, panelData, layout) {
  const panelIndex = findPanelDataIndex(panelDataArray, panelData);
  const isLastPanel = panelIndex === panelDataArray.length - 1;
  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];
  const panelSize = layout[panelIndex];
  return {
    ...panelData.constraints,
    panelSize,
    pivotIndices
  };
}
function useWindowSplitterResizeHandlerBehavior({
  disabled,
  handleId,
  resizeHandler,
  panelGroupElement
}) {
  (0, import_react8.useEffect)(() => {
    if (disabled || resizeHandler == null || panelGroupElement == null) {
      return;
    }
    const handleElement = getResizeHandleElement(handleId, panelGroupElement);
    if (handleElement == null) {
      return;
    }
    const onKeyDown = (event) => {
      if (event.defaultPrevented) {
        return;
      }
      switch (event.key) {
        case "ArrowDown":
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "End":
        case "Home": {
          event.preventDefault();
          resizeHandler(event);
          break;
        }
        case "F6": {
          event.preventDefault();
          const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);
          assert(groupId, `No group element found for id "${groupId}"`);
          const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);
          const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);
          assert(index !== null, `No resize element found for id "${handleId}"`);
          const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;
          const nextHandle = handles[nextIndex];
          nextHandle.focus();
          break;
        }
      }
    };
    handleElement.addEventListener("keydown", onKeyDown);
    return () => {
      handleElement.removeEventListener("keydown", onKeyDown);
    };
  }, [panelGroupElement, disabled, handleId, resizeHandler]);
}
function PanelResizeHandle({
  children = null,
  className: classNameFromProps = "",
  disabled = false,
  hitAreaMargins,
  id: idFromProps,
  onBlur,
  onClick,
  onDragging,
  onFocus,
  onPointerDown,
  onPointerUp,
  style: styleFromProps = {},
  tabIndex = 0,
  tagName: Type = "div",
  ...rest
}) {
  var _hitAreaMargins$coars, _hitAreaMargins$fine;
  const elementRef = (0, import_react8.useRef)(null);
  const callbacksRef = (0, import_react8.useRef)({
    onClick,
    onDragging,
    onPointerDown,
    onPointerUp
  });
  (0, import_react8.useEffect)(() => {
    callbacksRef.current.onClick = onClick;
    callbacksRef.current.onDragging = onDragging;
    callbacksRef.current.onPointerDown = onPointerDown;
    callbacksRef.current.onPointerUp = onPointerUp;
  });
  const panelGroupContext = (0, import_react8.useContext)(PanelGroupContext);
  if (panelGroupContext === null) {
    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);
  }
  const {
    direction,
    groupId,
    registerResizeHandle: registerResizeHandleWithParentGroup,
    startDragging,
    stopDragging,
    panelGroupElement
  } = panelGroupContext;
  const resizeHandleId = useUniqueId(idFromProps);
  const [state, setState] = (0, import_react8.useState)("inactive");
  const [isFocused, setIsFocused] = (0, import_react8.useState)(false);
  const [resizeHandler, setResizeHandler] = (0, import_react8.useState)(null);
  const committedValuesRef = (0, import_react8.useRef)({
    state
  });
  useIsomorphicLayoutEffect2(() => {
    committedValuesRef.current.state = state;
  });
  (0, import_react8.useEffect)(() => {
    if (disabled) {
      setResizeHandler(null);
    } else {
      const resizeHandler2 = registerResizeHandleWithParentGroup(resizeHandleId);
      setResizeHandler(() => resizeHandler2);
    }
  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);
  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;
  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;
  (0, import_react8.useEffect)(() => {
    if (disabled || resizeHandler == null) {
      return;
    }
    const element = elementRef.current;
    assert(element, "Element ref not attached");
    let didMove = false;
    const setResizeHandlerState = (action, isActive, event) => {
      if (!isActive) {
        setState("inactive");
        return;
      }
      switch (action) {
        case "down": {
          setState("drag");
          didMove = false;
          assert(event, 'Expected event to be defined for "down" action');
          startDragging(resizeHandleId, event);
          const {
            onDragging: onDragging2,
            onPointerDown: onPointerDown2
          } = callbacksRef.current;
          onDragging2 === null || onDragging2 === void 0 ? void 0 : onDragging2(true);
          onPointerDown2 === null || onPointerDown2 === void 0 ? void 0 : onPointerDown2();
          break;
        }
        case "move": {
          const {
            state: state2
          } = committedValuesRef.current;
          didMove = true;
          if (state2 !== "drag") {
            setState("hover");
          }
          assert(event, 'Expected event to be defined for "move" action');
          resizeHandler(event);
          break;
        }
        case "up": {
          setState("hover");
          stopDragging();
          const {
            onClick: onClick2,
            onDragging: onDragging2,
            onPointerUp: onPointerUp2
          } = callbacksRef.current;
          onDragging2 === null || onDragging2 === void 0 ? void 0 : onDragging2(false);
          onPointerUp2 === null || onPointerUp2 === void 0 ? void 0 : onPointerUp2();
          if (!didMove) {
            onClick2 === null || onClick2 === void 0 ? void 0 : onClick2();
          }
          break;
        }
      }
    };
    return registerResizeHandle(resizeHandleId, element, direction, {
      coarse: coarseHitAreaMargins,
      fine: fineHitAreaMargins
    }, setResizeHandlerState);
  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);
  useWindowSplitterResizeHandlerBehavior({
    disabled,
    handleId: resizeHandleId,
    resizeHandler,
    panelGroupElement
  });
  const style = {
    touchAction: "none",
    userSelect: "none"
  };
  return (0, import_react8.createElement)(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: idFromProps,
    onBlur: () => {
      setIsFocused(false);
      onBlur === null || onBlur === void 0 ? void 0 : onBlur();
    },
    onFocus: () => {
      setIsFocused(true);
      onFocus === null || onFocus === void 0 ? void 0 : onFocus();
    },
    ref: elementRef,
    role: "separator",
    style: {
      ...style,
      ...styleFromProps
    },
    tabIndex,
    // CSS selectors
    [DATA_ATTRIBUTES.groupDirection]: direction,
    [DATA_ATTRIBUTES.groupId]: groupId,
    [DATA_ATTRIBUTES.resizeHandle]: "",
    [DATA_ATTRIBUTES.resizeHandleActive]: state === "drag" ? "pointer" : isFocused ? "keyboard" : void 0,
    [DATA_ATTRIBUTES.resizeHandleEnabled]: !disabled,
    [DATA_ATTRIBUTES.resizeHandleId]: resizeHandleId,
    [DATA_ATTRIBUTES.resizeHandleState]: state
  });
}
PanelResizeHandle.displayName = "PanelResizeHandle";

// node_modules/@motiadev/ui/dist/components/ui/collapsible-panel.js
var PanelControls = (t0) => {
  const $ = (0, import_compiler_runtime9.c)(10);
  if ($[0] !== "dcfed46e4c606b67cf4b4e5ebb8482758fc50e61c44c1de1b82c7a068d5c0653") {
    for (let $i = 0; $i < 10; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "dcfed46e4c606b67cf4b4e5ebb8482758fc50e61c44c1de1b82c7a068d5c0653";
  }
  const { header, isCollapsed, onToggle, variant: t1 } = t0;
  const variant = t1 === void 0 ? "default" : t1;
  let t2;
  if ($[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t2 = (0, import_jsx_runtime21.jsx)("div", { className: "flex-1" });
    $[1] = t2;
  } else t2 = $[1];
  let t3;
  if ($[2] !== isCollapsed || $[3] !== onToggle || $[4] !== variant) {
    t3 = onToggle && (0, import_jsx_runtime21.jsx)(Button, {
      variant: "default",
      onClick: onToggle,
      "aria-label": isCollapsed ? "Expand panel" : "Collapse panel",
      className: cn("h-8 px-3 [&_svg]:size-5", { "mr-5": variant === "tabs" }),
      children: (0, import_jsx_runtime21.jsx)(import_lucide_react4.ChevronDown, { className: cn("transition-transform", { "-rotate-180": !isCollapsed }) })
    });
    $[2] = isCollapsed;
    $[3] = onToggle;
    $[4] = variant;
    $[5] = t3;
  } else t3 = $[5];
  let t4;
  if ($[6] !== header || $[7] !== t3 || $[8] !== variant) {
    t4 = (0, import_jsx_runtime21.jsxs)(ContainerHeader, {
      variant,
      children: [
        header,
        t2,
        t3
      ]
    });
    $[6] = header;
    $[7] = t3;
    $[8] = variant;
    $[9] = t4;
  } else t4 = $[9];
  return t4;
};
var CustomResizeHandle = () => {
  const $ = (0, import_compiler_runtime9.c)(2);
  if ($[0] !== "dcfed46e4c606b67cf4b4e5ebb8482758fc50e61c44c1de1b82c7a068d5c0653") {
    for (let $i = 0; $i < 2; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "dcfed46e4c606b67cf4b4e5ebb8482758fc50e61c44c1de1b82c7a068d5c0653";
  }
  let t0;
  if ($[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t0 = (0, import_jsx_runtime21.jsx)("div", {
      className: "relative",
      children: (0, import_jsx_runtime21.jsx)("div", {
        className: "absolute inset-0 flex items-center justify-center",
        children: (0, import_jsx_runtime21.jsx)(PanelResizeHandle, {
          className: "group relative",
          children: (0, import_jsx_runtime21.jsx)("div", {
            className: "flex h-6 w-6 items-center justify-center rounded-full bg-background border border-border",
            children: (0, import_jsx_runtime21.jsx)(import_lucide_react4.Equal, { className: "h-4 w-4 text-muted-foreground" })
          })
        })
      })
    });
    $[1] = t0;
  } else t0 = $[1];
  return t0;
};
var CollapsiblePanel = (t0) => {
  const $ = (0, import_compiler_runtime9.c)(28);
  if ($[0] !== "dcfed46e4c606b67cf4b4e5ebb8482758fc50e61c44c1de1b82c7a068d5c0653") {
    for (let $i = 0; $i < 28; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "dcfed46e4c606b67cf4b4e5ebb8482758fc50e61c44c1de1b82c7a068d5c0653";
  }
  const { id, header, children, withResizeHandle, className, variant, defaultTab, onTabChange } = t0;
  const [isCollapsed, setIsCollapsed] = (0, import_react9.useState)(false);
  const panelRef = (0, import_react9.useRef)(null);
  let t1;
  if ($[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      const panel = panelRef.current;
      if (!panel) return;
      try {
        if (panel.isCollapsed()) panel.expand();
        else panel.collapse();
      } catch (t2$1) {
        const error = t2$1;
        console.warn("Failed to toggle panel:", error);
      }
    };
    $[1] = t1;
  } else t1 = $[1];
  const onToggle = t1;
  let t2;
  if ($[2] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t2 = () => setIsCollapsed(true);
    $[2] = t2;
  } else t2 = $[2];
  const onCollapse = t2;
  let t3;
  if ($[3] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t3 = () => setIsCollapsed(false);
    $[3] = t3;
  } else t3 = $[3];
  const onExpand = t3;
  let t4;
  bb0: {
    let t5$1;
    if ($[4] !== header || $[5] !== isCollapsed || $[6] !== variant) {
      t5$1 = (0, import_jsx_runtime21.jsx)(PanelControls, {
        header,
        isCollapsed,
        variant,
        onToggle
      });
      $[4] = header;
      $[5] = isCollapsed;
      $[6] = variant;
      $[7] = t5$1;
    } else t5$1 = $[7];
    let t6$1;
    if ($[8] !== children) {
      t6$1 = (0, import_jsx_runtime21.jsx)(ContainerContent, { children });
      $[8] = children;
      $[9] = t6$1;
    } else t6$1 = $[9];
    let t7$1;
    if ($[10] !== t5$1 || $[11] !== t6$1) {
      t7$1 = (0, import_jsx_runtime21.jsxs)(Container, {
        className: "h-full",
        children: [t5$1, t6$1]
      });
      $[10] = t5$1;
      $[11] = t6$1;
      $[12] = t7$1;
    } else t7$1 = $[12];
    const container = t7$1;
    if (variant == "tabs") {
      let t8$1;
      if ($[13] !== container || $[14] !== defaultTab || $[15] !== onTabChange) {
        t8$1 = (0, import_jsx_runtime21.jsx)(Tabs2, {
          className: "h-full",
          defaultValue: defaultTab,
          onValueChange: onTabChange,
          children: container
        });
        $[13] = container;
        $[14] = defaultTab;
        $[15] = onTabChange;
        $[16] = t8$1;
      } else t8$1 = $[16];
      t4 = t8$1;
      break bb0;
    }
    t4 = container;
  }
  const view = t4;
  let t5;
  if ($[17] !== className) {
    t5 = cn("min-h-[42px]", className);
    $[17] = className;
    $[18] = t5;
  } else t5 = $[18];
  let t6;
  if ($[19] !== id || $[20] !== t5 || $[21] !== view) {
    t6 = (0, import_jsx_runtime21.jsx)(Panel, {
      id,
      collapsible: true,
      ref: panelRef,
      className: t5,
      onCollapse,
      onExpand,
      children: view
    });
    $[19] = id;
    $[20] = t5;
    $[21] = view;
    $[22] = t6;
  } else t6 = $[22];
  let t7;
  if ($[23] !== withResizeHandle) {
    t7 = withResizeHandle && (0, import_jsx_runtime21.jsx)(CustomResizeHandle, {});
    $[23] = withResizeHandle;
    $[24] = t7;
  } else t7 = $[24];
  let t8;
  if ($[25] !== t6 || $[26] !== t7) {
    t8 = (0, import_jsx_runtime21.jsxs)(import_jsx_runtime21.Fragment, { children: [t6, t7] });
    $[25] = t6;
    $[26] = t7;
    $[27] = t8;
  } else t8 = $[27];
  return t8;
};
var CollapsiblePanelGroup = (t0) => {
  const $ = (0, import_compiler_runtime9.c)(13);
  if ($[0] !== "dcfed46e4c606b67cf4b4e5ebb8482758fc50e61c44c1de1b82c7a068d5c0653") {
    for (let $i = 0; $i < 13; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "dcfed46e4c606b67cf4b4e5ebb8482758fc50e61c44c1de1b82c7a068d5c0653";
  }
  let children;
  let props2;
  if ($[1] !== t0) {
    ({ children, ...props2 } = t0);
    $[1] = t0;
    $[2] = children;
    $[3] = props2;
  } else {
    children = $[2];
    props2 = $[3];
  }
  const [resizeHandleCount, setResizeHandleCount] = (0, import_react9.useState)(0);
  let t1;
  if ($[4] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t1 = (sizes) => {
      setResizeHandleCount(sizes.length);
    };
    $[4] = t1;
  } else t1 = $[4];
  let t2;
  if ($[5] !== children || $[6] !== resizeHandleCount) {
    let t3$1;
    if ($[8] !== resizeHandleCount) {
      t3$1 = (child, index) => {
        if (import_react9.default.isValidElement(child)) {
          const last = resizeHandleCount - 1 === index;
          const hasResizeHandle = resizeHandleCount > 1;
          return import_react9.default.cloneElement(child, { withResizeHandle: hasResizeHandle && !last });
        }
        return child;
      };
      $[8] = resizeHandleCount;
      $[9] = t3$1;
    } else t3$1 = $[9];
    t2 = import_react9.default.Children.map(children, t3$1);
    $[5] = children;
    $[6] = resizeHandleCount;
    $[7] = t2;
  } else t2 = $[7];
  let t3;
  if ($[10] !== props2 || $[11] !== t2) {
    t3 = (0, import_jsx_runtime21.jsx)(PanelGroup, {
      onLayout: t1,
      ...props2,
      children: t2
    });
    $[10] = props2;
    $[11] = t2;
    $[12] = t3;
  } else t3 = $[12];
  return t3;
};

// node_modules/@motiadev/ui/dist/components/ui/empty.js
var import_compiler_runtime10 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
function Empty(t0) {
  const $ = (0, import_compiler_runtime10.c)(9);
  if ($[0] !== "f8af5c7bbd5b7b466051ad6c6ba7c28263cee5f1ff855c30b732e93e6441e539") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "f8af5c7bbd5b7b466051ad6c6ba7c28263cee5f1ff855c30b732e93e6441e539";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("flex min-w-0 flex-1 flex-col items-center justify-center gap-6 text-balance rounded-lg border-dashed p-6 text-center md:p-12", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== t1) {
    t2 = (0, import_jsx_runtime22.jsx)("div", {
      "data-slot": "empty",
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = t1;
    $[8] = t2;
  } else t2 = $[8];
  return t2;
}
function EmptyHeader(t0) {
  const $ = (0, import_compiler_runtime10.c)(9);
  if ($[0] !== "f8af5c7bbd5b7b466051ad6c6ba7c28263cee5f1ff855c30b732e93e6441e539") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "f8af5c7bbd5b7b466051ad6c6ba7c28263cee5f1ff855c30b732e93e6441e539";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("flex max-w-sm flex-col items-center gap-2 text-center", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== t1) {
    t2 = (0, import_jsx_runtime22.jsx)("div", {
      "data-slot": "empty-header",
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = t1;
    $[8] = t2;
  } else t2 = $[8];
  return t2;
}
var emptyMediaVariants = cva("mb-2 flex shrink-0 items-center justify-center [&_svg]:pointer-events-none [&_svg]:shrink-0", {
  variants: { variant: {
    default: "bg-transparent",
    icon: "bg-dark-50 dark:bg-light-50 text-foreground flex size-10 shrink-0 items-center justify-center rounded-lg [&_svg:not([class*='size-'])]:size-6"
  } },
  defaultVariants: { variant: "default" }
});
function EmptyMedia(t0) {
  const $ = (0, import_compiler_runtime10.c)(12);
  if ($[0] !== "f8af5c7bbd5b7b466051ad6c6ba7c28263cee5f1ff855c30b732e93e6441e539") {
    for (let $i = 0; $i < 12; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "f8af5c7bbd5b7b466051ad6c6ba7c28263cee5f1ff855c30b732e93e6441e539";
  }
  let className;
  let props2;
  let t1;
  if ($[1] !== t0) {
    ({ className, variant: t1, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
    $[4] = t1;
  } else {
    className = $[2];
    props2 = $[3];
    t1 = $[4];
  }
  const variant = t1 === void 0 ? "default" : t1;
  let t2;
  if ($[5] !== className || $[6] !== variant) {
    t2 = cn(emptyMediaVariants({
      variant,
      className
    }));
    $[5] = className;
    $[6] = variant;
    $[7] = t2;
  } else t2 = $[7];
  let t3;
  if ($[8] !== props2 || $[9] !== t2 || $[10] !== variant) {
    t3 = (0, import_jsx_runtime22.jsx)("div", {
      "data-slot": "empty-icon",
      "data-variant": variant,
      className: t2,
      ...props2
    });
    $[8] = props2;
    $[9] = t2;
    $[10] = variant;
    $[11] = t3;
  } else t3 = $[11];
  return t3;
}
function EmptyTitle(t0) {
  const $ = (0, import_compiler_runtime10.c)(9);
  if ($[0] !== "f8af5c7bbd5b7b466051ad6c6ba7c28263cee5f1ff855c30b732e93e6441e539") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "f8af5c7bbd5b7b466051ad6c6ba7c28263cee5f1ff855c30b732e93e6441e539";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("text-lg font-medium tracking-tight", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== t1) {
    t2 = (0, import_jsx_runtime22.jsx)("div", {
      "data-slot": "empty-title",
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = t1;
    $[8] = t2;
  } else t2 = $[8];
  return t2;
}
function EmptyDescription(t0) {
  const $ = (0, import_compiler_runtime10.c)(9);
  if ($[0] !== "f8af5c7bbd5b7b466051ad6c6ba7c28263cee5f1ff855c30b732e93e6441e539") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "f8af5c7bbd5b7b466051ad6c6ba7c28263cee5f1ff855c30b732e93e6441e539";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("text-muted-foreground [&>a:hover]:text-primary text-sm/relaxed [&>a]:underline [&>a]:underline-offset-4", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== t1) {
    t2 = (0, import_jsx_runtime22.jsx)("div", {
      "data-slot": "empty-description",
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = t1;
    $[8] = t2;
  } else t2 = $[8];
  return t2;
}
function EmptyContent(t0) {
  const $ = (0, import_compiler_runtime10.c)(9);
  if ($[0] !== "f8af5c7bbd5b7b466051ad6c6ba7c28263cee5f1ff855c30b732e93e6441e539") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "f8af5c7bbd5b7b466051ad6c6ba7c28263cee5f1ff855c30b732e93e6441e539";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("flex w-full min-w-0 max-w-sm flex-col items-center gap-4 text-balance text-sm", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== t1) {
    t2 = (0, import_jsx_runtime22.jsx)("div", {
      "data-slot": "empty-content",
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = t1;
    $[8] = t2;
  } else t2 = $[8];
  return t2;
}

// node_modules/@motiadev/ui/dist/components/ui/input.js
var import_compiler_runtime11 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var inputVariants = cva(cn("flex w-full rounded-md px-3 py-2 text-base transition-colors outline-none resize-none", "field-sizing-content", "aria-invalid:border-destructive", "disabled:cursor-not-allowed disabled:opacity-50", "text-sm font-medium leading-[1.3] tracking-[-0.01em]"), {
  variants: { variant: {
    default: "bg-input border border-border hover:border-border focus-visible:border-ring text-foreground placeholder:text-muted-foreground focus-visible:ring-2 focus-visible:ring-ring/20",
    shade: "bg-muted-foreground/10 text-muted-foreground hover:bg-muted-foreground/12 focus:bg-muted-foreground/15",
    outline: "focus-visible:border-border focus-visible:bg-card hover:border-border hover:bg-card bg-transparent text-foreground border border-transparent",
    outlineReadonly: "bg-transparent text-foreground border border-transparent"
  } },
  defaultVariants: { variant: "default" }
});
var Input = (0, import_react10.forwardRef)((t0, ref) => {
  const $ = (0, import_compiler_runtime11.c)(14);
  if ($[0] !== "ed2073a4c548690e4b490ee4a53cd2431c8f22f07636cbbde7ce31719476c874") {
    for (let $i = 0; $i < 14; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "ed2073a4c548690e4b490ee4a53cd2431c8f22f07636cbbde7ce31719476c874";
  }
  let className;
  let props2;
  let type;
  let variant;
  if ($[1] !== t0) {
    ({ className, type, variant, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
    $[4] = type;
    $[5] = variant;
  } else {
    className = $[2];
    props2 = $[3];
    type = $[4];
    variant = $[5];
  }
  let t1;
  if ($[6] !== className || $[7] !== variant) {
    t1 = inputVariants({
      variant,
      className
    });
    $[6] = className;
    $[7] = variant;
    $[8] = t1;
  } else t1 = $[8];
  let t2;
  if ($[9] !== props2 || $[10] !== ref || $[11] !== t1 || $[12] !== type) {
    t2 = (0, import_jsx_runtime23.jsx)("input", {
      type,
      className: t1,
      ref,
      ...props2
    });
    $[9] = props2;
    $[10] = ref;
    $[11] = t1;
    $[12] = type;
    $[13] = t2;
  } else t2 = $[13];
  return t2;
});
Input.displayName = "Input";

// node_modules/@motiadev/ui/dist/components/ui/label.js
var import_compiler_runtime12 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-label/dist/index.mjs
var React27 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-label/node_modules/@radix-ui/react-primitive/dist/index.mjs
var React26 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive2 = NODES.reduce((primitive, node) => {
  const Slot7 = createSlot(`Primitive.${node}`);
  const Node2 = React26.forwardRef((props2, forwardedRef) => {
    const { asChild, ...primitiveProps } = props2;
    const Comp = asChild ? Slot7 : node;
    if (typeof window !== "undefined") {
      window[/* @__PURE__ */ Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime24.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});

// node_modules/@radix-ui/react-label/dist/index.mjs
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var NAME = "Label";
var Label3 = React27.forwardRef((props2, forwardedRef) => {
  return (0, import_jsx_runtime25.jsx)(
    Primitive2.label,
    {
      ...props2,
      ref: forwardedRef,
      onMouseDown: (event) => {
        const target = event.target;
        if (target.closest("button, input, select, textarea")) return;
        props2.onMouseDown?.(event);
        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
      }
    }
  );
});
Label3.displayName = NAME;
var Root4 = Label3;

// node_modules/@motiadev/ui/dist/components/ui/label.js
var Label4 = (t0) => {
  const $ = (0, import_compiler_runtime12.c)(9);
  if ($[0] !== "bc03bf8d20a05e79233882d03ca2843467f2667eb3cd1e042034760f23d14746") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "bc03bf8d20a05e79233882d03ca2843467f2667eb3cd1e042034760f23d14746";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== t1) {
    t2 = (0, import_jsx_runtime26.jsx)(Root4, {
      "data-slot": "label",
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = t1;
    $[8] = t2;
  } else t2 = $[8];
  return t2;
};
Label4.displayName = Root4.displayName;

// node_modules/@motiadev/ui/dist/components/ui/level-dot.js
var import_compiler_runtime13 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var badgeVariants2 = cva("text-xs font-medium tracking-wide rounded-full h-[6px] w-[6px] m-[4px] outline-[2px]", { variants: { variant: {
  info: "bg-[#2862FE] outline-[#2862FE]/20",
  trace: "bg-[#2862FE] outline-[#2862FE]/20",
  debug: "bg-[#2862FE] outline-[#2862FE]/20",
  error: "bg-[#E22A6D] outline-[#E22A6D]/20",
  fatal: "bg-[#E22A6D] outline-[#E22A6D]/20",
  warn: "bg-[#F59F0B] outline-[#F59F0B]/20"
} } });
var LevelDot = (t0) => {
  const $ = (0, import_compiler_runtime13.c)(5);
  if ($[0] !== "287e910b40d2d16a0ea10c860e841aec14db3697fd5534011c819d5b26df8ac1") {
    for (let $i = 0; $i < 5; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "287e910b40d2d16a0ea10c860e841aec14db3697fd5534011c819d5b26df8ac1";
  }
  const { level } = t0;
  const t1 = level;
  let t2;
  if ($[1] !== t1) {
    t2 = badgeVariants2({ variant: t1 });
    $[1] = t1;
    $[2] = t2;
  } else t2 = $[2];
  let t3;
  if ($[3] !== t2) {
    t3 = (0, import_jsx_runtime27.jsx)("div", { className: t2 });
    $[3] = t2;
    $[4] = t3;
  } else t3 = $[4];
  return t3;
};

// node_modules/@motiadev/ui/dist/components/ui/panel.js
var import_compiler_runtime14 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var panelVariants = {
  default: "bg-transparent border border-border",
  outlined: "bg-transparent border border-border",
  filled: "bg-muted border border-transparent",
  ghost: "bg-transparent border-transparent shadow-none"
};
var PanelDetailItem = (t0) => {
  const $ = (0, import_compiler_runtime14.c)(15);
  if ($[0] !== "b3b7236dd5fadd4d6212298d092e19d59c580762f7498864f6e887d5ae5a53c3") {
    for (let $i = 0; $i < 15; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "b3b7236dd5fadd4d6212298d092e19d59c580762f7498864f6e887d5ae5a53c3";
  }
  const { label, value, highlighted } = t0;
  let t1;
  if ($[1] !== label) {
    t1 = (0, import_jsx_runtime28.jsx)("div", {
      className: "flex items-center h-8 shrink-0",
      children: (0, import_jsx_runtime28.jsx)("span", {
        className: "text-sm font-medium text-foreground tracking-[-0.25px] w-24 truncate",
        children: label
      })
    });
    $[1] = label;
    $[2] = t1;
  } else t1 = $[2];
  const t2 = highlighted && "bg-secondary";
  let t3;
  if ($[3] !== t2) {
    t3 = cn("flex-1 rounded-lg px-2 py-1 min-h-6", t2);
    $[3] = t2;
    $[4] = t3;
  } else t3 = $[4];
  let t4;
  if ($[5] !== value) {
    t4 = typeof value === "string" ? (0, import_jsx_runtime28.jsx)("span", {
      className: "text-sm font-medium text-muted-foreground tracking-[-0.25px] leading-tight",
      children: value
    }) : value;
    $[5] = value;
    $[6] = t4;
  } else t4 = $[6];
  let t5;
  if ($[7] !== t4) {
    t5 = (0, import_jsx_runtime28.jsx)("div", {
      className: "flex items-center min-h-6",
      children: t4
    });
    $[7] = t4;
    $[8] = t5;
  } else t5 = $[8];
  let t6;
  if ($[9] !== t3 || $[10] !== t5) {
    t6 = (0, import_jsx_runtime28.jsx)("div", {
      className: t3,
      children: t5
    });
    $[9] = t3;
    $[10] = t5;
    $[11] = t6;
  } else t6 = $[11];
  let t7;
  if ($[12] !== t1 || $[13] !== t6) {
    t7 = (0, import_jsx_runtime28.jsxs)("div", {
      className: "flex gap-4 items-start",
      children: [t1, t6]
    });
    $[12] = t1;
    $[13] = t6;
    $[14] = t7;
  } else t7 = $[14];
  return t7;
};
var Panel2 = (t0) => {
  const $ = (0, import_compiler_runtime14.c)(48);
  if ($[0] !== "b3b7236dd5fadd4d6212298d092e19d59c580762f7498864f6e887d5ae5a53c3") {
    for (let $i = 0; $i < 48; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "b3b7236dd5fadd4d6212298d092e19d59c580762f7498864f6e887d5ae5a53c3";
  }
  const { "data-testid": dataTestId, title, subtitle, details, actions, className, children, size, variant: t1, contentClassName, tabs } = t0;
  const variant = t1 === void 0 ? "default" : t1;
  const hasTabs = tabs && tabs.length > 0;
  let t2;
  bb0: {
    let t3$1;
    if ($[1] !== hasTabs || $[2] !== tabs || $[3] !== variant) {
      t3$1 = hasTabs && (0, import_jsx_runtime28.jsx)(TabsList2, {
        className: cn("bg-card border-b border-border px-1 pt-5", { "bg-transparent": variant === "ghost" }),
        children: tabs?.map(_temp2)
      });
      $[1] = hasTabs;
      $[2] = tabs;
      $[3] = variant;
      $[4] = t3$1;
    } else t3$1 = $[4];
    let t4$1;
    if ($[5] !== contentClassName) {
      t4$1 = cn("flex flex-col gap-2 p-4 h-full", contentClassName);
      $[5] = contentClassName;
      $[6] = t4$1;
    } else t4$1 = $[6];
    let t5$1;
    if ($[7] !== details) {
      t5$1 = details?.map(_temp22);
      $[7] = details;
      $[8] = t5$1;
    } else t5$1 = $[8];
    let t6$1;
    if ($[9] !== hasTabs || $[10] !== tabs) {
      t6$1 = hasTabs && tabs.map(_temp3);
      $[9] = hasTabs;
      $[10] = tabs;
      $[11] = t6$1;
    } else t6$1 = $[11];
    let t7$1;
    if ($[12] !== children || $[13] !== t4$1 || $[14] !== t5$1 || $[15] !== t6$1) {
      t7$1 = (0, import_jsx_runtime28.jsxs)("div", {
        className: t4$1,
        children: [
          t5$1,
          t6$1,
          children
        ]
      });
      $[12] = children;
      $[13] = t4$1;
      $[14] = t5$1;
      $[15] = t6$1;
      $[16] = t7$1;
    } else t7$1 = $[16];
    let t8$1;
    if ($[17] !== t3$1 || $[18] !== t7$1) {
      t8$1 = (0, import_jsx_runtime28.jsxs)(import_jsx_runtime28.Fragment, { children: [t3$1, t7$1] });
      $[17] = t3$1;
      $[18] = t7$1;
      $[19] = t8$1;
    } else t8$1 = $[19];
    const _view = t8$1;
    if (hasTabs) {
      const t9$1 = tabs?.[0]?.label;
      let t10$1;
      if ($[20] !== _view || $[21] !== t9$1) {
        t10$1 = (0, import_jsx_runtime28.jsx)(Tabs2, {
          defaultValue: t9$1,
          children: _view
        });
        $[20] = _view;
        $[21] = t9$1;
        $[22] = t10$1;
      } else t10$1 = $[22];
      t2 = t10$1;
      break bb0;
    }
    t2 = _view;
  }
  const content = t2;
  const t3 = panelVariants[variant];
  let t4;
  if ($[23] !== className || $[24] !== t3) {
    t4 = cn("relative isolate size-full backdrop-blur-[48px] backdrop-filter", "text-foreground", "rounded-lg overflow-hidden", t3, className);
    $[23] = className;
    $[24] = t3;
    $[25] = t4;
  } else t4 = $[25];
  let t5;
  if ($[26] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t5 = (0, import_jsx_runtime28.jsx)(BackgroundEffect, {});
    $[26] = t5;
  } else t5 = $[26];
  const t6 = variant === "ghost";
  let t7;
  if ($[27] !== hasTabs || $[28] !== t6) {
    t7 = cn("relative shrink-0 w-full border-b border-border bg-card", {
      "bg-transparent": t6,
      "border-b-0": hasTabs
    });
    $[27] = hasTabs;
    $[28] = t6;
    $[29] = t7;
  } else t7 = $[29];
  let t8;
  if ($[30] !== actions || $[31] !== hasTabs || $[32] !== size || $[33] !== subtitle || $[34] !== title) {
    t8 = title && (0, import_jsx_runtime28.jsxs)("div", {
      className: cn("flex flex-col gap-1 px-5 py-4", {
        "px-4 py-3": size === "sm",
        "px-5 py-4": size === "md",
        "pb-0": hasTabs
      }),
      children: [(0, import_jsx_runtime28.jsxs)("div", {
        className: "flex items-center w-full",
        children: [(0, import_jsx_runtime28.jsx)("div", {
          className: cn("font-semibold text-foreground tracking-[-0.25px] leading-tight flex-1", size === "sm" ? "text-xs" : "text-base"),
          children: title
        }), actions && actions.length > 0 && (0, import_jsx_runtime28.jsx)("div", {
          className: "flex items-center gap-1",
          children: actions.map(_temp4)
        })]
      }), subtitle && (0, import_jsx_runtime28.jsx)("p", {
        className: "text-sm font-medium text-muted-foreground tracking-[-0.25px] leading-tight",
        children: subtitle
      })]
    });
    $[30] = actions;
    $[31] = hasTabs;
    $[32] = size;
    $[33] = subtitle;
    $[34] = title;
    $[35] = t8;
  } else t8 = $[35];
  let t9;
  if ($[36] !== t7 || $[37] !== t8) {
    t9 = (0, import_jsx_runtime28.jsx)("div", {
      className: t7,
      children: t8
    });
    $[36] = t7;
    $[37] = t8;
    $[38] = t9;
  } else t9 = $[38];
  let t10;
  if ($[39] !== content) {
    t10 = (0, import_jsx_runtime28.jsx)("div", {
      className: "flex-1 overflow-auto",
      children: content
    });
    $[39] = content;
    $[40] = t10;
  } else t10 = $[40];
  let t11;
  if ($[41] !== t10 || $[42] !== t9) {
    t11 = (0, import_jsx_runtime28.jsxs)("div", {
      className: "flex flex-col size-full",
      children: [t9, t10]
    });
    $[41] = t10;
    $[42] = t9;
    $[43] = t11;
  } else t11 = $[43];
  let t12;
  if ($[44] !== dataTestId || $[45] !== t11 || $[46] !== t4) {
    t12 = (0, import_jsx_runtime28.jsxs)("div", {
      className: t4,
      "data-testid": dataTestId,
      children: [t5, t11]
    });
    $[44] = dataTestId;
    $[45] = t11;
    $[46] = t4;
    $[47] = t12;
  } else t12 = $[47];
  return t12;
};
Panel2.displayName = "Panel";
function _temp2(tab) {
  return (0, import_jsx_runtime28.jsx)(TabsTrigger2, {
    value: tab.label,
    "data-testid": tab["data-testid"],
    className: "cursor-pointer",
    children: tab.labelComponent || tab.label
  }, tab.label);
}
function _temp22(detail, index) {
  return (0, import_jsx_runtime28.jsx)(PanelDetailItem, { ...detail }, index);
}
function _temp3(tab_0) {
  return (0, import_jsx_runtime28.jsx)(TabsContent2, {
    value: tab_0.label,
    children: tab_0.content
  }, tab_0.label);
}
function _temp4(action, index_0) {
  return (0, import_jsx_runtime28.jsx)(Button, {
    onClick: action.onClick,
    variant: "ghost",
    className: cn(action.active && "bg-muted-foreground/20 hover:bg-muted-foreground/30"),
    size: "icon",
    "aria-label": action.label,
    "data-testid": "close-panel",
    children: action.icon
  }, index_0);
}

// node_modules/@motiadev/ui/dist/components/ui/select.js
var import_compiler_runtime15 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_lucide_react5 = __toESM(require_lucide_react(), 1);
var React$12 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-select/dist/index.mjs
var React29 = __toESM(require_react(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/number/dist/index.mjs
function clamp(value, [min, max]) {
  return Math.min(max, Math.max(min, value));
}

// node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-slot/dist/index.mjs
var React28 = __toESM(require_react(), 1);
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
function createSlot4(ownerName) {
  const SlotClone = createSlotClone4(ownerName);
  const Slot22 = React28.forwardRef((props2, forwardedRef) => {
    const { children, ...slotProps } = props2;
    const childrenArray = React28.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable4);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React28.Children.count(newElement) > 1) return React28.Children.only(null);
          return React28.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime29.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React28.isValidElement(newElement) ? React28.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime29.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot5 = createSlot4("Slot");
function createSlotClone4(ownerName) {
  const SlotClone = React28.forwardRef((props2, forwardedRef) => {
    const { children, ...slotProps } = props2;
    if (React28.isValidElement(children)) {
      const childrenRef = getElementRef4(children);
      const props22 = mergeProps4(slotProps, children.props);
      if (children.type !== React28.Fragment) {
        props22.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React28.cloneElement(children, props22);
    }
    return React28.Children.count(children) > 1 ? React28.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER4 = /* @__PURE__ */ Symbol("radix.slottable");
function createSlottable4(ownerName) {
  const Slottable22 = ({ children }) => {
    return (0, import_jsx_runtime29.jsx)(import_jsx_runtime29.Fragment, { children });
  };
  Slottable22.displayName = `${ownerName}.Slottable`;
  Slottable22.__radixId = SLOTTABLE_IDENTIFIER4;
  return Slottable22;
}
var Slottable4 = createSlottable4("Slottable");
function isSlottable4(child) {
  return React28.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER4;
}
function mergeProps4(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef4(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-select/dist/index.mjs
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS2 = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection3, useCollection3, createCollectionScope3] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope3,
  createPopperScope
]);
var usePopperScope2 = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select = (props2) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required,
    form
  } = props2;
  const popperScope = usePopperScope2(__scopeSelect);
  const [trigger, setTrigger] = React29.useState(null);
  const [valueNode, setValueNode] = React29.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React29.useState(false);
  const direction = useDirection(dir);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SELECT_NAME
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange,
    caller: SELECT_NAME
  });
  const triggerPointerDownPosRef = React29.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React29.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return (0, import_jsx_runtime30.jsx)(Root2, { ...popperScope, children: (0, import_jsx_runtime30.jsxs)(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        (0, import_jsx_runtime30.jsx)(Collection3.Provider, { scope: __scopeSelect, children: (0, import_jsx_runtime30.jsx)(
          SelectNativeOptionsProvider,
          {
            scope: props2.__scopeSelect,
            onNativeOptionAdd: React29.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React29.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? (0, import_jsx_runtime30.jsxs)(
          SelectBubbleInput,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? (0, import_jsx_runtime30.jsx)("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select.displayName = SELECT_NAME;
var TRIGGER_NAME4 = "SelectTrigger";
var SelectTrigger = React29.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props2;
    const popperScope = usePopperScope2(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME4, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection3(__scopeSelect);
    const pointerTypeRef = React29.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return (0, import_jsx_runtime30.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime30.jsx)(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger.displayName = TRIGGER_NAME4;
var VALUE_NAME = "SelectValue";
var SelectValue = React29.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props2;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return (0, import_jsx_runtime30.jsx)(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? (0, import_jsx_runtime30.jsx)(import_jsx_runtime30.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React29.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props2;
    return (0, import_jsx_runtime30.jsx)(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME3 = "SelectPortal";
var SelectPortal = (props2) => {
  return (0, import_jsx_runtime30.jsx)(Portal, { asChild: true, ...props2 });
};
SelectPortal.displayName = PORTAL_NAME3;
var CONTENT_NAME4 = "SelectContent";
var SelectContent = React29.forwardRef(
  (props2, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME4, props2.__scopeSelect);
    const [fragment, setFragment] = React29.useState();
    useLayoutEffect2(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? ReactDOM2.createPortal(
        (0, import_jsx_runtime30.jsx)(SelectContentProvider, { scope: props2.__scopeSelect, children: (0, import_jsx_runtime30.jsx)(Collection3.Slot, { scope: props2.__scopeSelect, children: (0, import_jsx_runtime30.jsx)("div", { children: props2.children }) }) }),
        frag
      ) : null;
    }
    return (0, import_jsx_runtime30.jsx)(SelectContentImpl, { ...props2, ref: forwardedRef });
  }
);
SelectContent.displayName = CONTENT_NAME4;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME4);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var Slot6 = createSlot4("SelectContent.RemoveScroll");
var SelectContentImpl = React29.forwardRef(
  (props2, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props2;
    const context = useSelectContext(CONTENT_NAME4, __scopeSelect);
    const [content, setContent] = React29.useState(null);
    const [viewport, setViewport] = React29.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = React29.useState(null);
    const [selectedItemText, setSelectedItemText] = React29.useState(
      null
    );
    const getItems = useCollection3(__scopeSelect);
    const [isPositioned, setIsPositioned] = React29.useState(false);
    const firstValidItemFoundRef = React29.useRef(false);
    React29.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst4 = React29.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate?.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate?.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = React29.useCallback(
      () => focusFirst4([selectedItem, content]),
      [focusFirst4, selectedItem, content]
    );
    React29.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React29.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove2 = (event) => {
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0))
          };
        };
        const handlePointerUp2 = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove2);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove2);
          document.addEventListener("pointerup", handlePointerUp2, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove2);
          document.removeEventListener("pointerup", handlePointerUp2, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    React29.useEffect(() => {
      const close = () => onOpenChange(false);
      window.addEventListener("blur", close);
      window.addEventListener("resize", close);
      return () => {
        window.removeEventListener("blur", close);
        window.removeEventListener("resize", close);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React29.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React29.useCallback(() => content?.focus(), [content]);
    const itemTextRefCallback = React29.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return (0, import_jsx_runtime30.jsx)(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: (0, import_jsx_runtime30.jsx)(Combination_default, { as: Slot6, allowPinchZoom: true, children: (0, import_jsx_runtime30.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              context.trigger?.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: (0, import_jsx_runtime30.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: (0, import_jsx_runtime30.jsx)(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst4(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React29.forwardRef((props2, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props2;
  const context = useSelectContext(CONTENT_NAME4, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME4, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React29.useState(null);
  const [content, setContent] = React29.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems = useCollection3(__scopeSelect);
  const shouldExpandOnScrollRef = React29.useRef(false);
  const shouldRepositionRef = React29.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = React29.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced?.();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect2(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = React29.useState();
  useLayoutEffect2(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = React29.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem?.();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return (0, import_jsx_runtime30.jsx)(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: (0, import_jsx_runtime30.jsx)(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: (0, import_jsx_runtime30.jsx)(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React29.forwardRef((props2, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props2;
  const popperScope = usePopperScope2(__scopeSelect);
  return (0, import_jsx_runtime30.jsx)(
    Content,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME4, {});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = React29.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, nonce: nonce2, ...viewportProps } = props2;
    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React29.useRef(0);
    return (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, { children: [
      (0, import_jsx_runtime30.jsx)(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce: nonce2
        }
      ),
      (0, import_jsx_runtime30.jsx)(Collection3.Slot, { scope: __scopeSelect, children: (0, import_jsx_runtime30.jsx)(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if (shouldExpandOnScrollRef?.current && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME4 = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME4);
var SelectGroup = React29.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props2;
    const groupId = useId();
    return (0, import_jsx_runtime30.jsx)(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: (0, import_jsx_runtime30.jsx)(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME4;
var LABEL_NAME3 = "SelectLabel";
var SelectLabel = React29.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props2;
    const groupContext = useSelectGroupContext(LABEL_NAME3, __scopeSelect);
    return (0, import_jsx_runtime30.jsx)(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel.displayName = LABEL_NAME3;
var ITEM_NAME4 = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME4);
var SelectItem = React29.forwardRef(
  (props2, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props2;
    const context = useSelectContext(ITEM_NAME4, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME4, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = React29.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = React29.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => contentContext.itemRefCallback?.(node, value, disabled)
    );
    const textId = useId();
    const pointerTypeRef = React29.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return (0, import_jsx_runtime30.jsx)(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React29.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || (node?.textContent ?? "").trim());
        }, []),
        children: (0, import_jsx_runtime30.jsx)(
          Collection3.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: (0, import_jsx_runtime30.jsx)(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    contentContext.onItemLeave?.();
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  if (event.currentTarget === document.activeElement) {
                    contentContext.onItemLeave?.();
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  const isTypingAhead = contentContext.searchRef?.current !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS2.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem.displayName = ITEM_NAME4;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React29.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props2;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React29.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled)
    );
    const textContent = itemTextNode?.textContent;
    const nativeOption = React29.useMemo(
      () => (0, import_jsx_runtime30.jsx)("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, { children: [
      (0, import_jsx_runtime30.jsx)(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM2.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME2 = "SelectItemIndicator";
var SelectItemIndicator = React29.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props2;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME2, __scopeSelect);
    return itemContext.isSelected ? (0, import_jsx_runtime30.jsx)(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME2;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton = React29.forwardRef((props2, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props2.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props2.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React29.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      var handleScroll2 = handleScroll22;
      const viewport = contentContext.viewport;
      handleScroll22();
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? (0, import_jsx_runtime30.jsx)(
    SelectScrollButtonImpl,
    {
      ...props2,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton = React29.forwardRef((props2, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props2.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props2.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React29.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      var handleScroll2 = handleScroll22;
      const viewport = contentContext.viewport;
      handleScroll22();
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? (0, import_jsx_runtime30.jsx)(
    SelectScrollButtonImpl,
    {
      ...props2,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React29.forwardRef((props2, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props2;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React29.useRef(null);
  const getItems = useCollection3(__scopeSelect);
  const clearAutoScrollTimer = React29.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React29.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect2(() => {
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    activeItem?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return (0, import_jsx_runtime30.jsx)(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        contentContext.onItemLeave?.();
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME3 = "SelectSeparator";
var SelectSeparator = React29.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props2;
    return (0, import_jsx_runtime30.jsx)(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator.displayName = SEPARATOR_NAME3;
var ARROW_NAME3 = "SelectArrow";
var SelectArrow = React29.forwardRef(
  (props2, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props2;
    const popperScope = usePopperScope2(__scopeSelect);
    const context = useSelectContext(ARROW_NAME3, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME3, __scopeSelect);
    return context.open && contentContext.position === "popper" ? (0, import_jsx_runtime30.jsx)(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME3;
var BUBBLE_INPUT_NAME2 = "SelectBubbleInput";
var SelectBubbleInput = React29.forwardRef(
  ({ __scopeSelect, value, ...props2 }, forwardedRef) => {
    const ref = React29.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    React29.useEffect(() => {
      const select = ref.current;
      if (!select) return;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return (0, import_jsx_runtime30.jsx)(
      Primitive.select,
      {
        ...props2,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props2.style },
        ref: composedRefs,
        defaultValue: value
      }
    );
  }
);
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME2;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef(onSearchChange);
  const searchRef = React29.useRef("");
  const timerRef = React29.useRef(0);
  const handleTypeaheadSearch = React29.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React29.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React29.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray3(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray3(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}
var Root24 = Select;
var Trigger4 = SelectTrigger;
var Value = SelectValue;
var Icon = SelectIcon;
var Portal4 = SelectPortal;
var Content24 = SelectContent;
var Viewport = SelectViewport;
var Label5 = SelectLabel;
var Item3 = SelectItem;
var ItemText = SelectItemText;
var ItemIndicator3 = SelectItemIndicator;
var ScrollUpButton = SelectScrollUpButton;
var ScrollDownButton = SelectScrollDownButton;
var Separator3 = SelectSeparator;

// node_modules/@motiadev/ui/dist/components/ui/select.js
var Select2 = Root24;
var SelectValue2 = Value;
var SelectTrigger2 = React$12.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime15.c)(13);
  if ($[0] !== "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a") {
    for (let $i = 0; $i < 13; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a";
  }
  let children;
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, children, ...props2 } = t0);
    $[1] = t0;
    $[2] = children;
    $[3] = className;
    $[4] = props2;
  } else {
    children = $[2];
    className = $[3];
    props2 = $[4];
  }
  let t1;
  if ($[5] !== className) {
    t1 = cn("flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1", className);
    $[5] = className;
    $[6] = t1;
  } else t1 = $[6];
  let t2;
  if ($[7] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t2 = (0, import_jsx_runtime31.jsx)(Icon, {
      asChild: true,
      children: (0, import_jsx_runtime31.jsx)(import_lucide_react5.ChevronDown, { className: "h-4 w-4 opacity-50" })
    });
    $[7] = t2;
  } else t2 = $[7];
  let t3;
  if ($[8] !== children || $[9] !== props2 || $[10] !== ref || $[11] !== t1) {
    t3 = (0, import_jsx_runtime31.jsxs)(Trigger4, {
      ref,
      className: t1,
      ...props2,
      children: [children, t2]
    });
    $[8] = children;
    $[9] = props2;
    $[10] = ref;
    $[11] = t1;
    $[12] = t3;
  } else t3 = $[12];
  return t3;
});
SelectTrigger2.displayName = Trigger4.displayName;
var SelectScrollUpButton2 = React$12.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime15.c)(11);
  if ($[0] !== "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a") {
    for (let $i = 0; $i < 11; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("flex cursor-default items-center justify-center py-1", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t2 = (0, import_jsx_runtime31.jsx)(import_lucide_react5.ChevronUp, { className: "h-4 w-4" });
    $[6] = t2;
  } else t2 = $[6];
  let t3;
  if ($[7] !== props2 || $[8] !== ref || $[9] !== t1) {
    t3 = (0, import_jsx_runtime31.jsx)(ScrollUpButton, {
      ref,
      className: t1,
      ...props2,
      children: t2
    });
    $[7] = props2;
    $[8] = ref;
    $[9] = t1;
    $[10] = t3;
  } else t3 = $[10];
  return t3;
});
SelectScrollUpButton2.displayName = ScrollUpButton.displayName;
var SelectScrollDownButton2 = React$12.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime15.c)(11);
  if ($[0] !== "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a") {
    for (let $i = 0; $i < 11; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("flex cursor-default items-center justify-center py-1", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t2 = (0, import_jsx_runtime31.jsx)(import_lucide_react5.ChevronDown, { className: "h-4 w-4" });
    $[6] = t2;
  } else t2 = $[6];
  let t3;
  if ($[7] !== props2 || $[8] !== ref || $[9] !== t1) {
    t3 = (0, import_jsx_runtime31.jsx)(ScrollDownButton, {
      ref,
      className: t1,
      ...props2,
      children: t2
    });
    $[7] = props2;
    $[8] = ref;
    $[9] = t1;
    $[10] = t3;
  } else t3 = $[10];
  return t3;
});
SelectScrollDownButton2.displayName = ScrollDownButton.displayName;
var SelectContent2 = React$12.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime15.c)(22);
  if ($[0] !== "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a") {
    for (let $i = 0; $i < 22; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a";
  }
  let children;
  let className;
  let props2;
  let t1;
  if ($[1] !== t0) {
    ({ className, children, position: t1, ...props2 } = t0);
    $[1] = t0;
    $[2] = children;
    $[3] = className;
    $[4] = props2;
    $[5] = t1;
  } else {
    children = $[2];
    className = $[3];
    props2 = $[4];
    t1 = $[5];
  }
  const position = t1 === void 0 ? "popper" : t1;
  const t2 = position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1";
  let t3;
  if ($[6] !== className || $[7] !== t2) {
    t3 = cn("relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] backdrop-blur-2xl overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]", t2, className);
    $[6] = className;
    $[7] = t2;
    $[8] = t3;
  } else t3 = $[8];
  let t4;
  if ($[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t4 = (0, import_jsx_runtime31.jsx)(SelectScrollUpButton2, {});
    $[9] = t4;
  } else t4 = $[9];
  const t5 = position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]";
  let t6;
  if ($[10] !== t5) {
    t6 = cn("p-1", t5);
    $[10] = t5;
    $[11] = t6;
  } else t6 = $[11];
  let t7;
  if ($[12] !== children || $[13] !== t6) {
    t7 = (0, import_jsx_runtime31.jsx)(Viewport, {
      className: t6,
      children
    });
    $[12] = children;
    $[13] = t6;
    $[14] = t7;
  } else t7 = $[14];
  let t8;
  if ($[15] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t8 = (0, import_jsx_runtime31.jsx)(SelectScrollDownButton2, {});
    $[15] = t8;
  } else t8 = $[15];
  let t9;
  if ($[16] !== position || $[17] !== props2 || $[18] !== ref || $[19] !== t3 || $[20] !== t7) {
    t9 = (0, import_jsx_runtime31.jsx)(Portal4, { children: (0, import_jsx_runtime31.jsxs)(Content24, {
      ref,
      className: t3,
      position,
      ...props2,
      children: [
        t4,
        t7,
        t8
      ]
    }) });
    $[16] = position;
    $[17] = props2;
    $[18] = ref;
    $[19] = t3;
    $[20] = t7;
    $[21] = t9;
  } else t9 = $[21];
  return t9;
});
SelectContent2.displayName = Content24.displayName;
var SelectLabel2 = React$12.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime15.c)(10);
  if ($[0] !== "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a") {
    for (let $i = 0; $i < 10; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("px-2 py-1.5 text-sm font-semibold", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== ref || $[8] !== t1) {
    t2 = (0, import_jsx_runtime31.jsx)(Label5, {
      ref,
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = ref;
    $[8] = t1;
    $[9] = t2;
  } else t2 = $[9];
  return t2;
});
SelectLabel2.displayName = Label5.displayName;
var SelectItem2 = React$12.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime15.c)(15);
  if ($[0] !== "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a") {
    for (let $i = 0; $i < 15; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a";
  }
  let children;
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, children, ...props2 } = t0);
    $[1] = t0;
    $[2] = children;
    $[3] = className;
    $[4] = props2;
  } else {
    children = $[2];
    className = $[3];
    props2 = $[4];
  }
  let t1;
  if ($[5] !== className) {
    t1 = cn("relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", className);
    $[5] = className;
    $[6] = t1;
  } else t1 = $[6];
  let t2;
  if ($[7] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t2 = (0, import_jsx_runtime31.jsx)("span", {
      className: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center",
      children: (0, import_jsx_runtime31.jsx)(ItemIndicator3, { children: (0, import_jsx_runtime31.jsx)(import_lucide_react5.Check, { className: "h-4 w-4" }) })
    });
    $[7] = t2;
  } else t2 = $[7];
  let t3;
  if ($[8] !== children) {
    t3 = (0, import_jsx_runtime31.jsx)(ItemText, { children });
    $[8] = children;
    $[9] = t3;
  } else t3 = $[9];
  let t4;
  if ($[10] !== props2 || $[11] !== ref || $[12] !== t1 || $[13] !== t3) {
    t4 = (0, import_jsx_runtime31.jsxs)(Item3, {
      ref,
      className: t1,
      ...props2,
      children: [t2, t3]
    });
    $[10] = props2;
    $[11] = ref;
    $[12] = t1;
    $[13] = t3;
    $[14] = t4;
  } else t4 = $[14];
  return t4;
});
SelectItem2.displayName = Item3.displayName;
var SelectSeparator2 = React$12.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime15.c)(10);
  if ($[0] !== "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a") {
    for (let $i = 0; $i < 10; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "7558ea93396792fd0b2c0cde73c662fdbfcdbc0d323b3b63f0daa9d9121f355a";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("-mx-1 my-1 h-px bg-muted", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== ref || $[8] !== t1) {
    t2 = (0, import_jsx_runtime31.jsx)(Separator3, {
      ref,
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = ref;
    $[8] = t1;
    $[9] = t2;
  } else t2 = $[9];
  return t2;
});
SelectSeparator2.displayName = Separator3.displayName;

// node_modules/@motiadev/ui/dist/components/ui/side-panel.js
var import_compiler_runtime16 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_lucide_react6 = __toESM(require_lucide_react(), 1);
var SidePanel = (t0) => {
  const $ = (0, import_compiler_runtime16.c)(29);
  if ($[0] !== "39a5c1c37b367fbe5681e107f52c735a559918c882d3fc91fa9f52f7cdd414a8") {
    for (let $i = 0; $i < 29; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "39a5c1c37b367fbe5681e107f52c735a559918c882d3fc91fa9f52f7cdd414a8";
  }
  const { title, subtitle, actions, className, children, onClose } = t0;
  let t1;
  if ($[1] !== className) {
    t1 = cn("bg-muted-foreground/5 text-foreground border-l border-border overflow-hidden w-1/3", className);
    $[1] = className;
    $[2] = t1;
  } else t1 = $[2];
  let t2;
  if ($[3] !== title) {
    t2 = (0, import_jsx_runtime32.jsx)("div", {
      className: "text-lg font-semibold text-foreground tracking-[-0.25px] leading-tight",
      children: title
    });
    $[3] = title;
    $[4] = t2;
  } else t2 = $[4];
  let t3;
  if ($[5] !== actions) {
    t3 = actions?.map(_temp5);
    $[5] = actions;
    $[6] = t3;
  } else t3 = $[6];
  let t4;
  if ($[7] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t4 = (0, import_jsx_runtime32.jsx)(import_lucide_react6.X, { className: "w-4 h-4 text-muted-foreground" });
    $[7] = t4;
  } else t4 = $[7];
  let t5;
  if ($[8] !== onClose) {
    t5 = (0, import_jsx_runtime32.jsx)(Button, {
      onClick: onClose,
      variant: "ghost",
      size: "icon",
      "aria-label": "Close",
      children: t4
    });
    $[8] = onClose;
    $[9] = t5;
  } else t5 = $[9];
  let t6;
  if ($[10] !== t3 || $[11] !== t5) {
    t6 = (0, import_jsx_runtime32.jsxs)("div", {
      className: "flex items-center gap-1",
      children: [t3, t5]
    });
    $[10] = t3;
    $[11] = t5;
    $[12] = t6;
  } else t6 = $[12];
  let t7;
  if ($[13] !== t2 || $[14] !== t6) {
    t7 = (0, import_jsx_runtime32.jsxs)("div", {
      className: "flex items-center justify-between w-full",
      children: [t2, t6]
    });
    $[13] = t2;
    $[14] = t6;
    $[15] = t7;
  } else t7 = $[15];
  let t8;
  if ($[16] !== subtitle) {
    t8 = subtitle && (0, import_jsx_runtime32.jsx)("div", {
      className: "text-md font-medium text-muted-foreground tracking-[-0.25px] leading-tight",
      children: subtitle
    });
    $[16] = subtitle;
    $[17] = t8;
  } else t8 = $[17];
  let t9;
  if ($[18] !== t7 || $[19] !== t8) {
    t9 = (0, import_jsx_runtime32.jsx)("div", {
      className: "relative shrink-0 w-full border-b border-border",
      children: (0, import_jsx_runtime32.jsxs)("div", {
        className: "flex flex-col gap-0 p-4",
        children: [t7, t8]
      })
    });
    $[18] = t7;
    $[19] = t8;
    $[20] = t9;
  } else t9 = $[20];
  let t10;
  if ($[21] !== children) {
    t10 = (0, import_jsx_runtime32.jsx)("div", {
      className: "flex-1 overflow-auto",
      children: (0, import_jsx_runtime32.jsx)("div", {
        className: "flex flex-col gap-2 p-4",
        children
      })
    });
    $[21] = children;
    $[22] = t10;
  } else t10 = $[22];
  let t11;
  if ($[23] !== t10 || $[24] !== t9) {
    t11 = (0, import_jsx_runtime32.jsxs)("div", {
      className: "flex flex-col size-full",
      children: [t9, t10]
    });
    $[23] = t10;
    $[24] = t9;
    $[25] = t11;
  } else t11 = $[25];
  let t12;
  if ($[26] !== t1 || $[27] !== t11) {
    t12 = (0, import_jsx_runtime32.jsx)("div", {
      className: t1,
      children: t11
    });
    $[26] = t1;
    $[27] = t11;
    $[28] = t12;
  } else t12 = $[28];
  return t12;
};
SidePanel.displayName = "SidePanel";
function _temp5(action, index) {
  return (0, import_jsx_runtime32.jsx)(Button, {
    onClick: action.onClick,
    variant: "ghost",
    size: "icon",
    "aria-label": action.label,
    children: action.icon
  }, index);
}

// node_modules/@motiadev/ui/dist/components/ui/side-panel-detail.js
var import_compiler_runtime17 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var SidePanelDetail = (t0) => {
  const $ = (0, import_compiler_runtime17.c)(3);
  if ($[0] !== "4a0de11b1b19fb813ed181f71caf5142f82ef32c94a5d554fa707c7ef35cd632") {
    for (let $i = 0; $i < 3; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "4a0de11b1b19fb813ed181f71caf5142f82ef32c94a5d554fa707c7ef35cd632";
  }
  const { children } = t0;
  let t1;
  if ($[1] !== children) {
    t1 = (0, import_jsx_runtime33.jsx)("table", {
      className: "w-full",
      children
    });
    $[1] = children;
    $[2] = t1;
  } else t1 = $[2];
  return t1;
};
var SidePanelDetailItem = (t0) => {
  const $ = (0, import_compiler_runtime17.c)(8);
  if ($[0] !== "4a0de11b1b19fb813ed181f71caf5142f82ef32c94a5d554fa707c7ef35cd632") {
    for (let $i = 0; $i < 8; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "4a0de11b1b19fb813ed181f71caf5142f82ef32c94a5d554fa707c7ef35cd632";
  }
  const { title, children } = t0;
  let t1;
  if ($[1] !== title) {
    t1 = (0, import_jsx_runtime33.jsx)("td", {
      className: "text-md min-w-[100px] font-medium",
      children: title
    });
    $[1] = title;
    $[2] = t1;
  } else t1 = $[2];
  let t2;
  if ($[3] !== children) {
    t2 = (0, import_jsx_runtime33.jsx)("td", {
      className: "py-2 text-muted-foreground font-medium",
      children
    });
    $[3] = children;
    $[4] = t2;
  } else t2 = $[4];
  let t3;
  if ($[5] !== t1 || $[6] !== t2) {
    t3 = (0, import_jsx_runtime33.jsxs)("tr", { children: [t1, t2] });
    $[5] = t1;
    $[6] = t2;
    $[7] = t3;
  } else t3 = $[7];
  return t3;
};
SidePanelDetail.displayName = "SidePanelDetail";
SidePanelDetailItem.displayName = "SidePanelDetailItem";

// node_modules/@motiadev/ui/dist/components/ui/sidebar.js
var import_compiler_runtime18 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_lucide_react7 = __toESM(require_lucide_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_react_use_resizable = __toESM(require_lib(), 1);
var APP_SIDEBAR_CONTAINER_ID = "app-sidebar-container";
var CLOSE_PREVIOUS_SIDEBAR_EVENT = "close-previous-sidebar";
var Sidebar = (t0) => {
  const $ = (0, import_compiler_runtime18.c)(30);
  if ($[0] !== "2d038c97da230ef76b013d9bf722504b2323d8b19cafc19547e60c7328f1f3f3") {
    for (let $i = 0; $i < 30; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "2d038c97da230ef76b013d9bf722504b2323d8b19cafc19547e60c7328f1f3f3";
  }
  let containerId;
  let initialWidth;
  let onClose;
  let props2;
  if ($[1] !== t0) {
    ({ initialWidth, onClose, containerId, ...props2 } = t0);
    $[1] = t0;
    $[2] = containerId;
    $[3] = initialWidth;
    $[4] = onClose;
    $[5] = props2;
  } else {
    containerId = $[2];
    initialWidth = $[3];
    onClose = $[4];
    props2 = $[5];
  }
  let t1;
  if ($[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t1 = /* @__PURE__ */ Symbol();
    $[6] = t1;
  } else t1 = $[6];
  const sidebarId = t1;
  const t2 = initialWidth ?? 400;
  let t3;
  let t4;
  if ($[7] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t3 = _temp6;
    t4 = _temp23;
    $[7] = t3;
    $[8] = t4;
  } else {
    t3 = $[7];
    t4 = $[8];
  }
  let t5;
  if ($[9] !== t2) {
    t5 = {
      lockVertical: true,
      initialWidth: t2,
      initialHeight: "100%",
      onDragStart: t3,
      onDragEnd: t4
    };
    $[9] = t2;
    $[10] = t5;
  } else t5 = $[10];
  const { getRootProps, getHandleProps } = (0, import_react_use_resizable.useResizable)(t5);
  let t6;
  let t7;
  if ($[11] !== onClose) {
    t6 = () => {
      const event = new CustomEvent(CLOSE_PREVIOUS_SIDEBAR_EVENT, { detail: { sidebarId } });
      window.dispatchEvent(event);
      const handleClose = (e) => {
        if (e.detail.sidebarId !== sidebarId) onClose();
      };
      window.addEventListener(CLOSE_PREVIOUS_SIDEBAR_EVENT, handleClose);
      return () => {
        window.removeEventListener(CLOSE_PREVIOUS_SIDEBAR_EVENT, handleClose);
      };
    };
    t7 = [sidebarId, onClose];
    $[11] = onClose;
    $[12] = t6;
    $[13] = t7;
  } else {
    t6 = $[12];
    t7 = $[13];
  }
  (0, import_react11.useEffect)(t6, t7);
  let t8;
  if ($[14] !== getRootProps) {
    t8 = getRootProps();
    $[14] = getRootProps;
    $[15] = t8;
  } else t8 = $[15];
  let t9;
  if ($[16] !== getHandleProps) {
    t9 = getHandleProps({ reverse: true });
    $[16] = getHandleProps;
    $[17] = t9;
  } else t9 = $[17];
  let t10;
  if ($[18] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t10 = (0, import_jsx_runtime34.jsx)(import_lucide_react7.Equal, { className: "rotate-90 w-4 h-4 text-muted-foreground" });
    $[18] = t10;
  } else t10 = $[18];
  let t11;
  if ($[19] !== t9) {
    t11 = (0, import_jsx_runtime34.jsx)("div", {
      ...t9,
      className: "flex h-6 w-6 items-center justify-center rounded-full bg-background border border-border absolute top-1/2 -translate-y-1/2 -left-4 z-20",
      children: t10
    });
    $[19] = t9;
    $[20] = t11;
  } else t11 = $[20];
  let t12;
  if ($[21] !== props2) {
    t12 = (0, import_jsx_runtime34.jsx)(Panel2, {
      ...props2,
      variant: "outlined",
      className: "max-h-[calc(100vh-80px)] h-full",
      "data-testid": "sidebar-panel"
    });
    $[21] = props2;
    $[22] = t12;
  } else t12 = $[22];
  let t13;
  if ($[23] !== t11 || $[24] !== t12 || $[25] !== t8) {
    t13 = (0, import_jsx_runtime34.jsxs)("div", {
      ...t8,
      className: "pr-2 py-2 relative",
      children: [t11, t12]
    });
    $[23] = t11;
    $[24] = t12;
    $[25] = t8;
    $[26] = t13;
  } else t13 = $[26];
  let t14;
  if ($[27] !== containerId || $[28] !== t13) {
    t14 = (0, import_react_dom.createPortal)(t13, document.querySelector(`#${containerId ?? APP_SIDEBAR_CONTAINER_ID}`));
    $[27] = containerId;
    $[28] = t13;
    $[29] = t14;
  } else t14 = $[29];
  return t14;
};
function _temp6() {
  document.body.style.userSelect = "none";
}
function _temp23() {
  document.body.style.userSelect = "";
}

// node_modules/@motiadev/ui/dist/components/ui/table.js
var import_compiler_runtime19 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var Table = import_react12.default.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime19.c)(10);
  if ($[0] !== "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d") {
    for (let $i = 0; $i < 10; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("w-full caption-bottom text-sm", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== ref || $[8] !== t1) {
    t2 = (0, import_jsx_runtime35.jsx)("div", {
      className: "relative w-full overflow-auto",
      children: (0, import_jsx_runtime35.jsx)("table", {
        ref,
        className: t1,
        ...props2
      })
    });
    $[6] = props2;
    $[7] = ref;
    $[8] = t1;
    $[9] = t2;
  } else t2 = $[9];
  return t2;
});
Table.displayName = "Table";
var TableHeader = import_react12.default.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime19.c)(10);
  if ($[0] !== "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d") {
    for (let $i = 0; $i < 10; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("[&_tr]:border-b", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== ref || $[8] !== t1) {
    t2 = (0, import_jsx_runtime35.jsx)("thead", {
      ref,
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = ref;
    $[8] = t1;
    $[9] = t2;
  } else t2 = $[9];
  return t2;
});
TableHeader.displayName = "TableHeader";
var TableBody = import_react12.default.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime19.c)(10);
  if ($[0] !== "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d") {
    for (let $i = 0; $i < 10; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("[&_tr:last-child]:border-0", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== ref || $[8] !== t1) {
    t2 = (0, import_jsx_runtime35.jsx)("tbody", {
      ref,
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = ref;
    $[8] = t1;
    $[9] = t2;
  } else t2 = $[9];
  return t2;
});
TableBody.displayName = "TableBody";
var TableFooter = import_react12.default.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime19.c)(10);
  if ($[0] !== "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d") {
    for (let $i = 0; $i < 10; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== ref || $[8] !== t1) {
    t2 = (0, import_jsx_runtime35.jsx)("tfoot", {
      ref,
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = ref;
    $[8] = t1;
    $[9] = t2;
  } else t2 = $[9];
  return t2;
});
TableFooter.displayName = "TableFooter";
var TableRow = import_react12.default.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime19.c)(10);
  if ($[0] !== "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d") {
    for (let $i = 0; $i < 10; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== ref || $[8] !== t1) {
    t2 = (0, import_jsx_runtime35.jsx)("tr", {
      ref,
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = ref;
    $[8] = t1;
    $[9] = t2;
  } else t2 = $[9];
  return t2;
});
TableRow.displayName = "TableRow";
var TableHead = import_react12.default.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime19.c)(10);
  if ($[0] !== "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d") {
    for (let $i = 0; $i < 10; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("h-10 px-2 text-left align-middle text-md font-medium bg-muted text-muted-foreground font-bold [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== ref || $[8] !== t1) {
    t2 = (0, import_jsx_runtime35.jsx)("th", {
      ref,
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = ref;
    $[8] = t1;
    $[9] = t2;
  } else t2 = $[9];
  return t2;
});
TableHead.displayName = "TableHead";
var TableCell = import_react12.default.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime19.c)(10);
  if ($[0] !== "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d") {
    for (let $i = 0; $i < 10; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== ref || $[8] !== t1) {
    t2 = (0, import_jsx_runtime35.jsx)("td", {
      ref,
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = ref;
    $[8] = t1;
    $[9] = t2;
  } else t2 = $[9];
  return t2;
});
TableCell.displayName = "TableCell";
var TableCaption = import_react12.default.forwardRef((t0, ref) => {
  const $ = (0, import_compiler_runtime19.c)(10);
  if ($[0] !== "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d") {
    for (let $i = 0; $i < 10; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "beec69b290f0ccfec44f9ddba7d69326f6e92a8ed664f00af9e1ee8aa24ece7d";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("mt-4 text-sm text-muted-foreground", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== ref || $[8] !== t1) {
    t2 = (0, import_jsx_runtime35.jsx)("caption", {
      ref,
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = ref;
    $[8] = t1;
    $[9] = t2;
  } else t2 = $[9];
  return t2;
});
TableCaption.displayName = "TableCaption";

// node_modules/@motiadev/ui/dist/components/ui/textarea.js
var import_compiler_runtime20 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var Textarea = (t0) => {
  const $ = (0, import_compiler_runtime20.c)(9);
  if ($[0] !== "8729aeaaab40ae089d3b440a5df42e1fe74e369d064c98a53816787f6a89f3b5") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "8729aeaaab40ae089d3b440a5df42e1fe74e369d064c98a53816787f6a89f3b5";
  }
  let className;
  let props2;
  if ($[1] !== t0) {
    ({ className, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
  } else {
    className = $[2];
    props2 = $[3];
  }
  let t1;
  if ($[4] !== className) {
    t1 = cn("flex w-full rounded-md px-3 py-2 text-base transition-colors outline-none resize-none", "min-h-[80px] field-sizing-content", "bg-input", "border border-border", "text-foreground placeholder:text-muted-foreground", "hover:border-border", "focus-visible:border-ring focus-visible:ring-2 focus-visible:ring-ring/20", "aria-invalid:border-destructive", "disabled:cursor-not-allowed disabled:opacity-50", "text-sm font-medium leading-[1.3] tracking-[-0.01em]", className);
    $[4] = className;
    $[5] = t1;
  } else t1 = $[5];
  let t2;
  if ($[6] !== props2 || $[7] !== t1) {
    t2 = (0, import_jsx_runtime36.jsx)("textarea", {
      "data-slot": "textarea",
      className: t1,
      ...props2
    });
    $[6] = props2;
    $[7] = t1;
    $[8] = t2;
  } else t2 = $[8];
  return t2;
};
Textarea.displayName = "Textarea";

// node_modules/@motiadev/ui/dist/components/ui/tooltip.js
var import_compiler_runtime21 = __toESM(require_compiler_runtime(), 1);
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);
var TooltipProvider = Provider;
var Tooltip = Root3;
var TooltipTrigger = Trigger;
var TooltipContent = (0, import_react13.forwardRef)((t0, ref) => {
  const $ = (0, import_compiler_runtime21.c)(12);
  if ($[0] !== "998f5163afd7c73a109385e4bf93ddcb932577053296df407f5045f6e13857ad") {
    for (let $i = 0; $i < 12; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "998f5163afd7c73a109385e4bf93ddcb932577053296df407f5045f6e13857ad";
  }
  let className;
  let props2;
  let t1;
  if ($[1] !== t0) {
    ({ className, sideOffset: t1, ...props2 } = t0);
    $[1] = t0;
    $[2] = className;
    $[3] = props2;
    $[4] = t1;
  } else {
    className = $[2];
    props2 = $[3];
    t1 = $[4];
  }
  const sideOffset = t1 === void 0 ? 4 : t1;
  let t2;
  if ($[5] !== className) {
    t2 = cn("z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]", className);
    $[5] = className;
    $[6] = t2;
  } else t2 = $[6];
  let t3;
  if ($[7] !== props2 || $[8] !== ref || $[9] !== sideOffset || $[10] !== t2) {
    t3 = (0, import_jsx_runtime37.jsx)(Portal2, { children: (0, import_jsx_runtime37.jsx)(Content2, {
      ref,
      sideOffset,
      className: t2,
      ...props2
    }) });
    $[7] = props2;
    $[8] = ref;
    $[9] = sideOffset;
    $[10] = t2;
    $[11] = t3;
  } else t3 = $[11];
  return t3;
});
TooltipContent.displayName = Content2.displayName;

// node_modules/@motiadev/ui/dist/stores/use-theme-store.js
var updateTheme = (theme$1) => {
  const root = window.document.body;
  root.classList.remove("light", "dark");
  if (theme$1 === "system") {
    const systemTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    root.classList.add(systemTheme);
    return;
  }
  root.classList.add(theme$1);
};
var useThemeStore = create()(persist((set) => ({
  theme: "dark",
  setTheme: (theme$1) => {
    updateTheme(theme$1);
    set({ theme: theme$1 });
  }
}), {
  name: "motia-theme-storage",
  storage: createJSONStorage(() => localStorage)
}));
var { theme } = useThemeStore.getState();
if (theme) updateTheme(theme);

export {
  BackgroundEffect,
  cn,
  Badge,
  Button,
  useFocusGuards,
  FocusScope,
  hideOthers,
  Combination_default,
  DropdownMenu2 as DropdownMenu,
  DropdownMenuTrigger2 as DropdownMenuTrigger,
  DropdownMenuContent2 as DropdownMenuContent,
  DropdownMenuGroup2 as DropdownMenuGroup,
  DropdownMenuItem2 as DropdownMenuItem,
  DropdownMenuCheckboxItem2 as DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup2 as DropdownMenuRadioGroup,
  DropdownMenuRadioItem2 as DropdownMenuRadioItem,
  DropdownMenuLabel2 as DropdownMenuLabel,
  DropdownMenuSeparator2 as DropdownMenuSeparator,
  DropdownMenuSub2 as DropdownMenuSub,
  DropdownMenuSubTrigger2 as DropdownMenuSubTrigger,
  DropdownMenuSubContent2 as DropdownMenuSubContent,
  BreadcrumbItem,
  Breadcrumb,
  Checkbox2 as Checkbox,
  Container,
  ContainerHeader,
  ContainerContent,
  Tabs2 as Tabs,
  TabsList2 as TabsList,
  TabsTrigger2 as TabsTrigger,
  TabsContent2 as TabsContent,
  CollapsiblePanel,
  CollapsiblePanelGroup,
  Empty,
  EmptyHeader,
  EmptyMedia,
  EmptyTitle,
  EmptyDescription,
  EmptyContent,
  Input,
  Label4 as Label,
  LevelDot,
  PanelDetailItem,
  Panel2 as Panel,
  Select2 as Select,
  SelectValue2 as SelectValue,
  SelectTrigger2 as SelectTrigger,
  SelectContent2 as SelectContent,
  SelectItem2 as SelectItem,
  SidePanel,
  SidePanelDetail,
  SidePanelDetailItem,
  APP_SIDEBAR_CONTAINER_ID,
  Sidebar,
  Table,
  TableHeader,
  TableBody,
  TableRow,
  TableHead,
  TableCell,
  Textarea,
  TooltipProvider,
  Tooltip,
  TooltipTrigger,
  TooltipContent,
  useThemeStore
};
//# sourceMappingURL=chunk-IASMWHZ4.js.map
