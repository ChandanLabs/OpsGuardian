import {
  formatDistanceToNow
} from "./chunk-M662HLQD.js";
import {
  JsonView
} from "./chunk-K3BQSGJQ.js";
import {
  Button,
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
  Input,
  Sidebar,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
  Tabs,
  TabsList,
  TabsTrigger,
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
  cn
} from "./chunk-IASMWHZ4.js";
import {
  create
} from "./chunk-GN6RPVUP.js";
import "./chunk-PK4VJZPQ.js";
import "./chunk-H3Z5RFEW.js";
import "./chunk-6JCWOCCU.js";
import "./chunk-ZYTAZ2LT.js";
import {
  require_lucide_react
} from "./chunk-A2EHX3L2.js";
import {
  useStreamGroup
} from "./chunk-EC5G5YSN.js";
import "./chunk-7OWYCO6Z.js";
import "./chunk-ZOZQR6GQ.js";
import {
  require_jsx_runtime
} from "./chunk-OVCHON5Z.js";
import "./chunk-VZXGP5H5.js";
import {
  require_compiler_runtime
} from "./chunk-N7QBCMQ7.js";
import {
  require_react
} from "./chunk-J3YWFM6B.js";
import {
  __toESM
} from "./chunk-PR4QN5HX.js";

// node_modules/@motiadev/plugin-bullmq/dist/index.js
var import_compiler_runtime = __toESM(require_compiler_runtime());
var import_react = __toESM(require_react());

// node_modules/@tanstack/query-core/build/modern/subscribable.js
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};

// node_modules/@tanstack/query-core/build/modern/timeoutManager.js
var defaultTimeoutProvider = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: (callback, delay) => setTimeout(callback, delay),
  clearTimeout: (timeoutId) => clearTimeout(timeoutId),
  setInterval: (callback, delay) => setInterval(callback, delay),
  clearInterval: (intervalId) => clearInterval(intervalId)
};
var TimeoutManager = class {
  // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
  // type at app boot; and if we leave that type, then any new timer provider
  // would need to support ReturnType<typeof setTimeout>, which is infeasible.
  //
  // We settle for type safety for the TimeoutProvider type, and accept that
  // this class is unsafe internally to allow for extension.
  #provider = defaultTimeoutProvider;
  #providerCalled = false;
  setTimeoutProvider(provider) {
    if (true) {
      if (this.#providerCalled && provider !== this.#provider) {
        console.error(
          `[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.`,
          { previous: this.#provider, provider }
        );
      }
    }
    this.#provider = provider;
    if (true) {
      this.#providerCalled = false;
    }
  }
  setTimeout(callback, delay) {
    if (true) {
      this.#providerCalled = true;
    }
    return this.#provider.setTimeout(callback, delay);
  }
  clearTimeout(timeoutId) {
    this.#provider.clearTimeout(timeoutId);
  }
  setInterval(callback, delay) {
    if (true) {
      this.#providerCalled = true;
    }
    return this.#provider.setInterval(callback, delay);
  }
  clearInterval(intervalId) {
    this.#provider.clearInterval(intervalId);
  }
};
var timeoutManager = new TimeoutManager();
function systemSetTimeoutZero(callback) {
  setTimeout(callback, 0);
}

// node_modules/@tanstack/query-core/build/modern/utils.js
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop() {
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = options?.queryKeyHashFn || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]));
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty;
function replaceEqualDeep(a, b) {
  if (a === b) {
    return a;
  }
  const array = isPlainArray(a) && isPlainArray(b);
  if (!array && !(isPlainObject(a) && isPlainObject(b))) return b;
  const aItems = array ? a : Object.keys(a);
  const aSize = aItems.length;
  const bItems = array ? b : Object.keys(b);
  const bSize = bItems.length;
  const copy = array ? new Array(bSize) : {};
  let equalItems = 0;
  for (let i = 0; i < bSize; i++) {
    const key = array ? i : bItems[i];
    const aItem = a[key];
    const bItem = b[key];
    if (aItem === bItem) {
      copy[key] = aItem;
      if (array ? i < aSize : hasOwn.call(a, key)) equalItems++;
      continue;
    }
    if (aItem === null || bItem === null || typeof aItem !== "object" || typeof bItem !== "object") {
      copy[key] = bItem;
      continue;
    }
    const v = replaceEqualDeep(aItem, bItem);
    copy[key] = v;
    if (v === aItem) equalItems++;
  }
  return aSize === bSize && equalItems === aSize ? a : copy;
}
function shallowEqualObjects(a, b) {
  if (!b || Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function sleep(timeout) {
  return new Promise((resolve) => {
    timeoutManager.setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    if (true) {
      try {
        return replaceEqualDeep(prevData, data);
      } catch (error) {
        console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`
        );
        throw error;
      }
    }
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function addToEnd(items, item, max = 0) {
  const newItems = [...items, item];
  return max && newItems.length > max ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max = 0) {
  const newItems = [item, ...items];
  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
}
var skipToken = /* @__PURE__ */ Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (true) {
    if (options.queryFn === skipToken) {
      console.error(
        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`
      );
    }
  }
  if (!options.queryFn && fetchOptions?.initialPromise) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
function shouldThrowError(throwOnError, params) {
  if (typeof throwOnError === "function") {
    return throwOnError(...params);
  }
  return !!throwOnError;
}

// node_modules/@tanstack/query-core/build/modern/focusManager.js
var FocusManager = class extends Subscribable {
  #focused;
  #cleanup;
  #setup;
  constructor() {
    super();
    this.#setup = (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.();
      this.#cleanup = void 0;
    }
  }
  setEventListener(setup) {
    this.#setup = setup;
    this.#cleanup?.();
    this.#cleanup = setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    const changed = this.#focused !== focused;
    if (changed) {
      this.#focused = focused;
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    if (typeof this.#focused === "boolean") {
      return this.#focused;
    }
    return globalThis.document?.visibilityState !== "hidden";
  }
};
var focusManager = new FocusManager();

// node_modules/@tanstack/query-core/build/modern/thenable.js
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data) {
    Object.assign(thenable, data);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}

// node_modules/@tanstack/query-core/build/modern/notifyManager.js
var defaultScheduler = systemSetTimeoutZero;
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = defaultScheduler;
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn) => {
      notifyFn = fn;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn) => {
      batchNotifyFn = fn;
    },
    setScheduler: (fn) => {
      scheduleFn = fn;
    }
  };
}
var notifyManager = createNotifyManager();

// node_modules/@tanstack/query-core/build/modern/onlineManager.js
var OnlineManager = class extends Subscribable {
  #online = true;
  #cleanup;
  #setup;
  constructor() {
    super();
    this.#setup = (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.();
      this.#cleanup = void 0;
    }
  }
  setEventListener(setup) {
    this.#setup = setup;
    this.#cleanup?.();
    this.#cleanup = setup(this.setOnline.bind(this));
  }
  setOnline(online) {
    const changed = this.#online !== online;
    if (changed) {
      this.#online = online;
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return this.#online;
  }
};
var onlineManager = new OnlineManager();

// node_modules/@tanstack/query-core/build/modern/retryer.js
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options?.revert;
    this.silent = options?.silent;
  }
};
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let continueFn;
  const thenable = pendingThenable();
  const isResolved = () => thenable.status !== "pending";
  const cancel = (cancelOptions) => {
    if (!isResolved()) {
      const error = new CancelledError(cancelOptions);
      reject(error);
      config.onCancel?.(error);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config.networkMode === "always" || onlineManager.isOnline()) && config.canRun();
  const canStart = () => canFetch(config.networkMode) && config.canRun();
  const resolve = (value) => {
    if (!isResolved()) {
      continueFn?.();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved()) {
      continueFn?.();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        if (isResolved() || canContinue()) {
          continueResolve(value);
        }
      };
      config.onPause?.();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved()) {
        config.onContinue?.();
      }
    });
  };
  const run = () => {
    if (isResolved()) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      if (isResolved()) {
        return;
      }
      const retry = config.retry ?? (isServer ? 0 : 3);
      const retryDelay = config.retryDelay ?? defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config.onFail?.(failureCount, error);
      sleep(delay).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise: thenable,
    status: () => thenable.status,
    cancel,
    continue: () => {
      continueFn?.();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    }
  };
}

// node_modules/@tanstack/query-core/build/modern/removable.js
var Removable = class {
  #gcTimeout;
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      this.#gcTimeout = timeoutManager.setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime);
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (this.#gcTimeout) {
      timeoutManager.clearTimeout(this.#gcTimeout);
      this.#gcTimeout = void 0;
    }
  }
};

// node_modules/@tanstack/query-core/build/modern/query.js
var Query = class extends Removable {
  #initialState;
  #revertState;
  #cache;
  #client;
  #retryer;
  #defaultOptions;
  #abortSignalConsumed;
  constructor(config) {
    super();
    this.#abortSignalConsumed = false;
    this.#defaultOptions = config.defaultOptions;
    this.setOptions(config.options);
    this.observers = [];
    this.#client = config.client;
    this.#cache = this.#client.getQueryCache();
    this.queryKey = config.queryKey;
    this.queryHash = config.queryHash;
    this.#initialState = getDefaultState(this.options);
    this.state = config.state ?? this.#initialState;
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return this.#retryer?.promise;
  }
  setOptions(options) {
    this.options = { ...this.#defaultOptions, ...options };
    this.updateGcTime(this.options.gcTime);
    if (this.state && this.state.data === void 0) {
      const defaultState = getDefaultState(this.options);
      if (defaultState.data !== void 0) {
        this.setState(
          successState(defaultState.data, defaultState.dataUpdatedAt)
        );
        this.#initialState = defaultState;
      }
    }
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      this.#cache.remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    this.#dispatch({
      data,
      type: "success",
      dataUpdatedAt: options?.updatedAt,
      manual: options?.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    this.#dispatch({ type: "setState", state, setStateOptions });
  }
  cancel(options) {
    const promise = this.#retryer?.promise;
    this.#retryer?.cancel(options);
    return promise ? promise.then(noop).catch(noop) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(this.#initialState);
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    if (this.getObserversCount() > 0) {
      return !this.isActive();
    }
    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => resolveStaleTime(observer.options.staleTime, this) === "static"
      );
    }
    return false;
  }
  isStale() {
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(staleTime = 0) {
    if (this.state.data === void 0) {
      return true;
    }
    if (staleTime === "static") {
      return false;
    }
    if (this.state.isInvalidated) {
      return true;
    }
    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
    observer?.refetch({ cancelRefetch: false });
    this.#retryer?.continue();
  }
  onOnline() {
    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
    observer?.refetch({ cancelRefetch: false });
    this.#retryer?.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.#cache.notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x) => x !== observer);
      if (!this.observers.length) {
        if (this.#retryer) {
          if (this.#abortSignalConsumed) {
            this.#retryer.cancel({ revert: true });
          } else {
            this.#retryer.cancelRetry();
          }
        }
        this.scheduleGc();
      }
      this.#cache.notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      this.#dispatch({ type: "invalidate" });
    }
  }
  async fetch(options, fetchOptions) {
    if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    this.#retryer?.status() !== "rejected") {
      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {
        this.cancel({ silent: true });
      } else if (this.#retryer) {
        this.#retryer.continueRetry();
        return this.#retryer.promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x) => x.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    if (true) {
      if (!Array.isArray(this.options.queryKey)) {
        console.error(
          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`
        );
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          this.#abortSignalConsumed = true;
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const createQueryFnContext = () => {
        const queryFnContext2 = {
          client: this.#client,
          queryKey: this.queryKey,
          meta: this.meta
        };
        addSignalProperty(queryFnContext2);
        return queryFnContext2;
      };
      const queryFnContext = createQueryFnContext();
      this.#abortSignalConsumed = false;
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const createFetchContext = () => {
      const context2 = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        client: this.#client,
        state: this.state,
        fetchFn
      };
      addSignalProperty(context2);
      return context2;
    };
    const context = createFetchContext();
    this.options.behavior?.onFetch(context, this);
    this.#revertState = this.state;
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== context.fetchOptions?.meta) {
      this.#dispatch({ type: "fetch", meta: context.fetchOptions?.meta });
    }
    this.#retryer = createRetryer({
      initialPromise: fetchOptions?.initialPromise,
      fn: context.fetchFn,
      onCancel: (error) => {
        if (error instanceof CancelledError && error.revert) {
          this.setState({
            ...this.#revertState,
            fetchStatus: "idle"
          });
        }
        abortController.abort();
      },
      onFail: (failureCount, error) => {
        this.#dispatch({ type: "failed", failureCount, error });
      },
      onPause: () => {
        this.#dispatch({ type: "pause" });
      },
      onContinue: () => {
        this.#dispatch({ type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    });
    try {
      const data = await this.#retryer.start();
      if (data === void 0) {
        if (true) {
          console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          );
        }
        throw new Error(`${this.queryHash} data is undefined`);
      }
      this.setData(data);
      this.#cache.config.onSuccess?.(data, this);
      this.#cache.config.onSettled?.(
        data,
        this.state.error,
        this
      );
      return data;
    } catch (error) {
      if (error instanceof CancelledError) {
        if (error.silent) {
          return this.#retryer.promise;
        } else if (error.revert) {
          if (this.state.data === void 0) {
            throw error;
          }
          return this.state.data;
        }
      }
      this.#dispatch({
        type: "error",
        error
      });
      this.#cache.config.onError?.(
        error,
        this
      );
      this.#cache.config.onSettled?.(
        this.state.data,
        error,
        this
      );
      throw error;
    } finally {
      this.scheduleGc();
    }
  }
  #dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state,
            ...fetchState(state.data, this.options),
            fetchMeta: action.meta ?? null
          };
        case "success":
          const newState = {
            ...state,
            ...successState(action.data, action.dataUpdatedAt),
            dataUpdateCount: state.dataUpdateCount + 1,
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
          this.#revertState = action.manual ? newState : void 0;
          return newState;
        case "error":
          const error = action.error;
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate();
      });
      this.#cache.notify({ query: this, type: "updated", action });
    });
  }
};
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function successState(data, dataUpdatedAt) {
  return {
    data,
    dataUpdatedAt: dataUpdatedAt ?? Date.now(),
    error: null,
    isInvalidated: false,
    status: "success"
  };
}
function getDefaultState(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}

// node_modules/@tanstack/query-core/build/modern/queryObserver.js
var QueryObserver = class extends Subscribable {
  constructor(client, options) {
    super();
    this.options = options;
    this.#client = client;
    this.#selectError = null;
    this.#currentThenable = pendingThenable();
    this.bindMethods();
    this.setOptions(options);
  }
  #client;
  #currentQuery = void 0;
  #currentQueryInitialState = void 0;
  #currentResult = void 0;
  #currentResultState;
  #currentResultOptions;
  #currentThenable;
  #selectError;
  #selectFn;
  #selectResult;
  // This property keeps track of the last query with defined data.
  // It will be used to pass the previous data and query to the placeholder function between renders.
  #lastQueryWithDefinedData;
  #staleTimeoutId;
  #refetchIntervalId;
  #currentRefetchInterval;
  #trackedProps = /* @__PURE__ */ new Set();
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      this.#currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.#currentQuery, this.options)) {
        this.#executeFetch();
      } else {
        this.updateResult();
      }
      this.#updateTimers();
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      this.#currentQuery,
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      this.#currentQuery,
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    this.#clearStaleTimeout();
    this.#clearRefetchInterval();
    this.#currentQuery.removeObserver(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    const prevQuery = this.#currentQuery;
    this.options = this.#client.defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== "boolean") {
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    }
    this.#updateQuery();
    this.#currentQuery.setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      this.#client.getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: this.#currentQuery,
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      this.#currentQuery,
      prevQuery,
      this.options,
      prevOptions
    )) {
      this.#executeFetch();
    }
    this.updateResult();
    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {
      this.#updateStaleTimeout();
    }
    const nextRefetchInterval = this.#computeRefetchInterval();
    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {
      this.#updateRefetchInterval(nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = this.#client.getQueryCache().build(this.#client, options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      this.#currentResult = result;
      this.#currentResultOptions = this.options;
      this.#currentResultState = this.#currentQuery.state;
    }
    return result;
  }
  getCurrentResult() {
    return this.#currentResult;
  }
  trackResult(result, onPropTracked) {
    return new Proxy(result, {
      get: (target, key) => {
        this.trackProp(key);
        onPropTracked?.(key);
        if (key === "promise") {
          this.trackProp("data");
          if (!this.options.experimental_prefetchInRender && this.#currentThenable.status === "pending") {
            this.#currentThenable.reject(
              new Error(
                "experimental_prefetchInRender feature flag is not enabled"
              )
            );
          }
        }
        return Reflect.get(target, key);
      }
    });
  }
  trackProp(key) {
    this.#trackedProps.add(key);
  }
  getCurrentQuery() {
    return this.#currentQuery;
  }
  refetch({ ...options } = {}) {
    return this.fetch({
      ...options
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = this.#client.defaultQueryOptions(options);
    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return this.#executeFetch({
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return this.#currentResult;
    });
  }
  #executeFetch(fetchOptions) {
    this.#updateQuery();
    let promise = this.#currentQuery.fetch(
      this.options,
      fetchOptions
    );
    if (!fetchOptions?.throwOnError) {
      promise = promise.catch(noop);
    }
    return promise;
  }
  #updateStaleTimeout() {
    this.#clearStaleTimeout();
    const staleTime = resolveStaleTime(
      this.options.staleTime,
      this.#currentQuery
    );
    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {
      return;
    }
    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);
    const timeout = time + 1;
    this.#staleTimeoutId = timeoutManager.setTimeout(() => {
      if (!this.#currentResult.isStale) {
        this.updateResult();
      }
    }, timeout);
  }
  #computeRefetchInterval() {
    return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;
  }
  #updateRefetchInterval(nextInterval) {
    this.#clearRefetchInterval();
    this.#currentRefetchInterval = nextInterval;
    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {
      return;
    }
    this.#refetchIntervalId = timeoutManager.setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        this.#executeFetch();
      }
    }, this.#currentRefetchInterval);
  }
  #updateTimers() {
    this.#updateStaleTimeout();
    this.#updateRefetchInterval(this.#computeRefetchInterval());
  }
  #clearStaleTimeout() {
    if (this.#staleTimeoutId) {
      timeoutManager.clearTimeout(this.#staleTimeoutId);
      this.#staleTimeoutId = void 0;
    }
  }
  #clearRefetchInterval() {
    if (this.#refetchIntervalId) {
      timeoutManager.clearInterval(this.#refetchIntervalId);
      this.#refetchIntervalId = void 0;
    }
  }
  createResult(query, options) {
    const prevQuery = this.#currentQuery;
    const prevOptions = this.options;
    const prevResult = this.#currentResult;
    const prevResultState = this.#currentResultState;
    const prevResultOptions = this.#currentResultOptions;
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;
    const { state } = query;
    let newState = { ...state };
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state.data, query.options)
        };
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    data = newState.data;
    let skipSelect = false;
    if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
      let placeholderData;
      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {
        placeholderData = prevResult.data;
        skipSelect = true;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          this.#lastQueryWithDefinedData?.state.data,
          this.#lastQueryWithDefinedData
        ) : options.placeholderData;
      }
      if (placeholderData !== void 0) {
        status = "success";
        data = replaceData(
          prevResult?.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (options.select && data !== void 0 && !skipSelect) {
      if (prevResult && data === prevResultState?.data && options.select === this.#selectFn) {
        data = this.#selectResult;
      } else {
        try {
          this.#selectFn = options.select;
          data = options.select(data);
          data = replaceData(prevResult?.data, data, options);
          this.#selectResult = data;
          this.#selectError = null;
        } catch (selectError) {
          this.#selectError = selectError;
        }
      }
    }
    if (this.#selectError) {
      error = this.#selectError;
      data = this.#selectResult;
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading,
      isLoading,
      data,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch,
      promise: this.#currentThenable,
      isEnabled: resolveEnabled(options.enabled, query) !== false
    };
    const nextResult = result;
    if (this.options.experimental_prefetchInRender) {
      const finalizeThenableIfPossible = (thenable) => {
        if (nextResult.status === "error") {
          thenable.reject(nextResult.error);
        } else if (nextResult.data !== void 0) {
          thenable.resolve(nextResult.data);
        }
      };
      const recreateThenable = () => {
        const pending = this.#currentThenable = nextResult.promise = pendingThenable();
        finalizeThenableIfPossible(pending);
      };
      const prevThenable = this.#currentThenable;
      switch (prevThenable.status) {
        case "pending":
          if (query.queryHash === prevQuery.queryHash) {
            finalizeThenableIfPossible(prevThenable);
          }
          break;
        case "fulfilled":
          if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
            recreateThenable();
          }
          break;
        case "rejected":
          if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
            recreateThenable();
          }
          break;
      }
    }
    return nextResult;
  }
  updateResult() {
    const prevResult = this.#currentResult;
    const nextResult = this.createResult(this.#currentQuery, this.options);
    this.#currentResultState = this.#currentQuery.state;
    this.#currentResultOptions = this.options;
    if (this.#currentResultState.data !== void 0) {
      this.#lastQueryWithDefinedData = this.#currentQuery;
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    this.#currentResult = nextResult;
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.#trackedProps.size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue ?? this.#trackedProps
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(this.#currentResult).some((key) => {
        const typedKey = key;
        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    this.#notify({ listeners: shouldNotifyListeners() });
  }
  #updateQuery() {
    const query = this.#client.getQueryCache().build(this.#client, this.options);
    if (query === this.#currentQuery) {
      return;
    }
    const prevQuery = this.#currentQuery;
    this.#currentQuery = query;
    this.#currentQueryInitialState = query.state;
    if (this.hasListeners()) {
      prevQuery?.removeObserver(this);
      query.addObserver(this);
    }
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      this.#updateTimers();
    }
  }
  #notify(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.#currentResult);
        });
      }
      this.#client.getQueryCache().notify({
        query: this.#currentQuery,
        type: "observerResultsUpdated"
      });
    });
  }
};
function shouldLoadOnMount(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false && resolveStaleTime(options.staleTime, query) !== "static") {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}

// node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      const options = context.options;
      const direction = context.fetchOptions?.meta?.fetchMore?.direction;
      const oldPages = context.state.data?.pages || [];
      const oldPageParams = context.state.data?.pageParams || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const createQueryFnContext = () => {
            const queryFnContext2 = {
              client: context.client,
              queryKey: context.queryKey,
              pageParam: param,
              direction: previous ? "backward" : "forward",
              meta: context.options.meta
            };
            addSignalProperty(queryFnContext2);
            return queryFnContext2;
          };
          const queryFnContext = createQueryFnContext();
          const page = await queryFn(queryFnContext);
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          return context.options.persister?.(
            fetchFn,
            {
              client: context.client,
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;
}

// node_modules/@tanstack/query-core/build/modern/mutation.js
var Mutation = class extends Removable {
  #client;
  #observers;
  #mutationCache;
  #retryer;
  constructor(config) {
    super();
    this.#client = config.client;
    this.mutationId = config.mutationId;
    this.#mutationCache = config.mutationCache;
    this.#observers = [];
    this.state = config.state || getDefaultState2();
    this.setOptions(config.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!this.#observers.includes(observer)) {
      this.#observers.push(observer);
      this.clearGcTimeout();
      this.#mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    this.#observers = this.#observers.filter((x) => x !== observer);
    this.scheduleGc();
    this.#mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!this.#observers.length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        this.#mutationCache.remove(this);
      }
    }
  }
  continue() {
    return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    const onContinue = () => {
      this.#dispatch({ type: "continue" });
    };
    const mutationFnContext = {
      client: this.#client,
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    this.#retryer = createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables, mutationFnContext);
      },
      onFail: (failureCount, error) => {
        this.#dispatch({ type: "failed", failureCount, error });
      },
      onPause: () => {
        this.#dispatch({ type: "pause" });
      },
      onContinue,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => this.#mutationCache.canRun(this)
    });
    const restored = this.state.status === "pending";
    const isPaused = !this.#retryer.canStart();
    try {
      if (restored) {
        onContinue();
      } else {
        this.#dispatch({ type: "pending", variables, isPaused });
        await this.#mutationCache.config.onMutate?.(
          variables,
          this,
          mutationFnContext
        );
        const context = await this.options.onMutate?.(
          variables,
          mutationFnContext
        );
        if (context !== this.state.context) {
          this.#dispatch({
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data = await this.#retryer.start();
      await this.#mutationCache.config.onSuccess?.(
        data,
        variables,
        this.state.context,
        this,
        mutationFnContext
      );
      await this.options.onSuccess?.(
        data,
        variables,
        this.state.context,
        mutationFnContext
      );
      await this.#mutationCache.config.onSettled?.(
        data,
        null,
        this.state.variables,
        this.state.context,
        this,
        mutationFnContext
      );
      await this.options.onSettled?.(
        data,
        null,
        variables,
        this.state.context,
        mutationFnContext
      );
      this.#dispatch({ type: "success", data });
      return data;
    } catch (error) {
      try {
        await this.#mutationCache.config.onError?.(
          error,
          variables,
          this.state.context,
          this,
          mutationFnContext
        );
        await this.options.onError?.(
          error,
          variables,
          this.state.context,
          mutationFnContext
        );
        await this.#mutationCache.config.onSettled?.(
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this,
          mutationFnContext
        );
        await this.options.onSettled?.(
          void 0,
          error,
          variables,
          this.state.context,
          mutationFnContext
        );
        throw error;
      } finally {
        this.#dispatch({ type: "error", error });
      }
    } finally {
      this.#mutationCache.runNext(this);
    }
  }
  #dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: action.failureCount,
            failureReason: action.error
          };
        case "pause":
          return {
            ...state,
            isPaused: true
          };
        case "continue":
          return {
            ...state,
            isPaused: false
          };
        case "pending":
          return {
            ...state,
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: action.isPaused,
            status: "pending",
            variables: action.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...state,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error"
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.#observers.forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      this.#mutationCache.notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }
};
function getDefaultState2() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}

// node_modules/@tanstack/query-core/build/modern/mutationCache.js
var MutationCache = class extends Subscribable {
  constructor(config = {}) {
    super();
    this.config = config;
    this.#mutations = /* @__PURE__ */ new Set();
    this.#scopes = /* @__PURE__ */ new Map();
    this.#mutationId = 0;
  }
  #mutations;
  #scopes;
  #mutationId;
  build(client, options, state) {
    const mutation = new Mutation({
      client,
      mutationCache: this,
      mutationId: ++this.#mutationId,
      options: client.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    this.#mutations.add(mutation);
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const scopedMutations = this.#scopes.get(scope);
      if (scopedMutations) {
        scopedMutations.push(mutation);
      } else {
        this.#scopes.set(scope, [mutation]);
      }
    }
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    if (this.#mutations.delete(mutation)) {
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const scopedMutations = this.#scopes.get(scope);
        if (scopedMutations) {
          if (scopedMutations.length > 1) {
            const index = scopedMutations.indexOf(mutation);
            if (index !== -1) {
              scopedMutations.splice(index, 1);
            }
          } else if (scopedMutations[0] === mutation) {
            this.#scopes.delete(scope);
          }
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const mutationsWithSameScope = this.#scopes.get(scope);
      const firstPendingMutation = mutationsWithSameScope?.find(
        (m) => m.state.status === "pending"
      );
      return !firstPendingMutation || firstPendingMutation === mutation;
    } else {
      return true;
    }
  }
  runNext(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);
      return foundMutation?.continue() ?? Promise.resolve();
    } else {
      return Promise.resolve();
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.#mutations.forEach((mutation) => {
        this.notify({ type: "removed", mutation });
      });
      this.#mutations.clear();
      this.#scopes.clear();
    });
  }
  getAll() {
    return Array.from(this.#mutations);
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop))
      )
    );
  }
};
function scopeFor(mutation) {
  return mutation.options.scope?.id;
}

// node_modules/@tanstack/query-core/build/modern/mutationObserver.js
var MutationObserver = class extends Subscribable {
  #client;
  #currentResult = void 0;
  #currentMutation;
  #mutateOptions;
  constructor(client, options) {
    super();
    this.#client = client;
    this.setOptions(options);
    this.bindMethods();
    this.#updateResult();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    this.options = this.#client.defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      this.#client.getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: this.#currentMutation,
        observer: this
      });
    }
    if (prevOptions?.mutationKey && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (this.#currentMutation?.state.status === "pending") {
      this.#currentMutation.setOptions(this.options);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#currentMutation?.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    this.#updateResult();
    this.#notify(action);
  }
  getCurrentResult() {
    return this.#currentResult;
  }
  reset() {
    this.#currentMutation?.removeObserver(this);
    this.#currentMutation = void 0;
    this.#updateResult();
    this.#notify();
  }
  mutate(variables, options) {
    this.#mutateOptions = options;
    this.#currentMutation?.removeObserver(this);
    this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);
    this.#currentMutation.addObserver(this);
    return this.#currentMutation.execute(variables);
  }
  #updateResult() {
    const state = this.#currentMutation?.state ?? getDefaultState2();
    this.#currentResult = {
      ...state,
      isPending: state.status === "pending",
      isSuccess: state.status === "success",
      isError: state.status === "error",
      isIdle: state.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
  }
  #notify(action) {
    notifyManager.batch(() => {
      if (this.#mutateOptions && this.hasListeners()) {
        const variables = this.#currentResult.variables;
        const onMutateResult = this.#currentResult.context;
        const context = {
          client: this.#client,
          meta: this.options.meta,
          mutationKey: this.options.mutationKey
        };
        if (action?.type === "success") {
          this.#mutateOptions.onSuccess?.(
            action.data,
            variables,
            onMutateResult,
            context
          );
          this.#mutateOptions.onSettled?.(
            action.data,
            null,
            variables,
            onMutateResult,
            context
          );
        } else if (action?.type === "error") {
          this.#mutateOptions.onError?.(
            action.error,
            variables,
            onMutateResult,
            context
          );
          this.#mutateOptions.onSettled?.(
            void 0,
            action.error,
            variables,
            onMutateResult,
            context
          );
        }
      }
      this.listeners.forEach((listener) => {
        listener(this.#currentResult);
      });
    });
  }
};

// node_modules/@tanstack/query-core/build/modern/queryCache.js
var QueryCache = class extends Subscribable {
  constructor(config = {}) {
    super();
    this.config = config;
    this.#queries = /* @__PURE__ */ new Map();
  }
  #queries;
  build(client, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        client,
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!this.#queries.has(query.queryHash)) {
      this.#queries.set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = this.#queries.get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        this.#queries.delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return this.#queries.get(queryHash);
  }
  getAll() {
    return [...this.#queries.values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
};

// node_modules/@tanstack/query-core/build/modern/queryClient.js
var QueryClient = class {
  #queryCache;
  #mutationCache;
  #defaultOptions;
  #queryDefaults;
  #mutationDefaults;
  #mountCount;
  #unsubscribeFocus;
  #unsubscribeOnline;
  constructor(config = {}) {
    this.#queryCache = config.queryCache || new QueryCache();
    this.#mutationCache = config.mutationCache || new MutationCache();
    this.#defaultOptions = config.defaultOptions || {};
    this.#queryDefaults = /* @__PURE__ */ new Map();
    this.#mutationDefaults = /* @__PURE__ */ new Map();
    this.#mountCount = 0;
  }
  mount() {
    this.#mountCount++;
    if (this.#mountCount !== 1) return;
    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        this.#queryCache.onFocus();
      }
    });
    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        this.#queryCache.onOnline();
      }
    });
  }
  unmount() {
    this.#mountCount--;
    if (this.#mountCount !== 0) return;
    this.#unsubscribeFocus?.();
    this.#unsubscribeFocus = void 0;
    this.#unsubscribeOnline?.();
    this.#unsubscribeOnline = void 0;
  }
  isFetching(filters) {
    return this.#queryCache.findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return this.#mutationCache.findAll({ ...filters, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return this.#queryCache.get(options.queryHash)?.state.data;
  }
  ensureQueryData(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    const query = this.#queryCache.build(this, defaultedOptions);
    const cachedData = query.state.data;
    if (cachedData === void 0) {
      return this.fetchQuery(options);
    }
    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
      void this.prefetchQuery(defaultedOptions);
    }
    return Promise.resolve(cachedData);
  }
  getQueriesData(filters) {
    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = this.#queryCache.get(
      defaultedOptions.queryHash
    );
    const prevData = query?.state.data;
    const data = functionalUpdate(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return this.#queryCache.get(
      options.queryHash
    )?.state;
  }
  removeQueries(filters) {
    const queryCache = this.#queryCache;
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = this.#queryCache;
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(
        {
          type: "active",
          ...filters
        },
        options
      );
    });
  }
  cancelQueries(filters, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop).catch(noop);
  }
  invalidateQueries(filters, options = {}) {
    return notifyManager.batch(() => {
      this.#queryCache.findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters?.refetchType === "none") {
        return Promise.resolve();
      }
      return this.refetchQueries(
        {
          ...filters,
          type: filters?.refetchType ?? filters?.type ?? "active"
        },
        options
      );
    });
  }
  refetchQueries(filters, options = {}) {
    const fetchOptions = {
      ...options,
      cancelRefetch: options.cancelRefetch ?? true
    };
    const promises = notifyManager.batch(
      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = this.#queryCache.build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop).catch(noop);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop).catch(noop);
  }
  ensureInfiniteQueryData(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.ensureQueryData(options);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return this.#mutationCache.resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return this.#queryCache;
  }
  getMutationCache() {
    return this.#mutationCache;
  }
  getDefaultOptions() {
    return this.#defaultOptions;
  }
  setDefaultOptions(options) {
    this.#defaultOptions = options;
  }
  setQueryDefaults(queryKey, options) {
    this.#queryDefaults.set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults = [...this.#queryDefaults.values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    this.#mutationDefaults.set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults = [...this.#mutationDefaults.values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...this.#defaultOptions.queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options?._defaulted) {
      return options;
    }
    return {
      ...this.#defaultOptions.mutations,
      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    this.#queryCache.clear();
    this.#mutationCache.clear();
  }
};

// node_modules/@tanstack/react-query/build/modern/useQueries.js
var React5 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js
var React = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var QueryClientContext = React.createContext(
  void 0
);
var useQueryClient = (queryClient2) => {
  const client = React.useContext(QueryClientContext);
  if (queryClient2) {
    return queryClient2;
  }
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};
var QueryClientProvider = ({
  client,
  children
}) => {
  React.useEffect(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  return (0, import_jsx_runtime.jsx)(QueryClientContext.Provider, { value: client, children });
};

// node_modules/@tanstack/react-query/build/modern/IsRestoringProvider.js
var React2 = __toESM(require_react(), 1);
var IsRestoringContext = React2.createContext(false);
var useIsRestoring = () => React2.useContext(IsRestoringContext);
var IsRestoringProvider = IsRestoringContext.Provider;

// node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js
var React3 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = React3.createContext(createValue());
var useQueryErrorResetBoundary = () => React3.useContext(QueryErrorResetBoundaryContext);

// node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js
var React4 = __toESM(require_react(), 1);
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  React4.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query,
  suspense
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));
};

// node_modules/@tanstack/react-query/build/modern/suspense.js
var ensureSuspenseTimers = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    const MIN_SUSPENSE_TIME_MS = 1e3;
    const clamp = (value) => value === "static" ? value : Math.max(value ?? MIN_SUSPENSE_TIME_MS, MIN_SUSPENSE_TIME_MS);
    const originalStaleTime = defaultedOptions.staleTime;
    defaultedOptions.staleTime = typeof originalStaleTime === "function" ? (...args) => clamp(originalStaleTime(...args)) : clamp(originalStaleTime);
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(
        defaultedOptions.gcTime,
        MIN_SUSPENSE_TIME_MS
      );
    }
  }
};
var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});

// node_modules/@tanstack/react-query/build/modern/useBaseQuery.js
var React6 = __toESM(require_react(), 1);
function useBaseQuery(options, Observer, queryClient2) {
  if (true) {
    if (typeof options !== "object" || Array.isArray(options)) {
      throw new Error(
        'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
      );
    }
  }
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const client = useQueryClient(queryClient2);
  const defaultedOptions = client.defaultQueryOptions(options);
  client.getDefaultOptions().queries?._experimental_beforeQuery?.(
    defaultedOptions
  );
  if (true) {
    if (!defaultedOptions.queryFn) {
      console.error(
        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
      );
    }
  }
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);
  const [observer] = React6.useState(
    () => new Observer(
      client,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  const shouldSubscribe = !isRestoring && options.subscribed !== false;
  React6.useSyncExternalStore(
    React6.useCallback(
      (onStoreChange) => {
        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;
        observer.updateResult();
        return unsubscribe;
      },
      [observer, shouldSubscribe]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  React6.useEffect(() => {
    observer.setOptions(defaultedOptions);
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client.getQueryCache().get(defaultedOptions.queryHash),
    suspense: defaultedOptions.suspense
  })) {
    throw result.error;
  }
  ;
  client.getDefaultOptions().queries?._experimental_afterQuery?.(
    defaultedOptions,
    result
  );
  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {
    const promise = isNewCacheEntry ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      client.getQueryCache().get(defaultedOptions.queryHash)?.promise
    );
    promise?.catch(noop).finally(() => {
      observer.updateResult();
    });
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}

// node_modules/@tanstack/react-query/build/modern/useQuery.js
function useQuery(options, queryClient2) {
  return useBaseQuery(options, QueryObserver, queryClient2);
}

// node_modules/@tanstack/react-query/build/modern/HydrationBoundary.js
var React7 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useIsFetching.js
var React8 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useMutationState.js
var React9 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useMutation.js
var React10 = __toESM(require_react(), 1);
function useMutation(options, queryClient2) {
  const client = useQueryClient(queryClient2);
  const [observer] = React10.useState(
    () => new MutationObserver(
      client,
      options
    )
  );
  React10.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = React10.useSyncExternalStore(
    React10.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = React10.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}

// node_modules/@motiadev/plugin-bullmq/dist/index.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_lucide_react = __toESM(require_lucide_react());
import "C:/Users/chandan2005/Desktop/chandan/Chandan-Projects/OpsGuardian/node_modules/react18-json-view/src/style.css";
var initialState = {
  queues: [],
  selectedQueue: null,
  selectedJob: null,
  selectedStatus: "waiting",
  error: null,
  searchQuery: "",
  jobDetailOpen: false
};
var useBullMQStore = create((set) => ({
  ...initialState,
  setQueues: (queues) => set({ queues }),
  setSelectedQueue: (queue) => set({
    selectedQueue: queue,
    selectedJob: null
  }),
  updateSelectedQueueStats: (queue) => set({ selectedQueue: queue }),
  setSelectedJob: (job) => set({ selectedJob: job }),
  setSelectedStatus: (status) => set({ selectedStatus: status }),
  setError: (error) => set({ error }),
  setSearchQuery: (query) => set({ searchQuery: query }),
  setJobDetailOpen: (open) => set({ jobDetailOpen: open }),
  reset: () => set(initialState)
}));
var STREAM_NAME = "__motia.bullmq-queues";
var useQueues = () => {
  const { queues, setQueues, setError, error, selectedQueue, setSelectedQueue } = useBullMQStore();
  const { data: streamQueues } = useStreamGroup({
    streamName: STREAM_NAME,
    groupId: "default"
  });
  (0, import_react.useEffect)(() => {
    if (streamQueues.length > 0) {
      setQueues(streamQueues);
      if (selectedQueue) {
        const updatedQueue = streamQueues.find((q) => q.name === selectedQueue.name);
        if (updatedQueue) {
          const currentStats = JSON.stringify(selectedQueue.stats);
          const newStats = JSON.stringify(updatedQueue.stats);
          const pausedChanged = selectedQueue.isPaused !== updatedQueue.isPaused;
          if (currentStats !== newStats || pausedChanged) setSelectedQueue(updatedQueue);
        }
      }
    }
  }, [
    streamQueues,
    setQueues,
    selectedQueue,
    setSelectedQueue
  ]);
  return {
    queues,
    error,
    refreshQueue: (0, import_react.useCallback)(async (name) => {
      try {
        const response = await fetch(`/__motia/bullmq/queues/${encodeURIComponent(name)}`);
        if (!response.ok) throw new Error("Failed to fetch queue");
        return await response.json();
      } catch {
        return null;
      }
    }, []),
    pauseQueue: (0, import_react.useCallback)(async (name_0) => {
      try {
        await fetch(`/__motia/bullmq/queues/${encodeURIComponent(name_0)}/pause`, { method: "POST" });
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to pause queue");
      }
    }, [setError]),
    resumeQueue: (0, import_react.useCallback)(async (name_1) => {
      try {
        await fetch(`/__motia/bullmq/queues/${encodeURIComponent(name_1)}/resume`, { method: "POST" });
      } catch (err_0) {
        setError(err_0 instanceof Error ? err_0.message : "Failed to resume queue");
      }
    }, [setError]),
    cleanQueue: (0, import_react.useCallback)(async (name_2, status, grace = 0, limit = 1e3) => {
      try {
        await fetch(`/__motia/bullmq/queues/${encodeURIComponent(name_2)}/clean`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            status,
            grace,
            limit
          })
        });
      } catch (err_1) {
        setError(err_1 instanceof Error ? err_1.message : "Failed to clean queue");
      }
    }, [setError]),
    drainQueue: (0, import_react.useCallback)(async (name_3) => {
      try {
        await fetch(`/__motia/bullmq/queues/${encodeURIComponent(name_3)}/drain`, { method: "POST" });
      } catch (err_2) {
        setError(err_2 instanceof Error ? err_2.message : "Failed to drain queue");
      }
    }, [setError])
  };
};
var queryClient = new QueryClient({ defaultOptions: { queries: {
  staleTime: 5e3,
  refetchOnWindowFocus: false,
  retry: 1
} } });
var QueryProvider = (t0) => {
  const $ = (0, import_compiler_runtime.c)(3);
  if ($[0] !== "72268343e8809a517b650d94aea39cf9f299784a2a89cdc3b8e9a0d84a7244b8") {
    for (let $i = 0; $i < 3; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "72268343e8809a517b650d94aea39cf9f299784a2a89cdc3b8e9a0d84a7244b8";
  }
  const { children } = t0;
  let t1;
  if ($[1] !== children) {
    t1 = (0, import_jsx_runtime3.jsx)(QueryClientProvider, {
      client: queryClient,
      children
    });
    $[1] = children;
    $[2] = t1;
  } else t1 = $[2];
  return t1;
};
var retryJobFn = async ({ queueName, jobId }) => {
  if (!(await fetch(`/__motia/bullmq/queues/${encodeURIComponent(queueName)}/jobs/${encodeURIComponent(jobId)}/retry`, { method: "POST" })).ok) throw new Error("Failed to retry job");
};
var removeJobFn = async ({ queueName, jobId }) => {
  if (!(await fetch(`/__motia/bullmq/queues/${encodeURIComponent(queueName)}/jobs/${encodeURIComponent(jobId)}/remove`, { method: "POST" })).ok) throw new Error("Failed to remove job");
};
var promoteJobFn = async ({ queueName, jobId }) => {
  if (!(await fetch(`/__motia/bullmq/queues/${encodeURIComponent(queueName)}/jobs/${encodeURIComponent(jobId)}/promote`, { method: "POST" })).ok) throw new Error("Failed to promote job");
};
var retryFromDLQFn = async ({ queueName, jobId }) => {
  if (!(await fetch(`/__motia/bullmq/dlq/${encodeURIComponent(queueName)}/retry/${encodeURIComponent(jobId)}`, { method: "POST" })).ok) throw new Error("Failed to retry from DLQ");
};
var retryAllFromDLQFn = async ({ queueName }) => {
  if (!(await fetch(`/__motia/bullmq/dlq/${encodeURIComponent(queueName)}/retry-all`, { method: "POST" })).ok) throw new Error("Failed to retry all from DLQ");
};
var clearDLQFn = async ({ queueName }) => {
  if (!(await fetch(`/__motia/bullmq/dlq/${encodeURIComponent(queueName)}/clear`, { method: "POST" })).ok) throw new Error("Failed to clear DLQ");
};
var useRetryJob = () => {
  const $ = (0, import_compiler_runtime.c)(8);
  if ($[0] !== "dda4e584b854b7387aa6e222ff1915ce152f6bfdf2fc4ff1beda4b29692e9177") {
    for (let $i = 0; $i < 8; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "dda4e584b854b7387aa6e222ff1915ce152f6bfdf2fc4ff1beda4b29692e9177";
  }
  const queryClient$1 = useQueryClient();
  const setError = useBullMQStore(_temp$7);
  let t0;
  if ($[1] !== queryClient$1) {
    t0 = (_, t1$1) => {
      const { queueName } = t1$1;
      queryClient$1.invalidateQueries({ queryKey: ["jobs", queueName] });
    };
    $[1] = queryClient$1;
    $[2] = t0;
  } else t0 = $[2];
  let t1;
  if ($[3] !== setError) {
    t1 = (error) => {
      setError(error instanceof Error ? error.message : "Failed to retry job");
    };
    $[3] = setError;
    $[4] = t1;
  } else t1 = $[4];
  let t2;
  if ($[5] !== t0 || $[6] !== t1) {
    t2 = {
      mutationFn: retryJobFn,
      onSuccess: t0,
      onError: t1
    };
    $[5] = t0;
    $[6] = t1;
    $[7] = t2;
  } else t2 = $[7];
  return useMutation(t2);
};
var useRemoveJob = () => {
  const $ = (0, import_compiler_runtime.c)(8);
  if ($[0] !== "dda4e584b854b7387aa6e222ff1915ce152f6bfdf2fc4ff1beda4b29692e9177") {
    for (let $i = 0; $i < 8; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "dda4e584b854b7387aa6e222ff1915ce152f6bfdf2fc4ff1beda4b29692e9177";
  }
  const queryClient$1 = useQueryClient();
  const setError = useBullMQStore(_temp2$7);
  let t0;
  if ($[1] !== queryClient$1) {
    t0 = (_, t1$1) => {
      const { queueName } = t1$1;
      queryClient$1.invalidateQueries({ queryKey: ["jobs", queueName] });
    };
    $[1] = queryClient$1;
    $[2] = t0;
  } else t0 = $[2];
  let t1;
  if ($[3] !== setError) {
    t1 = (error) => {
      setError(error instanceof Error ? error.message : "Failed to remove job");
    };
    $[3] = setError;
    $[4] = t1;
  } else t1 = $[4];
  let t2;
  if ($[5] !== t0 || $[6] !== t1) {
    t2 = {
      mutationFn: removeJobFn,
      onSuccess: t0,
      onError: t1
    };
    $[5] = t0;
    $[6] = t1;
    $[7] = t2;
  } else t2 = $[7];
  return useMutation(t2);
};
var usePromoteJob = () => {
  const $ = (0, import_compiler_runtime.c)(8);
  if ($[0] !== "dda4e584b854b7387aa6e222ff1915ce152f6bfdf2fc4ff1beda4b29692e9177") {
    for (let $i = 0; $i < 8; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "dda4e584b854b7387aa6e222ff1915ce152f6bfdf2fc4ff1beda4b29692e9177";
  }
  const queryClient$1 = useQueryClient();
  const setError = useBullMQStore(_temp3$4);
  let t0;
  if ($[1] !== queryClient$1) {
    t0 = (_, t1$1) => {
      const { queueName } = t1$1;
      queryClient$1.invalidateQueries({ queryKey: ["jobs", queueName] });
    };
    $[1] = queryClient$1;
    $[2] = t0;
  } else t0 = $[2];
  let t1;
  if ($[3] !== setError) {
    t1 = (error) => {
      setError(error instanceof Error ? error.message : "Failed to promote job");
    };
    $[3] = setError;
    $[4] = t1;
  } else t1 = $[4];
  let t2;
  if ($[5] !== t0 || $[6] !== t1) {
    t2 = {
      mutationFn: promoteJobFn,
      onSuccess: t0,
      onError: t1
    };
    $[5] = t0;
    $[6] = t1;
    $[7] = t2;
  } else t2 = $[7];
  return useMutation(t2);
};
var useRetryFromDLQ = () => {
  const $ = (0, import_compiler_runtime.c)(8);
  if ($[0] !== "dda4e584b854b7387aa6e222ff1915ce152f6bfdf2fc4ff1beda4b29692e9177") {
    for (let $i = 0; $i < 8; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "dda4e584b854b7387aa6e222ff1915ce152f6bfdf2fc4ff1beda4b29692e9177";
  }
  const queryClient$1 = useQueryClient();
  const setError = useBullMQStore(_temp4$3);
  let t0;
  if ($[1] !== queryClient$1) {
    t0 = (_, t1$1) => {
      const { queueName } = t1$1;
      queryClient$1.invalidateQueries({ queryKey: ["dlq-jobs", queueName] });
    };
    $[1] = queryClient$1;
    $[2] = t0;
  } else t0 = $[2];
  let t1;
  if ($[3] !== setError) {
    t1 = (error) => {
      setError(error instanceof Error ? error.message : "Failed to retry from DLQ");
    };
    $[3] = setError;
    $[4] = t1;
  } else t1 = $[4];
  let t2;
  if ($[5] !== t0 || $[6] !== t1) {
    t2 = {
      mutationFn: retryFromDLQFn,
      onSuccess: t0,
      onError: t1
    };
    $[5] = t0;
    $[6] = t1;
    $[7] = t2;
  } else t2 = $[7];
  return useMutation(t2);
};
var useRetryAllFromDLQ = () => {
  const $ = (0, import_compiler_runtime.c)(8);
  if ($[0] !== "dda4e584b854b7387aa6e222ff1915ce152f6bfdf2fc4ff1beda4b29692e9177") {
    for (let $i = 0; $i < 8; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "dda4e584b854b7387aa6e222ff1915ce152f6bfdf2fc4ff1beda4b29692e9177";
  }
  const queryClient$1 = useQueryClient();
  const setError = useBullMQStore(_temp5$3);
  let t0;
  if ($[1] !== queryClient$1) {
    t0 = (_, t1$1) => {
      const { queueName } = t1$1;
      queryClient$1.invalidateQueries({ queryKey: ["dlq-jobs", queueName] });
    };
    $[1] = queryClient$1;
    $[2] = t0;
  } else t0 = $[2];
  let t1;
  if ($[3] !== setError) {
    t1 = (error) => {
      setError(error instanceof Error ? error.message : "Failed to retry all from DLQ");
    };
    $[3] = setError;
    $[4] = t1;
  } else t1 = $[4];
  let t2;
  if ($[5] !== t0 || $[6] !== t1) {
    t2 = {
      mutationFn: retryAllFromDLQFn,
      onSuccess: t0,
      onError: t1
    };
    $[5] = t0;
    $[6] = t1;
    $[7] = t2;
  } else t2 = $[7];
  return useMutation(t2);
};
var useClearDLQ = () => {
  const $ = (0, import_compiler_runtime.c)(8);
  if ($[0] !== "dda4e584b854b7387aa6e222ff1915ce152f6bfdf2fc4ff1beda4b29692e9177") {
    for (let $i = 0; $i < 8; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "dda4e584b854b7387aa6e222ff1915ce152f6bfdf2fc4ff1beda4b29692e9177";
  }
  const queryClient$1 = useQueryClient();
  const setError = useBullMQStore(_temp6$1);
  let t0;
  if ($[1] !== queryClient$1) {
    t0 = (_, t1$1) => {
      const { queueName } = t1$1;
      queryClient$1.invalidateQueries({ queryKey: ["dlq-jobs", queueName] });
    };
    $[1] = queryClient$1;
    $[2] = t0;
  } else t0 = $[2];
  let t1;
  if ($[3] !== setError) {
    t1 = (error) => {
      setError(error instanceof Error ? error.message : "Failed to clear DLQ");
    };
    $[3] = setError;
    $[4] = t1;
  } else t1 = $[4];
  let t2;
  if ($[5] !== t0 || $[6] !== t1) {
    t2 = {
      mutationFn: clearDLQFn,
      onSuccess: t0,
      onError: t1
    };
    $[5] = t0;
    $[6] = t1;
    $[7] = t2;
  } else t2 = $[7];
  return useMutation(t2);
};
function _temp$7(state) {
  return state.setError;
}
function _temp2$7(state) {
  return state.setError;
}
function _temp3$4(state) {
  return state.setError;
}
function _temp4$3(state) {
  return state.setError;
}
function _temp5$3(state) {
  return state.setError;
}
function _temp6$1(state) {
  return state.setError;
}
var fetchJobs = async (queueName, status, start = 0, end = 100) => {
  const params = new URLSearchParams({
    status,
    start: String(start),
    end: String(end)
  });
  const response = await fetch(`/__motia/bullmq/queues/${encodeURIComponent(queueName)}/jobs?${params}`);
  if (!response.ok) throw new Error("Failed to fetch jobs");
  return (await response.json()).jobs;
};
var fetchDLQJobs = async (queueName, start = 0, end = 100) => {
  const params = new URLSearchParams({
    start: String(start),
    end: String(end)
  });
  const response = await fetch(`/__motia/bullmq/dlq/${encodeURIComponent(queueName)}/jobs?${params}`);
  if (!response.ok) return [];
  return (await response.json()).jobs;
};
var useJobsQuery = () => {
  const $ = (0, import_compiler_runtime.c)(14);
  if ($[0] !== "62345f058f3013b9a25310d4c1435bcda4709648cddbee0fee4472c79e98da42") {
    for (let $i = 0; $i < 14; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "62345f058f3013b9a25310d4c1435bcda4709648cddbee0fee4472c79e98da42";
  }
  const selectedQueue = useBullMQStore(_temp$6);
  const selectedStatus = useBullMQStore(_temp2$6);
  const queueName = selectedQueue?.name;
  let t0;
  if ($[1] !== selectedQueue) {
    t0 = selectedQueue ? JSON.stringify(selectedQueue.stats) : null;
    $[1] = selectedQueue;
    $[2] = t0;
  } else t0 = $[2];
  const statsKey = t0;
  let t1;
  if ($[3] !== queueName || $[4] !== selectedStatus || $[5] !== statsKey) {
    t1 = [
      "jobs",
      queueName,
      selectedStatus,
      statsKey
    ];
    $[3] = queueName;
    $[4] = selectedStatus;
    $[5] = statsKey;
    $[6] = t1;
  } else t1 = $[6];
  let t2;
  if ($[7] !== queueName || $[8] !== selectedStatus) {
    t2 = () => fetchJobs(queueName, selectedStatus);
    $[7] = queueName;
    $[8] = selectedStatus;
    $[9] = t2;
  } else t2 = $[9];
  const t3 = !!queueName;
  let t4;
  if ($[10] !== t1 || $[11] !== t2 || $[12] !== t3) {
    t4 = {
      queryKey: t1,
      queryFn: t2,
      enabled: t3,
      staleTime: 5e3
    };
    $[10] = t1;
    $[11] = t2;
    $[12] = t3;
    $[13] = t4;
  } else t4 = $[13];
  return useQuery(t4);
};
var useDLQJobsQuery = (queueName) => {
  const $ = (0, import_compiler_runtime.c)(8);
  if ($[0] !== "62345f058f3013b9a25310d4c1435bcda4709648cddbee0fee4472c79e98da42") {
    for (let $i = 0; $i < 8; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "62345f058f3013b9a25310d4c1435bcda4709648cddbee0fee4472c79e98da42";
  }
  let t0;
  let t1;
  if ($[1] !== queueName) {
    t0 = ["dlq-jobs", queueName];
    t1 = () => fetchDLQJobs(queueName);
    $[1] = queueName;
    $[2] = t0;
    $[3] = t1;
  } else {
    t0 = $[2];
    t1 = $[3];
  }
  const t2 = !!queueName;
  let t3;
  if ($[4] !== t0 || $[5] !== t1 || $[6] !== t2) {
    t3 = {
      queryKey: t0,
      queryFn: t1,
      enabled: t2
    };
    $[4] = t0;
    $[5] = t1;
    $[6] = t2;
    $[7] = t3;
  } else t3 = $[7];
  return useQuery(t3);
};
function _temp$6(state) {
  return state.selectedQueue;
}
function _temp2$6(state_0) {
  return state_0.selectedStatus;
}
var DLQJobDetailContent = (0, import_react.memo)((t0) => {
  const $ = (0, import_compiler_runtime.c)(30);
  if ($[0] !== "9c642c700580e607dc6114475cae1bdbb21b1057857ec3c5d1e46ac6c107027a") {
    for (let $i = 0; $i < 30; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "9c642c700580e607dc6114475cae1bdbb21b1057857ec3c5d1e46ac6c107027a";
  }
  const { job, onRetry } = t0;
  let t1;
  if ($[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t1 = (0, import_jsx_runtime3.jsx)(import_lucide_react.RefreshCw, { className: "mr-2 h-4 w-4" });
    $[1] = t1;
  } else t1 = $[1];
  let t2;
  if ($[2] !== onRetry) {
    t2 = (0, import_jsx_runtime3.jsx)("div", {
      className: "flex gap-2",
      children: (0, import_jsx_runtime3.jsxs)(Button, {
        variant: "outline",
        size: "sm",
        onClick: onRetry,
        children: [t1, "Retry"]
      })
    });
    $[2] = onRetry;
    $[3] = t2;
  } else t2 = $[3];
  let t3;
  if ($[4] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t3 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Job ID"
    });
    $[4] = t3;
  } else t3 = $[4];
  let t4;
  if ($[5] !== job.id) {
    t4 = (0, import_jsx_runtime3.jsxs)("div", { children: [t3, (0, import_jsx_runtime3.jsx)("div", {
      className: "font-mono text-xs",
      children: job.id
    })] });
    $[5] = job.id;
    $[6] = t4;
  } else t4 = $[6];
  let t5;
  if ($[7] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t5 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Original Job ID"
    });
    $[7] = t5;
  } else t5 = $[7];
  const t6 = job.originalJobId || "-";
  let t7;
  if ($[8] !== t6) {
    t7 = (0, import_jsx_runtime3.jsxs)("div", { children: [t5, (0, import_jsx_runtime3.jsx)("div", {
      className: "font-mono text-xs",
      children: t6
    })] });
    $[8] = t6;
    $[9] = t7;
  } else t7 = $[9];
  let t8;
  if ($[10] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t8 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Attempts Made"
    });
    $[10] = t8;
  } else t8 = $[10];
  let t9;
  if ($[11] !== job.attemptsMade) {
    t9 = (0, import_jsx_runtime3.jsxs)("div", { children: [t8, (0, import_jsx_runtime3.jsx)("div", {
      className: "font-semibold",
      children: job.attemptsMade
    })] });
    $[11] = job.attemptsMade;
    $[12] = t9;
  } else t9 = $[12];
  let t10;
  if ($[13] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t10 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Failed At"
    });
    $[13] = t10;
  } else t10 = $[13];
  let t11;
  if ($[14] !== job.failureTimestamp) {
    t11 = formatDistanceToNow(job.failureTimestamp, { addSuffix: true });
    $[14] = job.failureTimestamp;
    $[15] = t11;
  } else t11 = $[15];
  let t12;
  if ($[16] !== t11) {
    t12 = (0, import_jsx_runtime3.jsxs)("div", { children: [t10, (0, import_jsx_runtime3.jsx)("div", { children: t11 })] });
    $[16] = t11;
    $[17] = t12;
  } else t12 = $[17];
  let t13;
  if ($[18] !== t12 || $[19] !== t4 || $[20] !== t7 || $[21] !== t9) {
    t13 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "grid grid-cols-2 gap-4 text-sm",
      children: [
        t4,
        t7,
        t9,
        t12
      ]
    });
    $[18] = t12;
    $[19] = t4;
    $[20] = t7;
    $[21] = t9;
    $[22] = t13;
  } else t13 = $[22];
  let t14;
  if ($[23] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t14 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-sm font-semibold text-destructive mb-2",
      children: "Failure Reason"
    });
    $[23] = t14;
  } else t14 = $[23];
  let t15;
  if ($[24] !== job.failureReason) {
    t15 = (0, import_jsx_runtime3.jsxs)("div", { children: [t14, (0, import_jsx_runtime3.jsx)("div", {
      className: "font-mono text-sm bg-destructive/10 p-3 rounded text-destructive",
      children: job.failureReason
    })] });
    $[24] = job.failureReason;
    $[25] = t15;
  } else t15 = $[25];
  let t16;
  if ($[26] !== t13 || $[27] !== t15 || $[28] !== t2) {
    t16 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "space-y-4",
      children: [
        t2,
        t13,
        t15
      ]
    });
    $[26] = t13;
    $[27] = t15;
    $[28] = t2;
    $[29] = t16;
  } else t16 = $[29];
  return t16;
});
DLQJobDetailContent.displayName = "DLQJobDetailContent";
var DLQJobDataTab = (0, import_react.memo)((t0) => {
  const $ = (0, import_compiler_runtime.c)(3);
  if ($[0] !== "9c642c700580e607dc6114475cae1bdbb21b1057857ec3c5d1e46ac6c107027a") {
    for (let $i = 0; $i < 3; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "9c642c700580e607dc6114475cae1bdbb21b1057857ec3c5d1e46ac6c107027a";
  }
  const { data } = t0;
  const t1 = data;
  let t2;
  if ($[1] !== t1) {
    t2 = (0, import_jsx_runtime3.jsx)("div", {
      className: "bg-muted/30 p-4 rounded overflow-auto max-h-[400px]",
      children: (0, import_jsx_runtime3.jsx)(JsonView, {
        src: t1,
        theme: "atom",
        collapsed: 2
      })
    });
    $[1] = t1;
    $[2] = t2;
  } else t2 = $[2];
  return t2;
});
DLQJobDataTab.displayName = "DLQJobDataTab";
var DLQPanel = (0, import_react.memo)(() => {
  const $ = (0, import_compiler_runtime.c)(66);
  if ($[0] !== "9c642c700580e607dc6114475cae1bdbb21b1057857ec3c5d1e46ac6c107027a") {
    for (let $i = 0; $i < 66; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "9c642c700580e607dc6114475cae1bdbb21b1057857ec3c5d1e46ac6c107027a";
  }
  const selectedQueue = useBullMQStore(_temp$5);
  const { data: t0, isLoading, refetch } = useDLQJobsQuery(selectedQueue?.isDLQ ? selectedQueue.name : void 0);
  let t1;
  if ($[1] !== t0) {
    t1 = t0 === void 0 ? [] : t0;
    $[1] = t0;
    $[2] = t1;
  } else t1 = $[2];
  const dlqJobs = t1;
  const retryFromDLQMutation = useRetryFromDLQ();
  const retryAllFromDLQMutation = useRetryAllFromDLQ();
  const clearDLQMutation = useClearDLQ();
  const [selectedDlqJob, setSelectedDlqJob] = (0, import_react.useState)(null);
  let t2;
  if ($[3] !== retryFromDLQMutation || $[4] !== selectedQueue) {
    t2 = (jobId) => {
      if (!selectedQueue) return;
      retryFromDLQMutation.mutate({
        queueName: selectedQueue.name,
        jobId
      });
    };
    $[3] = retryFromDLQMutation;
    $[4] = selectedQueue;
    $[5] = t2;
  } else t2 = $[5];
  const handleRetry = t2;
  let t3;
  if ($[6] !== retryAllFromDLQMutation || $[7] !== selectedQueue) {
    t3 = () => {
      if (!selectedQueue) return;
      retryAllFromDLQMutation.mutate({ queueName: selectedQueue.name });
    };
    $[6] = retryAllFromDLQMutation;
    $[7] = selectedQueue;
    $[8] = t3;
  } else t3 = $[8];
  const handleRetryAll = t3;
  let t4;
  if ($[9] !== clearDLQMutation || $[10] !== selectedQueue) {
    t4 = () => {
      if (!selectedQueue) return;
      clearDLQMutation.mutate({ queueName: selectedQueue.name });
    };
    $[9] = clearDLQMutation;
    $[10] = selectedQueue;
    $[11] = t4;
  } else t4 = $[11];
  const handleClear = t4;
  let t5;
  if ($[12] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t5 = () => {
      setSelectedDlqJob(null);
    };
    $[12] = t5;
  } else t5 = $[12];
  const handleCloseSidePanel = t5;
  let t6;
  if ($[13] !== handleRetry || $[14] !== selectedDlqJob) {
    t6 = () => {
      if (selectedDlqJob) {
        handleRetry(selectedDlqJob.id);
        setSelectedDlqJob(null);
      }
    };
    $[13] = handleRetry;
    $[14] = selectedDlqJob;
    $[15] = t6;
  } else t6 = $[15];
  const handleRetryAndClose = t6;
  if (!selectedQueue?.isDLQ) return null;
  let t7;
  if ($[16] !== selectedQueue.displayName) {
    t7 = (0, import_jsx_runtime3.jsx)("h2", {
      className: "font-semibold text-lg",
      children: selectedQueue.displayName
    });
    $[16] = selectedQueue.displayName;
    $[17] = t7;
  } else t7 = $[17];
  const t8 = dlqJobs.length !== 1 ? "s" : "";
  let t9;
  if ($[18] !== dlqJobs.length || $[19] !== t8) {
    t9 = (0, import_jsx_runtime3.jsxs)("p", {
      className: "text-sm text-muted-foreground",
      children: [
        dlqJobs.length,
        " failed job",
        t8,
        " in dead letter queue"
      ]
    });
    $[18] = dlqJobs.length;
    $[19] = t8;
    $[20] = t9;
  } else t9 = $[20];
  let t10;
  if ($[21] !== t7 || $[22] !== t9) {
    t10 = (0, import_jsx_runtime3.jsxs)("div", { children: [t7, t9] });
    $[21] = t7;
    $[22] = t9;
    $[23] = t10;
  } else t10 = $[23];
  let t11;
  if ($[24] !== refetch) {
    t11 = () => refetch();
    $[24] = refetch;
    $[25] = t11;
  } else t11 = $[25];
  const t12 = `h-4 w-4 ${isLoading ? "animate-spin" : ""}`;
  let t13;
  if ($[26] !== t12) {
    t13 = (0, import_jsx_runtime3.jsx)(import_lucide_react.RefreshCw, { className: t12 });
    $[26] = t12;
    $[27] = t13;
  } else t13 = $[27];
  let t14;
  if ($[28] !== isLoading || $[29] !== t11 || $[30] !== t13) {
    t14 = (0, import_jsx_runtime3.jsx)(TooltipTrigger, {
      asChild: true,
      children: (0, import_jsx_runtime3.jsx)(Button, {
        variant: "ghost",
        size: "icon",
        onClick: t11,
        disabled: isLoading,
        children: t13
      })
    });
    $[28] = isLoading;
    $[29] = t11;
    $[30] = t13;
    $[31] = t14;
  } else t14 = $[31];
  let t15;
  if ($[32] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t15 = (0, import_jsx_runtime3.jsx)(TooltipContent, { children: (0, import_jsx_runtime3.jsx)("p", { children: "Refresh DLQ jobs list" }) });
    $[32] = t15;
  } else t15 = $[32];
  let t16;
  if ($[33] !== t14) {
    t16 = (0, import_jsx_runtime3.jsxs)(Tooltip, { children: [t14, t15] });
    $[33] = t14;
    $[34] = t16;
  } else t16 = $[34];
  const t17 = dlqJobs.length === 0;
  let t18;
  if ($[35] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t18 = (0, import_jsx_runtime3.jsx)(import_lucide_react.RefreshCw, { className: "mr-2 h-4 w-4" });
    $[35] = t18;
  } else t18 = $[35];
  let t19;
  if ($[36] !== handleRetryAll || $[37] !== t17) {
    t19 = (0, import_jsx_runtime3.jsx)(TooltipTrigger, {
      asChild: true,
      children: (0, import_jsx_runtime3.jsxs)(Button, {
        variant: "outline",
        size: "sm",
        onClick: handleRetryAll,
        disabled: t17,
        children: [t18, "Retry All"]
      })
    });
    $[36] = handleRetryAll;
    $[37] = t17;
    $[38] = t19;
  } else t19 = $[38];
  let t20;
  if ($[39] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t20 = (0, import_jsx_runtime3.jsx)(TooltipContent, { children: (0, import_jsx_runtime3.jsx)("p", { children: "Re-queue all failed jobs to the original queue" }) });
    $[39] = t20;
  } else t20 = $[39];
  let t21;
  if ($[40] !== t19) {
    t21 = (0, import_jsx_runtime3.jsxs)(Tooltip, { children: [t19, t20] });
    $[40] = t19;
    $[41] = t21;
  } else t21 = $[41];
  const t22 = dlqJobs.length === 0;
  let t23;
  if ($[42] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t23 = (0, import_jsx_runtime3.jsx)(import_lucide_react.Trash, { className: "mr-2 h-4 w-4" });
    $[42] = t23;
  } else t23 = $[42];
  let t24;
  if ($[43] !== handleClear || $[44] !== t22) {
    t24 = (0, import_jsx_runtime3.jsx)(TooltipTrigger, {
      asChild: true,
      children: (0, import_jsx_runtime3.jsxs)(Button, {
        variant: "outline",
        size: "sm",
        onClick: handleClear,
        disabled: t22,
        className: "text-destructive",
        children: [t23, "Clear All"]
      })
    });
    $[43] = handleClear;
    $[44] = t22;
    $[45] = t24;
  } else t24 = $[45];
  let t25;
  if ($[46] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t25 = (0, import_jsx_runtime3.jsx)(TooltipContent, { children: (0, import_jsx_runtime3.jsx)("p", { children: "Permanently delete all jobs from DLQ" }) });
    $[46] = t25;
  } else t25 = $[46];
  let t26;
  if ($[47] !== t24) {
    t26 = (0, import_jsx_runtime3.jsxs)(Tooltip, { children: [t24, t25] });
    $[47] = t24;
    $[48] = t26;
  } else t26 = $[48];
  let t27;
  if ($[49] !== t16 || $[50] !== t21 || $[51] !== t26) {
    t27 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex items-center gap-2",
      children: [
        t16,
        t21,
        t26
      ]
    });
    $[49] = t16;
    $[50] = t21;
    $[51] = t26;
    $[52] = t27;
  } else t27 = $[52];
  let t28;
  if ($[53] !== t10 || $[54] !== t27) {
    t28 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex items-center justify-between p-3 border-b border-border",
      children: [t10, t27]
    });
    $[53] = t10;
    $[54] = t27;
    $[55] = t28;
  } else t28 = $[55];
  let t29;
  if ($[56] !== dlqJobs || $[57] !== handleRetry) {
    t29 = dlqJobs.length === 0 ? (0, import_jsx_runtime3.jsx)("div", {
      className: "flex items-center justify-center flex-1 text-muted-foreground",
      children: "No jobs in dead letter queue"
    }) : (0, import_jsx_runtime3.jsx)("div", {
      className: "flex-1 overflow-auto",
      children: (0, import_jsx_runtime3.jsxs)(Table, { children: [(0, import_jsx_runtime3.jsx)(TableHeader, {
        className: "sticky top-0 bg-background/95 backdrop-blur-sm",
        children: (0, import_jsx_runtime3.jsxs)(TableRow, { children: [
          (0, import_jsx_runtime3.jsx)(TableHead, {
            className: "w-[180px]",
            children: "Job ID"
          }),
          (0, import_jsx_runtime3.jsx)(TableHead, {
            className: "w-[180px]",
            children: "Original Job"
          }),
          (0, import_jsx_runtime3.jsx)(TableHead, { children: "Failure Reason" }),
          (0, import_jsx_runtime3.jsx)(TableHead, {
            className: "w-[100px]",
            children: "Attempts"
          }),
          (0, import_jsx_runtime3.jsx)(TableHead, {
            className: "w-[150px]",
            children: "Failed At"
          }),
          (0, import_jsx_runtime3.jsx)(TableHead, {
            className: "w-[100px]",
            children: "Actions"
          })
        ] })
      }), (0, import_jsx_runtime3.jsx)(TableBody, { children: dlqJobs.map((job) => (0, import_jsx_runtime3.jsxs)(TableRow, {
        className: "cursor-pointer hover:bg-muted-foreground/10",
        onClick: () => setSelectedDlqJob(job),
        children: [
          (0, import_jsx_runtime3.jsx)(TableCell, {
            className: "font-mono text-xs",
            children: job.id
          }),
          (0, import_jsx_runtime3.jsx)(TableCell, {
            className: "font-mono text-xs text-muted-foreground",
            children: job.originalJobId || "-"
          }),
          (0, import_jsx_runtime3.jsx)(TableCell, {
            className: "text-destructive text-sm truncate max-w-[300px]",
            children: job.failureReason
          }),
          (0, import_jsx_runtime3.jsx)(TableCell, { children: job.attemptsMade }),
          (0, import_jsx_runtime3.jsx)(TableCell, {
            className: "text-xs text-muted-foreground",
            children: formatDistanceToNow(job.failureTimestamp, { addSuffix: true })
          }),
          (0, import_jsx_runtime3.jsx)(TableCell, {
            onClick: _temp2$5,
            children: (0, import_jsx_runtime3.jsxs)(Tooltip, { children: [(0, import_jsx_runtime3.jsx)(TooltipTrigger, {
              asChild: true,
              children: (0, import_jsx_runtime3.jsx)(Button, {
                variant: "ghost",
                size: "sm",
                onClick: () => handleRetry(job.id),
                children: (0, import_jsx_runtime3.jsx)(import_lucide_react.RefreshCw, { className: "h-4 w-4" })
              })
            }), (0, import_jsx_runtime3.jsx)(TooltipContent, { children: (0, import_jsx_runtime3.jsx)("p", { children: "Retry this job" }) })] })
          })
        ]
      }, job.id)) })] })
    });
    $[56] = dlqJobs;
    $[57] = handleRetry;
    $[58] = t29;
  } else t29 = $[58];
  let t30;
  if ($[59] !== handleRetryAndClose || $[60] !== selectedDlqJob) {
    t30 = selectedDlqJob && (0, import_jsx_runtime3.jsx)(Sidebar, {
      onClose: handleCloseSidePanel,
      title: "Dead Letter Job",
      initialWidth: 600,
      tabs: [{
        label: "Details",
        content: (0, import_jsx_runtime3.jsx)(DLQJobDetailContent, {
          job: selectedDlqJob,
          onRetry: handleRetryAndClose
        })
      }, {
        label: "Event Data",
        content: (0, import_jsx_runtime3.jsx)(DLQJobDataTab, { data: selectedDlqJob.originalEvent })
      }],
      actions: [{
        icon: (0, import_jsx_runtime3.jsx)(import_lucide_react.X, {}),
        onClick: handleCloseSidePanel,
        label: "Close"
      }]
    });
    $[59] = handleRetryAndClose;
    $[60] = selectedDlqJob;
    $[61] = t30;
  } else t30 = $[61];
  let t31;
  if ($[62] !== t28 || $[63] !== t29 || $[64] !== t30) {
    t31 = (0, import_jsx_runtime3.jsx)(TooltipProvider, { children: (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex flex-col h-full",
      children: [
        t28,
        t29,
        t30
      ]
    }) });
    $[62] = t28;
    $[63] = t29;
    $[64] = t30;
    $[65] = t31;
  } else t31 = $[65];
  return t31;
});
DLQPanel.displayName = "DLQPanel";
function _temp$5(state) {
  return state.selectedQueue;
}
function _temp2$5(e) {
  return e.stopPropagation();
}
var JobDataTab = (0, import_react.memo)((t0) => {
  const $ = (0, import_compiler_runtime.c)(3);
  if ($[0] !== "3b06a00e91af27c8dc4dbe23232bee1ad67432d0e4c5ed3ab9b136e6d2a7a3cd") {
    for (let $i = 0; $i < 3; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "3b06a00e91af27c8dc4dbe23232bee1ad67432d0e4c5ed3ab9b136e6d2a7a3cd";
  }
  const { data } = t0;
  const t1 = data;
  let t2;
  if ($[1] !== t1) {
    t2 = (0, import_jsx_runtime3.jsx)("div", {
      className: "bg-muted/30 p-4 rounded",
      children: (0, import_jsx_runtime3.jsx)(JsonView, {
        src: t1,
        theme: "atom",
        collapsed: 2
      })
    });
    $[1] = t1;
    $[2] = t2;
  } else t2 = $[2];
  return t2;
});
JobDataTab.displayName = "JobDataTab";
var JobOptionsTab = (0, import_react.memo)((t0) => {
  const $ = (0, import_compiler_runtime.c)(3);
  if ($[0] !== "3b06a00e91af27c8dc4dbe23232bee1ad67432d0e4c5ed3ab9b136e6d2a7a3cd") {
    for (let $i = 0; $i < 3; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "3b06a00e91af27c8dc4dbe23232bee1ad67432d0e4c5ed3ab9b136e6d2a7a3cd";
  }
  const { opts } = t0;
  let t1;
  if ($[1] !== opts) {
    t1 = (0, import_jsx_runtime3.jsx)("div", {
      className: "bg-muted/30 p-4 rounded",
      children: (0, import_jsx_runtime3.jsx)(JsonView, {
        src: opts,
        theme: "atom",
        collapsed: 2
      })
    });
    $[1] = opts;
    $[2] = t1;
  } else t1 = $[2];
  return t1;
});
JobOptionsTab.displayName = "JobOptionsTab";
var JobResultTab = (0, import_react.memo)((t0) => {
  const $ = (0, import_compiler_runtime.c)(3);
  if ($[0] !== "3b06a00e91af27c8dc4dbe23232bee1ad67432d0e4c5ed3ab9b136e6d2a7a3cd") {
    for (let $i = 0; $i < 3; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "3b06a00e91af27c8dc4dbe23232bee1ad67432d0e4c5ed3ab9b136e6d2a7a3cd";
  }
  const { returnvalue } = t0;
  const t1 = returnvalue;
  let t2;
  if ($[1] !== t1) {
    t2 = (0, import_jsx_runtime3.jsx)("div", {
      className: "bg-muted/30 p-4 rounded",
      children: (0, import_jsx_runtime3.jsx)(JsonView, {
        src: t1,
        theme: "atom",
        collapsed: 2
      })
    });
    $[1] = t1;
    $[2] = t2;
  } else t2 = $[2];
  return t2;
});
JobResultTab.displayName = "JobResultTab";
var JobErrorTab = (0, import_react.memo)((t0) => {
  const $ = (0, import_compiler_runtime.c)(9);
  if ($[0] !== "3b06a00e91af27c8dc4dbe23232bee1ad67432d0e4c5ed3ab9b136e6d2a7a3cd") {
    for (let $i = 0; $i < 9; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "3b06a00e91af27c8dc4dbe23232bee1ad67432d0e4c5ed3ab9b136e6d2a7a3cd";
  }
  const { failedReason, stacktrace } = t0;
  let t1;
  if ($[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t1 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-sm font-semibold text-destructive mb-1",
      children: "Error Message"
    });
    $[1] = t1;
  } else t1 = $[1];
  let t2;
  if ($[2] !== failedReason) {
    t2 = (0, import_jsx_runtime3.jsxs)("div", { children: [t1, (0, import_jsx_runtime3.jsx)("div", {
      className: "font-mono text-sm bg-destructive/10 p-3 rounded text-destructive",
      children: failedReason
    })] });
    $[2] = failedReason;
    $[3] = t2;
  } else t2 = $[3];
  let t3;
  if ($[4] !== stacktrace) {
    t3 = stacktrace && stacktrace.length > 0 && (0, import_jsx_runtime3.jsxs)("div", { children: [(0, import_jsx_runtime3.jsx)("div", {
      className: "text-sm font-semibold text-muted-foreground mb-1",
      children: "Stack Trace"
    }), (0, import_jsx_runtime3.jsx)("pre", {
      className: "font-mono text-xs bg-muted p-3 rounded overflow-auto max-h-[300px]",
      children: stacktrace.join("\n")
    })] });
    $[4] = stacktrace;
    $[5] = t3;
  } else t3 = $[5];
  let t4;
  if ($[6] !== t2 || $[7] !== t3) {
    t4 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "space-y-4",
      children: [t2, t3]
    });
    $[6] = t2;
    $[7] = t3;
    $[8] = t4;
  } else t4 = $[8];
  return t4;
});
JobErrorTab.displayName = "JobErrorTab";
var JobDetail = (0, import_react.memo)(() => {
  const $ = (0, import_compiler_runtime.c)(92);
  if ($[0] !== "3b06a00e91af27c8dc4dbe23232bee1ad67432d0e4c5ed3ab9b136e6d2a7a3cd") {
    for (let $i = 0; $i < 92; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "3b06a00e91af27c8dc4dbe23232bee1ad67432d0e4c5ed3ab9b136e6d2a7a3cd";
  }
  const selectedJob = useBullMQStore(_temp$4);
  const selectedQueue = useBullMQStore(_temp2$4);
  const jobDetailOpen = useBullMQStore(_temp3$3);
  const setJobDetailOpen = useBullMQStore(_temp4$2);
  const setSelectedJob = useBullMQStore(_temp5$2);
  const retryJobMutation = useRetryJob();
  const removeJobMutation = useRemoveJob();
  const promoteJobMutation = usePromoteJob();
  let t0;
  if ($[1] !== setJobDetailOpen || $[2] !== setSelectedJob) {
    t0 = () => {
      setJobDetailOpen(false);
      setSelectedJob(null);
    };
    $[1] = setJobDetailOpen;
    $[2] = setSelectedJob;
    $[3] = t0;
  } else t0 = $[3];
  const handleClose = t0;
  let t1;
  if ($[4] !== handleClose || $[5] !== retryJobMutation || $[6] !== selectedJob || $[7] !== selectedQueue) {
    t1 = () => {
      if (!selectedQueue || !selectedJob) return;
      retryJobMutation.mutate({
        queueName: selectedQueue.name,
        jobId: selectedJob.id
      });
      handleClose();
    };
    $[4] = handleClose;
    $[5] = retryJobMutation;
    $[6] = selectedJob;
    $[7] = selectedQueue;
    $[8] = t1;
  } else t1 = $[8];
  const handleRetry = t1;
  let t2;
  if ($[9] !== handleClose || $[10] !== removeJobMutation || $[11] !== selectedJob || $[12] !== selectedQueue) {
    t2 = () => {
      if (!selectedQueue || !selectedJob) return;
      removeJobMutation.mutate({
        queueName: selectedQueue.name,
        jobId: selectedJob.id
      });
      handleClose();
    };
    $[9] = handleClose;
    $[10] = removeJobMutation;
    $[11] = selectedJob;
    $[12] = selectedQueue;
    $[13] = t2;
  } else t2 = $[13];
  const handleRemove = t2;
  let t3;
  if ($[14] !== handleClose || $[15] !== promoteJobMutation || $[16] !== selectedJob || $[17] !== selectedQueue) {
    t3 = () => {
      if (!selectedQueue || !selectedJob) return;
      promoteJobMutation.mutate({
        queueName: selectedQueue.name,
        jobId: selectedJob.id
      });
      handleClose();
    };
    $[14] = handleClose;
    $[15] = promoteJobMutation;
    $[16] = selectedJob;
    $[17] = selectedQueue;
    $[18] = t3;
  } else t3 = $[18];
  const handlePromote = t3;
  if (!jobDetailOpen || !selectedJob || !selectedQueue) return null;
  const hasError = !!selectedJob.failedReason;
  const isDelayed = selectedJob.delay && selectedJob.delay > 0;
  const hasReturnValue = selectedJob.returnvalue !== void 0 && selectedJob.returnvalue !== null;
  let t4;
  if ($[19] !== selectedJob.data) {
    t4 = {
      label: "Data",
      content: (0, import_jsx_runtime3.jsx)(JobDataTab, { data: selectedJob.data })
    };
    $[19] = selectedJob.data;
    $[20] = t4;
  } else t4 = $[20];
  let t5;
  if ($[21] !== selectedJob.opts) {
    t5 = {
      label: "Options",
      content: (0, import_jsx_runtime3.jsx)(JobOptionsTab, { opts: selectedJob.opts })
    };
    $[21] = selectedJob.opts;
    $[22] = t5;
  } else t5 = $[22];
  let t6;
  if ($[23] !== hasReturnValue || $[24] !== selectedJob.returnvalue) {
    t6 = hasReturnValue ? [{
      label: "Result",
      content: (0, import_jsx_runtime3.jsx)(JobResultTab, { returnvalue: selectedJob.returnvalue })
    }] : [];
    $[23] = hasReturnValue;
    $[24] = selectedJob.returnvalue;
    $[25] = t6;
  } else t6 = $[25];
  let t7;
  if ($[26] !== hasError || $[27] !== selectedJob.failedReason || $[28] !== selectedJob.stacktrace) {
    t7 = hasError ? [{
      label: "Error",
      content: (0, import_jsx_runtime3.jsx)(JobErrorTab, {
        failedReason: selectedJob.failedReason,
        stacktrace: selectedJob.stacktrace
      })
    }] : [];
    $[26] = hasError;
    $[27] = selectedJob.failedReason;
    $[28] = selectedJob.stacktrace;
    $[29] = t7;
  } else t7 = $[29];
  let t8;
  if ($[30] !== t4 || $[31] !== t5 || $[32] !== t6 || $[33] !== t7) {
    t8 = [
      t4,
      t5,
      ...t6,
      ...t7
    ];
    $[30] = t4;
    $[31] = t5;
    $[32] = t6;
    $[33] = t7;
    $[34] = t8;
  } else t8 = $[34];
  const tabs = t8;
  let t9;
  if ($[35] !== hasError || $[36] !== isDelayed || $[37] !== selectedJob.finishedOn || $[38] !== selectedJob.processedOn) {
    t9 = hasError ? (0, import_jsx_runtime3.jsx)("span", {
      className: "text-destructive",
      children: "Failed"
    }) : selectedJob.finishedOn ? (0, import_jsx_runtime3.jsx)("span", {
      className: "text-green-500",
      children: "Completed"
    }) : selectedJob.processedOn ? (0, import_jsx_runtime3.jsx)("span", {
      className: "text-yellow-500",
      children: "Processing"
    }) : isDelayed ? (0, import_jsx_runtime3.jsx)("span", {
      className: "text-purple-500",
      children: "Delayed"
    }) : (0, import_jsx_runtime3.jsx)("span", {
      className: "text-blue-500",
      children: "Waiting"
    });
    $[35] = hasError;
    $[36] = isDelayed;
    $[37] = selectedJob.finishedOn;
    $[38] = selectedJob.processedOn;
    $[39] = t9;
  } else t9 = $[39];
  const statusElement = t9;
  const t10 = selectedJob.name;
  let t11;
  if ($[40] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t11 = (0, import_jsx_runtime3.jsx)(import_lucide_react.X, {});
    $[40] = t11;
  } else t11 = $[40];
  let t12;
  if ($[41] !== handleClose) {
    t12 = [{
      icon: t11,
      onClick: handleClose,
      label: "Close"
    }];
    $[41] = handleClose;
    $[42] = t12;
  } else t12 = $[42];
  let t13;
  if ($[43] !== handleRetry || $[44] !== hasError) {
    t13 = hasError && (0, import_jsx_runtime3.jsxs)(Button, {
      variant: "outline",
      size: "sm",
      onClick: handleRetry,
      children: [(0, import_jsx_runtime3.jsx)(import_lucide_react.RefreshCw, { className: "mr-2 h-4 w-4" }), "Retry"]
    });
    $[43] = handleRetry;
    $[44] = hasError;
    $[45] = t13;
  } else t13 = $[45];
  let t14;
  if ($[46] !== handlePromote || $[47] !== isDelayed) {
    t14 = isDelayed && (0, import_jsx_runtime3.jsxs)(Button, {
      variant: "outline",
      size: "sm",
      onClick: handlePromote,
      children: [(0, import_jsx_runtime3.jsx)(import_lucide_react.ArrowUpRight, { className: "mr-2 h-4 w-4" }), "Promote"]
    });
    $[46] = handlePromote;
    $[47] = isDelayed;
    $[48] = t14;
  } else t14 = $[48];
  let t15;
  if ($[49] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t15 = (0, import_jsx_runtime3.jsx)(import_lucide_react.Trash, { className: "mr-2 h-4 w-4" });
    $[49] = t15;
  } else t15 = $[49];
  let t16;
  if ($[50] !== handleRemove) {
    t16 = (0, import_jsx_runtime3.jsxs)(Button, {
      variant: "outline",
      size: "sm",
      onClick: handleRemove,
      className: "text-destructive",
      children: [t15, "Remove"]
    });
    $[50] = handleRemove;
    $[51] = t16;
  } else t16 = $[51];
  let t17;
  if ($[52] !== t13 || $[53] !== t14 || $[54] !== t16) {
    t17 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex gap-2",
      children: [
        t13,
        t14,
        t16
      ]
    });
    $[52] = t13;
    $[53] = t14;
    $[54] = t16;
    $[55] = t17;
  } else t17 = $[55];
  let t18;
  if ($[56] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t18 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Job ID"
    });
    $[56] = t18;
  } else t18 = $[56];
  let t19;
  if ($[57] !== selectedJob.id) {
    t19 = (0, import_jsx_runtime3.jsxs)("div", { children: [t18, (0, import_jsx_runtime3.jsx)("div", {
      className: "font-mono text-xs",
      children: selectedJob.id
    })] });
    $[57] = selectedJob.id;
    $[58] = t19;
  } else t19 = $[58];
  let t20;
  if ($[59] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t20 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Status"
    });
    $[59] = t20;
  } else t20 = $[59];
  let t21;
  if ($[60] !== statusElement) {
    t21 = (0, import_jsx_runtime3.jsxs)("div", { children: [t20, (0, import_jsx_runtime3.jsx)("div", {
      className: "font-semibold",
      children: statusElement
    })] });
    $[60] = statusElement;
    $[61] = t21;
  } else t21 = $[61];
  let t22;
  if ($[62] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t22 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Created"
    });
    $[62] = t22;
  } else t22 = $[62];
  let t23;
  if ($[63] !== selectedJob.timestamp) {
    t23 = formatDistanceToNow(selectedJob.timestamp, { addSuffix: true });
    $[63] = selectedJob.timestamp;
    $[64] = t23;
  } else t23 = $[64];
  let t24;
  if ($[65] !== t23) {
    t24 = (0, import_jsx_runtime3.jsxs)("div", { children: [t22, (0, import_jsx_runtime3.jsx)("div", { children: t23 })] });
    $[65] = t23;
    $[66] = t24;
  } else t24 = $[66];
  let t25;
  if ($[67] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t25 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Attempts"
    });
    $[67] = t25;
  } else t25 = $[67];
  let t26;
  if ($[68] !== selectedJob.attemptsMade) {
    t26 = (0, import_jsx_runtime3.jsxs)("div", { children: [t25, (0, import_jsx_runtime3.jsx)("div", {
      className: "font-semibold",
      children: selectedJob.attemptsMade
    })] });
    $[68] = selectedJob.attemptsMade;
    $[69] = t26;
  } else t26 = $[69];
  let t27;
  if ($[70] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t27 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Progress"
    });
    $[70] = t27;
  } else t27 = $[70];
  const t28 = typeof selectedJob.progress === "number" ? `${selectedJob.progress}%` : "-";
  let t29;
  if ($[71] !== t28) {
    t29 = (0, import_jsx_runtime3.jsxs)("div", { children: [t27, (0, import_jsx_runtime3.jsx)("div", {
      className: "font-semibold",
      children: t28
    })] });
    $[71] = t28;
    $[72] = t29;
  } else t29 = $[72];
  let t30;
  if ($[73] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t30 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Delay"
    });
    $[73] = t30;
  } else t30 = $[73];
  const t31 = selectedJob.delay ? `${selectedJob.delay}ms` : "-";
  let t32;
  if ($[74] !== t31) {
    t32 = (0, import_jsx_runtime3.jsxs)("div", { children: [t30, (0, import_jsx_runtime3.jsx)("div", {
      className: "font-semibold",
      children: t31
    })] });
    $[74] = t31;
    $[75] = t32;
  } else t32 = $[75];
  let t33;
  if ($[76] !== t19 || $[77] !== t21 || $[78] !== t24 || $[79] !== t26 || $[80] !== t29 || $[81] !== t32) {
    t33 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "grid grid-cols-2 gap-4 text-sm",
      children: [
        t19,
        t21,
        t24,
        t26,
        t29,
        t32
      ]
    });
    $[76] = t19;
    $[77] = t21;
    $[78] = t24;
    $[79] = t26;
    $[80] = t29;
    $[81] = t32;
    $[82] = t33;
  } else t33 = $[82];
  let t34;
  if ($[83] !== t17 || $[84] !== t33) {
    t34 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "space-y-4",
      children: [t17, t33]
    });
    $[83] = t17;
    $[84] = t33;
    $[85] = t34;
  } else t34 = $[85];
  let t35;
  if ($[86] !== handleClose || $[87] !== selectedJob.name || $[88] !== t12 || $[89] !== t34 || $[90] !== tabs) {
    t35 = (0, import_jsx_runtime3.jsx)(Sidebar, {
      onClose: handleClose,
      title: t10,
      initialWidth: 600,
      tabs,
      actions: t12,
      children: t34
    });
    $[86] = handleClose;
    $[87] = selectedJob.name;
    $[88] = t12;
    $[89] = t34;
    $[90] = tabs;
    $[91] = t35;
  } else t35 = $[91];
  return t35;
});
JobDetail.displayName = "JobDetail";
function _temp$4(state) {
  return state.selectedJob;
}
function _temp2$4(state_0) {
  return state_0.selectedQueue;
}
function _temp3$3(state_1) {
  return state_1.jobDetailOpen;
}
function _temp4$2(state_2) {
  return state_2.setJobDetailOpen;
}
function _temp5$2(state_3) {
  return state_3.setSelectedJob;
}
var JobRow = (0, import_react.memo)((t0) => {
  const $ = (0, import_compiler_runtime.c)(50);
  if ($[0] !== "35e57f18a759ee630724f8001ffcc43b791357fe1eb5c9a6692b76ef0e6628e1") {
    for (let $i = 0; $i < 50; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "35e57f18a759ee630724f8001ffcc43b791357fe1eb5c9a6692b76ef0e6628e1";
  }
  const { job, queueName, onSelect, isSelected } = t0;
  const retryJobMutation = useRetryJob();
  const removeJobMutation = useRemoveJob();
  const promoteJobMutation = usePromoteJob();
  let t1;
  if ($[1] !== job.id || $[2] !== queueName || $[3] !== retryJobMutation) {
    t1 = (e) => {
      e.stopPropagation();
      retryJobMutation.mutate({
        queueName,
        jobId: job.id
      });
    };
    $[1] = job.id;
    $[2] = queueName;
    $[3] = retryJobMutation;
    $[4] = t1;
  } else t1 = $[4];
  const handleRetry = t1;
  let t2;
  if ($[5] !== job.id || $[6] !== queueName || $[7] !== removeJobMutation) {
    t2 = (e_0) => {
      e_0.stopPropagation();
      removeJobMutation.mutate({
        queueName,
        jobId: job.id
      });
    };
    $[5] = job.id;
    $[6] = queueName;
    $[7] = removeJobMutation;
    $[8] = t2;
  } else t2 = $[8];
  const handleRemove = t2;
  let t3;
  if ($[9] !== job.id || $[10] !== promoteJobMutation || $[11] !== queueName) {
    t3 = (e_1) => {
      e_1.stopPropagation();
      promoteJobMutation.mutate({
        queueName,
        jobId: job.id
      });
    };
    $[9] = job.id;
    $[10] = promoteJobMutation;
    $[11] = queueName;
    $[12] = t3;
  } else t3 = $[12];
  const handlePromote = t3;
  const t4 = isSelected ? "bg-muted-foreground/10 hover:bg-muted-foreground/20" : "hover:bg-muted-foreground/10";
  let t5;
  if ($[13] !== t4) {
    t5 = cn("cursor-pointer border-0", t4);
    $[13] = t4;
    $[14] = t5;
  } else t5 = $[14];
  let t6;
  if ($[15] !== job.id) {
    t6 = (0, import_jsx_runtime3.jsx)(TableCell, {
      className: "font-mono text-xs",
      children: job.id
    });
    $[15] = job.id;
    $[16] = t6;
  } else t6 = $[16];
  let t7;
  if ($[17] !== job.name) {
    t7 = (0, import_jsx_runtime3.jsx)(TableCell, {
      className: "font-medium",
      children: job.name
    });
    $[17] = job.name;
    $[18] = t7;
  } else t7 = $[18];
  let t8;
  if ($[19] !== job.timestamp) {
    t8 = formatDistanceToNow(job.timestamp, { addSuffix: true });
    $[19] = job.timestamp;
    $[20] = t8;
  } else t8 = $[20];
  let t9;
  if ($[21] !== t8) {
    t9 = (0, import_jsx_runtime3.jsx)(TableCell, {
      className: "text-xs text-muted-foreground",
      children: t8
    });
    $[21] = t8;
    $[22] = t9;
  } else t9 = $[22];
  let t10;
  if ($[23] !== job.attemptsMade) {
    t10 = (0, import_jsx_runtime3.jsx)(TableCell, { children: (0, import_jsx_runtime3.jsx)("span", {
      className: "text-xs",
      children: job.attemptsMade
    }) });
    $[23] = job.attemptsMade;
    $[24] = t10;
  } else t10 = $[24];
  let t11;
  if ($[25] !== job.progress) {
    t11 = (0, import_jsx_runtime3.jsx)(TableCell, { children: typeof job.progress === "number" ? (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex items-center gap-2",
      children: [(0, import_jsx_runtime3.jsx)("div", {
        className: "w-16 h-1.5 bg-muted rounded-full overflow-hidden",
        children: (0, import_jsx_runtime3.jsx)("div", {
          className: "h-full bg-primary transition-all",
          style: { width: `${Math.min(100, job.progress)}%` }
        })
      }), (0, import_jsx_runtime3.jsxs)("span", {
        className: "text-xs text-muted-foreground",
        children: [job.progress, "%"]
      })]
    }) : (0, import_jsx_runtime3.jsx)("span", {
      className: "text-xs text-muted-foreground",
      children: "-"
    }) });
    $[25] = job.progress;
    $[26] = t11;
  } else t11 = $[26];
  let t12;
  if ($[27] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t12 = (0, import_jsx_runtime3.jsx)(DropdownMenuTrigger, {
      asChild: true,
      children: (0, import_jsx_runtime3.jsx)(Button, {
        variant: "ghost",
        size: "icon",
        className: "h-8 w-8",
        children: (0, import_jsx_runtime3.jsx)(import_lucide_react.MoreVertical, { className: "h-4 w-4" })
      })
    });
    $[27] = t12;
  } else t12 = $[27];
  let t13;
  if ($[28] !== handleRetry || $[29] !== job.failedReason) {
    t13 = job.failedReason && (0, import_jsx_runtime3.jsxs)(DropdownMenuItem, {
      onClick: handleRetry,
      children: [(0, import_jsx_runtime3.jsx)(import_lucide_react.RefreshCw, { className: "mr-2 h-4 w-4" }), "Retry"]
    });
    $[28] = handleRetry;
    $[29] = job.failedReason;
    $[30] = t13;
  } else t13 = $[30];
  let t14;
  if ($[31] !== handlePromote || $[32] !== job.delay) {
    t14 = job.delay && job.delay > 0 && (0, import_jsx_runtime3.jsxs)(DropdownMenuItem, {
      onClick: handlePromote,
      children: [(0, import_jsx_runtime3.jsx)(import_lucide_react.ArrowUpRight, { className: "mr-2 h-4 w-4" }), "Promote"]
    });
    $[31] = handlePromote;
    $[32] = job.delay;
    $[33] = t14;
  } else t14 = $[33];
  let t15;
  if ($[34] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t15 = (0, import_jsx_runtime3.jsx)(import_lucide_react.Trash, { className: "mr-2 h-4 w-4" });
    $[34] = t15;
  } else t15 = $[34];
  let t16;
  if ($[35] !== handleRemove) {
    t16 = (0, import_jsx_runtime3.jsxs)(DropdownMenuItem, {
      onClick: handleRemove,
      className: "text-destructive",
      children: [t15, "Remove"]
    });
    $[35] = handleRemove;
    $[36] = t16;
  } else t16 = $[36];
  let t17;
  if ($[37] !== t13 || $[38] !== t14 || $[39] !== t16) {
    t17 = (0, import_jsx_runtime3.jsx)(TableCell, {
      onClick: _temp$3,
      children: (0, import_jsx_runtime3.jsxs)(DropdownMenu, { children: [t12, (0, import_jsx_runtime3.jsxs)(DropdownMenuContent, {
        align: "end",
        className: "bg-background text-foreground",
        children: [
          t13,
          t14,
          t16
        ]
      })] })
    });
    $[37] = t13;
    $[38] = t14;
    $[39] = t16;
    $[40] = t17;
  } else t17 = $[40];
  let t18;
  if ($[41] !== onSelect || $[42] !== t10 || $[43] !== t11 || $[44] !== t17 || $[45] !== t5 || $[46] !== t6 || $[47] !== t7 || $[48] !== t9) {
    t18 = (0, import_jsx_runtime3.jsxs)(TableRow, {
      onClick: onSelect,
      className: t5,
      children: [
        t6,
        t7,
        t9,
        t10,
        t11,
        t17
      ]
    });
    $[41] = onSelect;
    $[42] = t10;
    $[43] = t11;
    $[44] = t17;
    $[45] = t5;
    $[46] = t6;
    $[47] = t7;
    $[48] = t9;
    $[49] = t18;
  } else t18 = $[49];
  return t18;
});
JobRow.displayName = "JobRow";
var JobsTable = (0, import_react.memo)(() => {
  const $ = (0, import_compiler_runtime.c)(21);
  if ($[0] !== "35e57f18a759ee630724f8001ffcc43b791357fe1eb5c9a6692b76ef0e6628e1") {
    for (let $i = 0; $i < 21; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "35e57f18a759ee630724f8001ffcc43b791357fe1eb5c9a6692b76ef0e6628e1";
  }
  const { data: t0, isLoading } = useJobsQuery();
  let t1;
  if ($[1] !== t0) {
    t1 = t0 === void 0 ? [] : t0;
    $[1] = t0;
    $[2] = t1;
  } else t1 = $[2];
  const jobs = t1;
  const selectedQueue = useBullMQStore(_temp2$3);
  const selectedJob = useBullMQStore(_temp3$2);
  const setSelectedJob = useBullMQStore(_temp4$1);
  const setJobDetailOpen = useBullMQStore(_temp5$1);
  let t2;
  if ($[3] !== setJobDetailOpen || $[4] !== setSelectedJob) {
    t2 = (job) => {
      setSelectedJob(job);
      setJobDetailOpen(true);
    };
    $[3] = setJobDetailOpen;
    $[4] = setSelectedJob;
    $[5] = t2;
  } else t2 = $[5];
  const handleSelectJob = t2;
  if (!selectedQueue) {
    let t3$1;
    if ($[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
      t3$1 = (0, import_jsx_runtime3.jsx)("div", {
        className: "flex items-center justify-center h-full text-muted-foreground",
        children: "Select a queue to view jobs"
      });
      $[6] = t3$1;
    } else t3$1 = $[6];
    return t3$1;
  }
  if (isLoading) {
    let t3$1;
    if ($[7] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
      t3$1 = (0, import_jsx_runtime3.jsx)("div", {
        className: "flex items-center justify-center h-full text-muted-foreground",
        children: "Loading jobs..."
      });
      $[7] = t3$1;
    } else t3$1 = $[7];
    return t3$1;
  }
  if (jobs.length === 0) {
    let t3$1;
    if ($[8] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
      t3$1 = (0, import_jsx_runtime3.jsx)("div", {
        className: "flex items-center justify-center h-full text-muted-foreground",
        children: "No jobs in this status"
      });
      $[8] = t3$1;
    } else t3$1 = $[8];
    return t3$1;
  }
  let t3;
  if ($[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t3 = (0, import_jsx_runtime3.jsx)(TableHeader, {
      className: "sticky top-0 bg-background/95 backdrop-blur-sm",
      children: (0, import_jsx_runtime3.jsxs)(TableRow, { children: [
        (0, import_jsx_runtime3.jsx)(TableHead, {
          className: "w-[200px]",
          children: "Job ID"
        }),
        (0, import_jsx_runtime3.jsx)(TableHead, { children: "Name" }),
        (0, import_jsx_runtime3.jsx)(TableHead, {
          className: "w-[150px]",
          children: "Created"
        }),
        (0, import_jsx_runtime3.jsx)(TableHead, {
          className: "w-[80px]",
          children: "Attempts"
        }),
        (0, import_jsx_runtime3.jsx)(TableHead, {
          className: "w-[140px]",
          children: "Progress"
        }),
        (0, import_jsx_runtime3.jsx)(TableHead, {
          className: "w-[60px]",
          children: "Actions"
        })
      ] })
    });
    $[9] = t3;
  } else t3 = $[9];
  let t4;
  if ($[10] !== handleSelectJob || $[11] !== jobs || $[12] !== selectedJob?.id || $[13] !== selectedQueue) {
    let t5$1;
    if ($[15] !== handleSelectJob || $[16] !== selectedJob?.id || $[17] !== selectedQueue) {
      t5$1 = (job_0) => (0, import_jsx_runtime3.jsx)(JobRow, {
        job: job_0,
        queueName: selectedQueue.name,
        onSelect: () => handleSelectJob(job_0),
        isSelected: selectedJob?.id === job_0.id
      }, job_0.id);
      $[15] = handleSelectJob;
      $[16] = selectedJob?.id;
      $[17] = selectedQueue;
      $[18] = t5$1;
    } else t5$1 = $[18];
    t4 = jobs.map(t5$1);
    $[10] = handleSelectJob;
    $[11] = jobs;
    $[12] = selectedJob?.id;
    $[13] = selectedQueue;
    $[14] = t4;
  } else t4 = $[14];
  let t5;
  if ($[19] !== t4) {
    t5 = (0, import_jsx_runtime3.jsxs)(Table, { children: [t3, (0, import_jsx_runtime3.jsx)(TableBody, { children: t4 })] });
    $[19] = t4;
    $[20] = t5;
  } else t5 = $[20];
  return t5;
});
JobsTable.displayName = "JobsTable";
function _temp$3(e_2) {
  return e_2.stopPropagation();
}
function _temp2$3(state) {
  return state.selectedQueue;
}
function _temp3$2(state_0) {
  return state_0.selectedJob;
}
function _temp4$1(state_1) {
  return state_1.setSelectedJob;
}
function _temp5$1(state_2) {
  return state_2.setJobDetailOpen;
}
var STATUS_TABS = [
  {
    value: "waiting",
    label: "Waiting"
  },
  {
    value: "active",
    label: "Active"
  },
  {
    value: "completed",
    label: "Completed"
  },
  {
    value: "failed",
    label: "Failed"
  },
  {
    value: "delayed",
    label: "Delayed"
  }
];
var QueueDetail = (0, import_react.memo)(() => {
  const $ = (0, import_compiler_runtime.c)(115);
  if ($[0] !== "ec763ba5d94c93fbec6c5d401f02a104160374351538eec66a12a09486a09276") {
    for (let $i = 0; $i < 115; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "ec763ba5d94c93fbec6c5d401f02a104160374351538eec66a12a09486a09276";
  }
  const queryClient$1 = useQueryClient();
  const selectedQueue = useBullMQStore(_temp$2);
  const selectedStatus = useBullMQStore(_temp2$2);
  const setSelectedStatus = useBullMQStore(_temp3$1);
  const { pauseQueue, resumeQueue, cleanQueue, drainQueue } = useQueues();
  let t0;
  if ($[1] !== pauseQueue || $[2] !== selectedQueue) {
    t0 = async () => {
      if (!selectedQueue) return;
      await pauseQueue(selectedQueue.name);
    };
    $[1] = pauseQueue;
    $[2] = selectedQueue;
    $[3] = t0;
  } else t0 = $[3];
  const handlePause = t0;
  let t1;
  if ($[4] !== resumeQueue || $[5] !== selectedQueue) {
    t1 = async () => {
      if (!selectedQueue) return;
      await resumeQueue(selectedQueue.name);
    };
    $[4] = resumeQueue;
    $[5] = selectedQueue;
    $[6] = t1;
  } else t1 = $[6];
  const handleResume = t1;
  let t2;
  if ($[7] !== cleanQueue || $[8] !== selectedQueue) {
    t2 = async () => {
      if (!selectedQueue) return;
      await cleanQueue(selectedQueue.name, "completed", 0, 1e3);
    };
    $[7] = cleanQueue;
    $[8] = selectedQueue;
    $[9] = t2;
  } else t2 = $[9];
  const handleCleanCompleted = t2;
  let t3;
  if ($[10] !== cleanQueue || $[11] !== selectedQueue) {
    t3 = async () => {
      if (!selectedQueue) return;
      await cleanQueue(selectedQueue.name, "failed", 0, 1e3);
    };
    $[10] = cleanQueue;
    $[11] = selectedQueue;
    $[12] = t3;
  } else t3 = $[12];
  const handleCleanFailed = t3;
  let t4;
  if ($[13] !== drainQueue || $[14] !== selectedQueue) {
    t4 = async () => {
      if (!selectedQueue) return;
      await drainQueue(selectedQueue.name);
    };
    $[13] = drainQueue;
    $[14] = selectedQueue;
    $[15] = t4;
  } else t4 = $[15];
  const handleDrain = t4;
  let t5;
  if ($[16] !== queryClient$1 || $[17] !== selectedQueue) {
    t5 = () => {
      if (!selectedQueue) return;
      queryClient$1.invalidateQueries({ queryKey: ["jobs", selectedQueue.name] });
    };
    $[16] = queryClient$1;
    $[17] = selectedQueue;
    $[18] = t5;
  } else t5 = $[18];
  const handleRefresh = t5;
  if (!selectedQueue) {
    let t6$1;
    if ($[19] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
      t6$1 = (0, import_jsx_runtime3.jsx)("div", {
        className: "flex items-center justify-center h-full text-muted-foreground",
        children: "Select a queue from the list to view details"
      });
      $[19] = t6$1;
    } else t6$1 = $[19];
    return t6$1;
  }
  let t6;
  if ($[20] !== selectedQueue.displayName) {
    t6 = (0, import_jsx_runtime3.jsx)("h2", {
      className: "font-semibold text-lg",
      children: selectedQueue.displayName
    });
    $[20] = selectedQueue.displayName;
    $[21] = t6;
  } else t6 = $[21];
  let t7;
  if ($[22] !== selectedQueue.isPaused) {
    t7 = selectedQueue.isPaused && (0, import_jsx_runtime3.jsx)("span", {
      className: "px-2 py-0.5 text-xs rounded bg-yellow-500/20 text-yellow-600",
      children: "Paused"
    });
    $[22] = selectedQueue.isPaused;
    $[23] = t7;
  } else t7 = $[23];
  let t8;
  if ($[24] !== t6 || $[25] !== t7) {
    t8 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex items-center gap-3",
      children: [t6, t7]
    });
    $[24] = t6;
    $[25] = t7;
    $[26] = t8;
  } else t8 = $[26];
  let t9;
  if ($[27] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t9 = (0, import_jsx_runtime3.jsx)(import_lucide_react.RefreshCw, { className: "h-4 w-4" });
    $[27] = t9;
  } else t9 = $[27];
  let t10;
  if ($[28] !== handleRefresh) {
    t10 = (0, import_jsx_runtime3.jsx)(TooltipTrigger, {
      asChild: true,
      children: (0, import_jsx_runtime3.jsx)(Button, {
        variant: "ghost",
        size: "icon",
        onClick: handleRefresh,
        children: t9
      })
    });
    $[28] = handleRefresh;
    $[29] = t10;
  } else t10 = $[29];
  let t11;
  if ($[30] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t11 = (0, import_jsx_runtime3.jsx)(TooltipContent, { children: (0, import_jsx_runtime3.jsx)("p", { children: "Refresh queue stats and jobs list" }) });
    $[30] = t11;
  } else t11 = $[30];
  let t12;
  if ($[31] !== t10) {
    t12 = (0, import_jsx_runtime3.jsxs)(Tooltip, { children: [t10, t11] });
    $[31] = t10;
    $[32] = t12;
  } else t12 = $[32];
  let t13;
  if ($[33] !== handlePause || $[34] !== handleResume || $[35] !== selectedQueue.isPaused) {
    t13 = selectedQueue.isPaused ? (0, import_jsx_runtime3.jsxs)(Tooltip, { children: [(0, import_jsx_runtime3.jsx)(TooltipTrigger, {
      asChild: true,
      children: (0, import_jsx_runtime3.jsxs)(Button, {
        variant: "ghost",
        size: "sm",
        onClick: handleResume,
        children: [(0, import_jsx_runtime3.jsx)(import_lucide_react.Play, { className: "mr-2 h-4 w-4" }), "Resume"]
      })
    }), (0, import_jsx_runtime3.jsx)(TooltipContent, { children: (0, import_jsx_runtime3.jsx)("p", { children: "Resume processing jobs in this queue" }) })] }) : (0, import_jsx_runtime3.jsxs)(Tooltip, { children: [(0, import_jsx_runtime3.jsx)(TooltipTrigger, {
      asChild: true,
      children: (0, import_jsx_runtime3.jsxs)(Button, {
        variant: "ghost",
        size: "sm",
        onClick: handlePause,
        children: [(0, import_jsx_runtime3.jsx)(import_lucide_react.Pause, { className: "mr-2 h-4 w-4" }), "Pause"]
      })
    }), (0, import_jsx_runtime3.jsx)(TooltipContent, { children: (0, import_jsx_runtime3.jsx)("p", { children: "Stop workers from picking up new jobs" }) })] });
    $[33] = handlePause;
    $[34] = handleResume;
    $[35] = selectedQueue.isPaused;
    $[36] = t13;
  } else t13 = $[36];
  let t14;
  if ($[37] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t14 = (0, import_jsx_runtime3.jsx)(DropdownMenuTrigger, {
      asChild: true,
      children: (0, import_jsx_runtime3.jsx)(Button, {
        variant: "ghost",
        size: "icon",
        children: (0, import_jsx_runtime3.jsx)(import_lucide_react.MoreVertical, { className: "h-4 w-4" })
      })
    });
    $[37] = t14;
  } else t14 = $[37];
  let t15;
  if ($[38] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t15 = (0, import_jsx_runtime3.jsx)(import_lucide_react.Trash, { className: "mr-2 h-4 w-4" });
    $[38] = t15;
  } else t15 = $[38];
  let t16;
  if ($[39] !== handleCleanCompleted) {
    t16 = (0, import_jsx_runtime3.jsxs)(DropdownMenuItem, {
      onClick: handleCleanCompleted,
      children: [t15, "Clean Completed"]
    });
    $[39] = handleCleanCompleted;
    $[40] = t16;
  } else t16 = $[40];
  let t17;
  if ($[41] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t17 = (0, import_jsx_runtime3.jsx)(import_lucide_react.Trash, { className: "mr-2 h-4 w-4" });
    $[41] = t17;
  } else t17 = $[41];
  let t18;
  if ($[42] !== handleCleanFailed) {
    t18 = (0, import_jsx_runtime3.jsxs)(DropdownMenuItem, {
      onClick: handleCleanFailed,
      children: [t17, "Clean Failed"]
    });
    $[42] = handleCleanFailed;
    $[43] = t18;
  } else t18 = $[43];
  let t19;
  if ($[44] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t19 = (0, import_jsx_runtime3.jsx)(DropdownMenuSeparator, {});
    $[44] = t19;
  } else t19 = $[44];
  let t20;
  if ($[45] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t20 = (0, import_jsx_runtime3.jsx)(import_lucide_react.Trash, { className: "mr-2 h-4 w-4" });
    $[45] = t20;
  } else t20 = $[45];
  let t21;
  if ($[46] !== handleDrain) {
    t21 = (0, import_jsx_runtime3.jsxs)(DropdownMenuItem, {
      onClick: handleDrain,
      className: "text-destructive",
      children: [t20, "Drain Queue"]
    });
    $[46] = handleDrain;
    $[47] = t21;
  } else t21 = $[47];
  let t22;
  if ($[48] !== t16 || $[49] !== t18 || $[50] !== t21) {
    t22 = (0, import_jsx_runtime3.jsx)(TooltipTrigger, {
      asChild: true,
      children: (0, import_jsx_runtime3.jsxs)(DropdownMenu, { children: [t14, (0, import_jsx_runtime3.jsxs)(DropdownMenuContent, {
        align: "end",
        className: "bg-background text-foreground",
        children: [
          t16,
          t18,
          t19,
          t21
        ]
      })] })
    });
    $[48] = t16;
    $[49] = t18;
    $[50] = t21;
    $[51] = t22;
  } else t22 = $[51];
  let t23;
  if ($[52] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t23 = (0, import_jsx_runtime3.jsx)(TooltipContent, { children: (0, import_jsx_runtime3.jsx)("p", { children: "More actions" }) });
    $[52] = t23;
  } else t23 = $[52];
  let t24;
  if ($[53] !== t22) {
    t24 = (0, import_jsx_runtime3.jsxs)(Tooltip, { children: [t22, t23] });
    $[53] = t22;
    $[54] = t24;
  } else t24 = $[54];
  let t25;
  if ($[55] !== t12 || $[56] !== t13 || $[57] !== t24) {
    t25 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex items-center gap-2",
      children: [
        t12,
        t13,
        t24
      ]
    });
    $[55] = t12;
    $[56] = t13;
    $[57] = t24;
    $[58] = t25;
  } else t25 = $[58];
  let t26;
  if ($[59] !== t25 || $[60] !== t8) {
    t26 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex items-center justify-between p-3 border-b border-border",
      children: [t8, t25]
    });
    $[59] = t25;
    $[60] = t8;
    $[61] = t26;
  } else t26 = $[61];
  let t27;
  if ($[62] !== selectedQueue.stats.waiting) {
    t27 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-2xl font-bold text-blue-500",
      children: selectedQueue.stats.waiting
    });
    $[62] = selectedQueue.stats.waiting;
    $[63] = t27;
  } else t27 = $[63];
  let t28;
  if ($[64] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t28 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-xs text-muted-foreground",
      children: "Waiting"
    });
    $[64] = t28;
  } else t28 = $[64];
  let t29;
  if ($[65] !== t27) {
    t29 = (0, import_jsx_runtime3.jsxs)("div", { children: [t27, t28] });
    $[65] = t27;
    $[66] = t29;
  } else t29 = $[66];
  let t30;
  if ($[67] !== selectedQueue.stats.active) {
    t30 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-2xl font-bold text-yellow-500",
      children: selectedQueue.stats.active
    });
    $[67] = selectedQueue.stats.active;
    $[68] = t30;
  } else t30 = $[68];
  let t31;
  if ($[69] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t31 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-xs text-muted-foreground",
      children: "Active"
    });
    $[69] = t31;
  } else t31 = $[69];
  let t32;
  if ($[70] !== t30) {
    t32 = (0, import_jsx_runtime3.jsxs)("div", { children: [t30, t31] });
    $[70] = t30;
    $[71] = t32;
  } else t32 = $[71];
  let t33;
  if ($[72] !== selectedQueue.stats.completed) {
    t33 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-2xl font-bold text-green-500",
      children: selectedQueue.stats.completed
    });
    $[72] = selectedQueue.stats.completed;
    $[73] = t33;
  } else t33 = $[73];
  let t34;
  if ($[74] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t34 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-xs text-muted-foreground",
      children: "Completed"
    });
    $[74] = t34;
  } else t34 = $[74];
  let t35;
  if ($[75] !== t33) {
    t35 = (0, import_jsx_runtime3.jsxs)("div", { children: [t33, t34] });
    $[75] = t33;
    $[76] = t35;
  } else t35 = $[76];
  let t36;
  if ($[77] !== selectedQueue.stats.failed) {
    t36 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-2xl font-bold text-destructive",
      children: selectedQueue.stats.failed
    });
    $[77] = selectedQueue.stats.failed;
    $[78] = t36;
  } else t36 = $[78];
  let t37;
  if ($[79] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t37 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-xs text-muted-foreground",
      children: "Failed"
    });
    $[79] = t37;
  } else t37 = $[79];
  let t38;
  if ($[80] !== t36) {
    t38 = (0, import_jsx_runtime3.jsxs)("div", { children: [t36, t37] });
    $[80] = t36;
    $[81] = t38;
  } else t38 = $[81];
  let t39;
  if ($[82] !== selectedQueue.stats.delayed) {
    t39 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-2xl font-bold text-purple-500",
      children: selectedQueue.stats.delayed
    });
    $[82] = selectedQueue.stats.delayed;
    $[83] = t39;
  } else t39 = $[83];
  let t40;
  if ($[84] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t40 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-xs text-muted-foreground",
      children: "Delayed"
    });
    $[84] = t40;
  } else t40 = $[84];
  let t41;
  if ($[85] !== t39) {
    t41 = (0, import_jsx_runtime3.jsxs)("div", { children: [t39, t40] });
    $[85] = t39;
    $[86] = t41;
  } else t41 = $[86];
  let t42;
  if ($[87] !== selectedQueue.stats.paused) {
    t42 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-2xl font-bold text-muted-foreground",
      children: selectedQueue.stats.paused
    });
    $[87] = selectedQueue.stats.paused;
    $[88] = t42;
  } else t42 = $[88];
  let t43;
  if ($[89] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t43 = (0, import_jsx_runtime3.jsx)("div", {
      className: "text-xs text-muted-foreground",
      children: "Paused"
    });
    $[89] = t43;
  } else t43 = $[89];
  let t44;
  if ($[90] !== t42) {
    t44 = (0, import_jsx_runtime3.jsxs)("div", { children: [t42, t43] });
    $[90] = t42;
    $[91] = t44;
  } else t44 = $[91];
  let t45;
  if ($[92] !== t29 || $[93] !== t32 || $[94] !== t35 || $[95] !== t38 || $[96] !== t41 || $[97] !== t44) {
    t45 = (0, import_jsx_runtime3.jsx)("div", {
      className: "p-3 border-b border-border",
      children: (0, import_jsx_runtime3.jsxs)("div", {
        className: "grid grid-cols-6 gap-4 text-center",
        children: [
          t29,
          t32,
          t35,
          t38,
          t41,
          t44
        ]
      })
    });
    $[92] = t29;
    $[93] = t32;
    $[94] = t35;
    $[95] = t38;
    $[96] = t41;
    $[97] = t44;
    $[98] = t45;
  } else t45 = $[98];
  let t46;
  if ($[99] !== setSelectedStatus) {
    t46 = (v) => setSelectedStatus(v);
    $[99] = setSelectedStatus;
    $[100] = t46;
  } else t46 = $[100];
  let t47;
  if ($[101] !== selectedQueue.stats || $[102] !== selectedStatus) {
    t47 = STATUS_TABS.map((tab) => (0, import_jsx_runtime3.jsxs)(TabsTrigger, {
      value: tab.value,
      className: cn("relative", selectedStatus === tab.value && "after:absolute after:bottom-0 after:left-0 after:right-0 after:h-0.5 after:bg-primary"),
      children: [tab.label, selectedQueue.stats[tab.value] > 0 && (0, import_jsx_runtime3.jsx)("span", {
        className: "ml-1.5 px-1.5 py-0.5 text-[10px] rounded-full bg-muted",
        children: selectedQueue.stats[tab.value]
      })]
    }, tab.value));
    $[101] = selectedQueue.stats;
    $[102] = selectedStatus;
    $[103] = t47;
  } else t47 = $[103];
  let t48;
  if ($[104] !== t47) {
    t48 = (0, import_jsx_runtime3.jsx)("div", {
      className: "px-3 pt-2 border-b border-border",
      children: (0, import_jsx_runtime3.jsx)(TabsList, { children: t47 })
    });
    $[104] = t47;
    $[105] = t48;
  } else t48 = $[105];
  let t49;
  if ($[106] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t49 = (0, import_jsx_runtime3.jsx)("div", {
      className: "flex-1 overflow-auto",
      children: (0, import_jsx_runtime3.jsx)(JobsTable, {})
    });
    $[106] = t49;
  } else t49 = $[106];
  let t50;
  if ($[107] !== selectedStatus || $[108] !== t46 || $[109] !== t48) {
    t50 = (0, import_jsx_runtime3.jsxs)(Tabs, {
      value: selectedStatus,
      onValueChange: t46,
      className: "flex-1 flex flex-col",
      children: [t48, t49]
    });
    $[107] = selectedStatus;
    $[108] = t46;
    $[109] = t48;
    $[110] = t50;
  } else t50 = $[110];
  let t51;
  if ($[111] !== t26 || $[112] !== t45 || $[113] !== t50) {
    t51 = (0, import_jsx_runtime3.jsx)(TooltipProvider, { children: (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex flex-col h-full",
      children: [
        t26,
        t45,
        t50
      ]
    }) });
    $[111] = t26;
    $[112] = t45;
    $[113] = t50;
    $[114] = t51;
  } else t51 = $[114];
  return t51;
});
QueueDetail.displayName = "QueueDetail";
function _temp$2(state) {
  return state.selectedQueue;
}
function _temp2$2(state_0) {
  return state_0.selectedStatus;
}
function _temp3$1(state_1) {
  return state_1.setSelectedStatus;
}
var QueueItem = (0, import_react.memo)((t0) => {
  const $ = (0, import_compiler_runtime.c)(54);
  if ($[0] !== "44e6229799ef8371f1e191c6f3e3ef70ea83c9489840337cf1d87e846b1bcc7c") {
    for (let $i = 0; $i < 54; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "44e6229799ef8371f1e191c6f3e3ef70ea83c9489840337cf1d87e846b1bcc7c";
  }
  const { queue, isSelected, onClick } = t0;
  const totalJobs = queue.stats.waiting + queue.stats.active + queue.stats.delayed + queue.stats.prioritized;
  const hasFailedJobs = queue.stats.failed > 0;
  const t1 = isSelected ? "bg-muted-foreground/10" : "hover:bg-muted/70";
  let t2;
  if ($[1] !== t1) {
    t2 = cn("w-full text-left p-3 transition-colors border-b border-border", t1);
    $[1] = t1;
    $[2] = t2;
  } else t2 = $[2];
  let t3;
  if ($[3] !== queue.isDLQ) {
    t3 = queue.isDLQ ? (0, import_jsx_runtime3.jsx)(import_lucide_react.Skull, { className: "w-4 h-4 text-destructive" }) : (0, import_jsx_runtime3.jsx)(import_lucide_react.Layers, { className: "w-4 h-4 text-muted-foreground" });
    $[3] = queue.isDLQ;
    $[4] = t3;
  } else t3 = $[4];
  let t4;
  if ($[5] !== queue.displayName) {
    t4 = (0, import_jsx_runtime3.jsx)("span", {
      className: "font-semibold text-sm truncate flex-1",
      children: queue.displayName
    });
    $[5] = queue.displayName;
    $[6] = t4;
  } else t4 = $[6];
  let t5;
  if ($[7] !== queue.isPaused) {
    t5 = queue.isPaused && (0, import_jsx_runtime3.jsx)(import_lucide_react.Pause, { className: "w-3 h-3 text-yellow-500" });
    $[7] = queue.isPaused;
    $[8] = t5;
  } else t5 = $[8];
  let t6;
  if ($[9] !== hasFailedJobs) {
    t6 = hasFailedJobs && (0, import_jsx_runtime3.jsx)(import_lucide_react.AlertTriangle, { className: "w-3 h-3 text-destructive" });
    $[9] = hasFailedJobs;
    $[10] = t6;
  } else t6 = $[10];
  let t7;
  if ($[11] !== t3 || $[12] !== t4 || $[13] !== t5 || $[14] !== t6) {
    t7 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex items-center gap-2 mb-1",
      children: [
        t3,
        t4,
        t5,
        t6
      ]
    });
    $[11] = t3;
    $[12] = t4;
    $[13] = t5;
    $[14] = t6;
    $[15] = t7;
  } else t7 = $[15];
  let t8;
  if ($[16] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t8 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Wait"
    });
    $[16] = t8;
  } else t8 = $[16];
  const t9 = queue.stats.waiting > 0 && "text-blue-500";
  let t10;
  if ($[17] !== t9) {
    t10 = cn("font-mono", t9);
    $[17] = t9;
    $[18] = t10;
  } else t10 = $[18];
  let t11;
  if ($[19] !== queue.stats.waiting || $[20] !== t10) {
    t11 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex flex-col",
      children: [t8, (0, import_jsx_runtime3.jsx)("span", {
        className: t10,
        children: queue.stats.waiting
      })]
    });
    $[19] = queue.stats.waiting;
    $[20] = t10;
    $[21] = t11;
  } else t11 = $[21];
  let t12;
  if ($[22] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t12 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Active"
    });
    $[22] = t12;
  } else t12 = $[22];
  const t13 = queue.stats.active > 0 && "text-yellow-500";
  let t14;
  if ($[23] !== t13) {
    t14 = cn("font-mono", t13);
    $[23] = t13;
    $[24] = t14;
  } else t14 = $[24];
  let t15;
  if ($[25] !== queue.stats.active || $[26] !== t14) {
    t15 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex flex-col",
      children: [t12, (0, import_jsx_runtime3.jsx)("span", {
        className: t14,
        children: queue.stats.active
      })]
    });
    $[25] = queue.stats.active;
    $[26] = t14;
    $[27] = t15;
  } else t15 = $[27];
  let t16;
  if ($[28] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t16 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Done"
    });
    $[28] = t16;
  } else t16 = $[28];
  const t17 = queue.stats.completed > 0 && "text-green-500";
  let t18;
  if ($[29] !== t17) {
    t18 = cn("font-mono", t17);
    $[29] = t17;
    $[30] = t18;
  } else t18 = $[30];
  let t19;
  if ($[31] !== queue.stats.completed || $[32] !== t18) {
    t19 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex flex-col",
      children: [t16, (0, import_jsx_runtime3.jsx)("span", {
        className: t18,
        children: queue.stats.completed
      })]
    });
    $[31] = queue.stats.completed;
    $[32] = t18;
    $[33] = t19;
  } else t19 = $[33];
  let t20;
  if ($[34] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t20 = (0, import_jsx_runtime3.jsx)("span", {
      className: "text-muted-foreground",
      children: "Failed"
    });
    $[34] = t20;
  } else t20 = $[34];
  const t21 = queue.stats.failed > 0 && "text-destructive";
  let t22;
  if ($[35] !== t21) {
    t22 = cn("font-mono", t21);
    $[35] = t21;
    $[36] = t22;
  } else t22 = $[36];
  let t23;
  if ($[37] !== queue.stats.failed || $[38] !== t22) {
    t23 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex flex-col",
      children: [t20, (0, import_jsx_runtime3.jsx)("span", {
        className: t22,
        children: queue.stats.failed
      })]
    });
    $[37] = queue.stats.failed;
    $[38] = t22;
    $[39] = t23;
  } else t23 = $[39];
  let t24;
  if ($[40] !== t11 || $[41] !== t15 || $[42] !== t19 || $[43] !== t23) {
    t24 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "grid grid-cols-4 gap-1 text-xs",
      children: [
        t11,
        t15,
        t19,
        t23
      ]
    });
    $[40] = t11;
    $[41] = t15;
    $[42] = t19;
    $[43] = t23;
    $[44] = t24;
  } else t24 = $[44];
  let t25;
  if ($[45] !== queue.stats.delayed || $[46] !== totalJobs) {
    t25 = (queue.stats.delayed > 0 || totalJobs > 0) && (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex gap-2 mt-1 text-xs text-muted-foreground",
      children: [queue.stats.delayed > 0 && (0, import_jsx_runtime3.jsxs)("span", { children: [queue.stats.delayed, " delayed"] }), totalJobs > 0 && (0, import_jsx_runtime3.jsxs)("span", {
        className: "ml-auto",
        children: [totalJobs, " pending"]
      })]
    });
    $[45] = queue.stats.delayed;
    $[46] = totalJobs;
    $[47] = t25;
  } else t25 = $[47];
  let t26;
  if ($[48] !== onClick || $[49] !== t2 || $[50] !== t24 || $[51] !== t25 || $[52] !== t7) {
    t26 = (0, import_jsx_runtime3.jsxs)("button", {
      type: "button",
      onClick,
      className: t2,
      children: [
        t7,
        t24,
        t25
      ]
    });
    $[48] = onClick;
    $[49] = t2;
    $[50] = t24;
    $[51] = t25;
    $[52] = t7;
    $[53] = t26;
  } else t26 = $[53];
  return t26;
});
QueueItem.displayName = "QueueItem";
var QueueList = (0, import_react.memo)(() => {
  const $ = (0, import_compiler_runtime.c)(38);
  if ($[0] !== "44e6229799ef8371f1e191c6f3e3ef70ea83c9489840337cf1d87e846b1bcc7c") {
    for (let $i = 0; $i < 38; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "44e6229799ef8371f1e191c6f3e3ef70ea83c9489840337cf1d87e846b1bcc7c";
  }
  const queues = useBullMQStore(_temp$1);
  const selectedQueue = useBullMQStore(_temp2$1);
  const setSelectedQueue = useBullMQStore(_temp3);
  const searchQuery = useBullMQStore(_temp4);
  const setSearchQuery = useBullMQStore(_temp5);
  let t0;
  bb0: {
    if (!searchQuery) {
      t0 = queues;
      break bb0;
    }
    let t1$1;
    if ($[1] !== queues || $[2] !== searchQuery) {
      const query = searchQuery.toLowerCase();
      t1$1 = queues.filter((q) => q.name.toLowerCase().includes(query) || q.displayName.toLowerCase().includes(query));
      $[1] = queues;
      $[2] = searchQuery;
      $[3] = t1$1;
    } else t1$1 = $[3];
    t0 = t1$1;
  }
  const filteredQueues = t0;
  let t1;
  if ($[4] !== filteredQueues) {
    t1 = filteredQueues.filter(_temp6);
    $[4] = filteredQueues;
    $[5] = t1;
  } else t1 = $[5];
  const regularQueues = t1;
  let t2;
  if ($[6] !== filteredQueues) {
    t2 = filteredQueues.filter(_temp7);
    $[6] = filteredQueues;
    $[7] = t2;
  } else t2 = $[7];
  const dlqQueues = t2;
  let t3;
  if ($[8] !== setSearchQuery) {
    t3 = (e) => setSearchQuery(e.target.value);
    $[8] = setSearchQuery;
    $[9] = t3;
  } else t3 = $[9];
  let t4;
  if ($[10] !== searchQuery || $[11] !== t3) {
    t4 = (0, import_jsx_runtime3.jsx)(Input, {
      variant: "shade",
      value: searchQuery,
      onChange: t3,
      className: "px-9! font-medium text-sm",
      placeholder: "Search queues..."
    });
    $[10] = searchQuery;
    $[11] = t3;
    $[12] = t4;
  } else t4 = $[12];
  let t5;
  if ($[13] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t5 = (0, import_jsx_runtime3.jsx)(import_lucide_react.Search, { className: "absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground/50" });
    $[13] = t5;
  } else t5 = $[13];
  let t6;
  if ($[14] !== searchQuery || $[15] !== setSearchQuery) {
    t6 = searchQuery && (0, import_jsx_runtime3.jsx)(import_lucide_react.X, {
      className: "cursor-pointer absolute right-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground/50 hover:text-muted-foreground",
      onClick: () => setSearchQuery("")
    });
    $[14] = searchQuery;
    $[15] = setSearchQuery;
    $[16] = t6;
  } else t6 = $[16];
  let t7;
  if ($[17] !== t4 || $[18] !== t6) {
    t7 = (0, import_jsx_runtime3.jsx)("div", {
      className: "p-2 border-b border-border",
      children: (0, import_jsx_runtime3.jsxs)("div", {
        className: "relative",
        children: [
          t4,
          t5,
          t6
        ]
      })
    });
    $[17] = t4;
    $[18] = t6;
    $[19] = t7;
  } else t7 = $[19];
  let t8;
  if ($[20] !== regularQueues || $[21] !== selectedQueue?.name || $[22] !== setSelectedQueue) {
    t8 = regularQueues.length > 0 && (0, import_jsx_runtime3.jsxs)("div", { children: [(0, import_jsx_runtime3.jsxs)("div", {
      className: "px-3 py-2 text-xs font-semibold text-muted-foreground uppercase tracking-wider bg-muted/30",
      children: [
        "Queues (",
        regularQueues.length,
        ")"
      ]
    }), regularQueues.map((queue) => (0, import_jsx_runtime3.jsx)(QueueItem, {
      queue,
      isSelected: selectedQueue?.name === queue.name,
      onClick: () => setSelectedQueue(queue)
    }, queue.name))] });
    $[20] = regularQueues;
    $[21] = selectedQueue?.name;
    $[22] = setSelectedQueue;
    $[23] = t8;
  } else t8 = $[23];
  let t9;
  if ($[24] !== dlqQueues || $[25] !== selectedQueue?.name || $[26] !== setSelectedQueue) {
    t9 = dlqQueues.length > 0 && (0, import_jsx_runtime3.jsxs)("div", { children: [(0, import_jsx_runtime3.jsxs)("div", {
      className: "px-3 py-2 text-xs font-semibold text-muted-foreground uppercase tracking-wider bg-destructive/10",
      children: [
        "Dead Letter Queues (",
        dlqQueues.length,
        ")"
      ]
    }), dlqQueues.map((queue_0) => (0, import_jsx_runtime3.jsx)(QueueItem, {
      queue: queue_0,
      isSelected: selectedQueue?.name === queue_0.name,
      onClick: () => setSelectedQueue(queue_0)
    }, queue_0.name))] });
    $[24] = dlqQueues;
    $[25] = selectedQueue?.name;
    $[26] = setSelectedQueue;
    $[27] = t9;
  } else t9 = $[27];
  let t10;
  if ($[28] !== filteredQueues.length || $[29] !== searchQuery) {
    t10 = filteredQueues.length === 0 && (0, import_jsx_runtime3.jsx)("div", {
      className: "p-4 text-center text-muted-foreground text-sm",
      children: searchQuery ? "No queues match your search" : "No queues found"
    });
    $[28] = filteredQueues.length;
    $[29] = searchQuery;
    $[30] = t10;
  } else t10 = $[30];
  let t11;
  if ($[31] !== t10 || $[32] !== t8 || $[33] !== t9) {
    t11 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex-1 overflow-auto",
      children: [
        t8,
        t9,
        t10
      ]
    });
    $[31] = t10;
    $[32] = t8;
    $[33] = t9;
    $[34] = t11;
  } else t11 = $[34];
  let t12;
  if ($[35] !== t11 || $[36] !== t7) {
    t12 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "flex flex-col h-full",
      children: [t7, t11]
    });
    $[35] = t11;
    $[36] = t7;
    $[37] = t12;
  } else t12 = $[37];
  return t12;
});
QueueList.displayName = "QueueList";
function _temp$1(state) {
  return state.queues;
}
function _temp2$1(state_0) {
  return state_0.selectedQueue;
}
function _temp3(state_1) {
  return state_1.setSelectedQueue;
}
function _temp4(state_2) {
  return state_2.searchQuery;
}
function _temp5(state_3) {
  return state_3.setSearchQuery;
}
function _temp6(q_0) {
  return !q_0.isDLQ;
}
function _temp7(q_1) {
  return q_1.isDLQ;
}
var QueuesPageContent = (0, import_react.memo)(() => {
  const $ = (0, import_compiler_runtime.c)(12);
  if ($[0] !== "d90f8688a2f661493c4a0312f1c954fe541dc3821309a6ba650a56e59fcac492") {
    for (let $i = 0; $i < 12; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "d90f8688a2f661493c4a0312f1c954fe541dc3821309a6ba650a56e59fcac492";
  }
  const selectedQueue = useBullMQStore(_temp);
  const updateSelectedQueueStats = useBullMQStore(_temp2);
  const { queues } = useQueues();
  let t0;
  let t1;
  if ($[1] !== queues || $[2] !== selectedQueue || $[3] !== updateSelectedQueueStats) {
    t0 = () => {
      if (selectedQueue) {
        const updatedQueue = queues.find((q) => q.name === selectedQueue.name);
        if (updatedQueue) updateSelectedQueueStats(updatedQueue);
      }
    };
    t1 = [
      queues,
      selectedQueue,
      updateSelectedQueueStats
    ];
    $[1] = queues;
    $[2] = selectedQueue;
    $[3] = updateSelectedQueueStats;
    $[4] = t0;
    $[5] = t1;
  } else {
    t0 = $[4];
    t1 = $[5];
  }
  (0, import_react.useEffect)(t0, t1);
  let t2;
  if ($[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t2 = (0, import_jsx_runtime3.jsx)("div", {
      className: "border-r border-border overflow-hidden",
      children: (0, import_jsx_runtime3.jsx)(QueueList, {})
    });
    $[6] = t2;
  } else t2 = $[6];
  let t3;
  if ($[7] !== selectedQueue?.isDLQ) {
    t3 = (0, import_jsx_runtime3.jsx)("div", {
      className: "overflow-hidden",
      children: selectedQueue?.isDLQ ? (0, import_jsx_runtime3.jsx)(DLQPanel, {}) : (0, import_jsx_runtime3.jsx)(QueueDetail, {})
    });
    $[7] = selectedQueue?.isDLQ;
    $[8] = t3;
  } else t3 = $[8];
  let t4;
  if ($[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t4 = (0, import_jsx_runtime3.jsx)(JobDetail, {});
    $[9] = t4;
  } else t4 = $[9];
  let t5;
  if ($[10] !== t3) {
    t5 = (0, import_jsx_runtime3.jsxs)("div", {
      className: "grid grid-cols-[300px_1fr] h-full overflow-hidden",
      children: [
        t2,
        t3,
        t4
      ]
    });
    $[10] = t3;
    $[11] = t5;
  } else t5 = $[11];
  return t5;
});
QueuesPageContent.displayName = "QueuesPageContent";
var QueuesPage = (0, import_react.memo)(() => {
  const $ = (0, import_compiler_runtime.c)(2);
  if ($[0] !== "d90f8688a2f661493c4a0312f1c954fe541dc3821309a6ba650a56e59fcac492") {
    for (let $i = 0; $i < 2; $i += 1) $[$i] = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
    $[0] = "d90f8688a2f661493c4a0312f1c954fe541dc3821309a6ba650a56e59fcac492";
  }
  let t0;
  if ($[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel")) {
    t0 = (0, import_jsx_runtime3.jsx)(QueryProvider, { children: (0, import_jsx_runtime3.jsx)(QueuesPageContent, {}) });
    $[1] = t0;
  } else t0 = $[1];
  return t0;
});
QueuesPage.displayName = "QueuesPage";
function _temp(state) {
  return state.selectedQueue;
}
function _temp2(state_0) {
  return state_0.updateSelectedQueueStats;
}
export {
  QueuesPage
};
//# sourceMappingURL=@motiadev_plugin-bullmq.js.map
