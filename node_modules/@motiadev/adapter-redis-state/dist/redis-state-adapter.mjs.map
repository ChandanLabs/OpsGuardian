{"version":3,"file":"redis-state-adapter.mjs","names":["config: RedisClientOptions","items: StateItem[]","keys: string[]","cursor: string | number"],"sources":["../src/redis-state-adapter.ts"],"sourcesContent":["import type { StateAdapter, StateFilter, StateItem, StateItemsInput } from '@motiadev/core'\nimport { createClient, type RedisClientOptions, type RedisClientType } from 'redis'\nimport type { RedisStateAdapterOptions } from './types'\n\nfunction isRedisClient(input: RedisClientType | RedisClientOptions): input is RedisClientType {\n  return typeof input === 'object' && 'isOpen' in input && 'connect' in input\n}\n\nexport class RedisStateAdapter implements StateAdapter {\n  private client: RedisClientType\n  private keyPrefix: string\n  private ttl?: number\n  private connected = false\n  private isExternalClient: boolean\n\n  constructor(redisConnection: RedisClientType | RedisClientOptions, options?: RedisStateAdapterOptions) {\n    this.keyPrefix = options?.keyPrefix || 'motia:state:'\n    this.ttl = options?.ttl\n\n    if (isRedisClient(redisConnection)) {\n      this.client = redisConnection\n      this.isExternalClient = true\n      this.connected = this.client.isOpen\n    } else {\n      const config: RedisClientOptions = redisConnection\n      this.isExternalClient = false\n\n      this.client = createClient(config) as RedisClientType\n\n      this.client.on('error', (err) => {\n        if (this.connected) {\n          console.error('[Redis State] Client error:', err?.message)\n        }\n      })\n\n      this.client.on('connect', () => {\n        this.connected = true\n      })\n\n      this.client.on('disconnect', () => {\n        console.warn('[Redis State] Disconnected')\n        this.connected = false\n      })\n\n      this.client.on('reconnecting', () => {\n        console.log('[Redis State] Reconnecting...')\n      })\n\n      this.connect()\n    }\n  }\n\n  private async connect(): Promise<void> {\n    if (!this.connected && !this.client.isOpen) {\n      try {\n        await this.client.connect()\n      } catch (error) {\n        console.error('[Redis State] Failed to connect:', error)\n        throw error\n      }\n    }\n  }\n\n  private async ensureConnected(): Promise<void> {\n    if (!this.client.isOpen) {\n      await this.connect()\n    }\n  }\n\n  private makeKey(traceId: string, key: string): string {\n    return `${this.keyPrefix}${traceId}:${key}`\n  }\n\n  private makeTracePrefix(traceId: string): string {\n    return `${this.keyPrefix}${traceId}:`\n  }\n\n  private extractKey(fullKey: string, traceId: string): string {\n    const prefix = this.makeTracePrefix(traceId)\n    return fullKey.slice(prefix.length)\n  }\n\n  private determineType(value: unknown): StateItem['type'] {\n    if (value === null) return 'null'\n    if (Array.isArray(value)) return 'array'\n    return (\n      (['string', 'number', 'boolean', 'object'].find((type) => typeof value === type) as StateItem['type']) || 'object'\n    )\n  }\n\n  async get<T>(traceId: string, key: string): Promise<T | null> {\n    await this.ensureConnected()\n    const fullKey = this.makeKey(traceId, key)\n    const value = await this.client.get(fullKey)\n    return value ? JSON.parse(value) : null\n  }\n\n  async set<T>(traceId: string, key: string, value: T): Promise<T> {\n    await this.ensureConnected()\n    const fullKey = this.makeKey(traceId, key)\n    const serialized = JSON.stringify(value)\n\n    if (this.ttl) {\n      await this.client.setEx(fullKey, this.ttl, serialized)\n    } else {\n      await this.client.set(fullKey, serialized)\n    }\n\n    return value\n  }\n\n  async delete<T>(traceId: string, key: string): Promise<T | null> {\n    await this.ensureConnected()\n    const fullKey = this.makeKey(traceId, key)\n    const value = await this.get<T>(traceId, key)\n    await this.client.del(fullKey)\n    return value\n  }\n\n  async getGroup<T>(traceId: string): Promise<T[]> {\n    await this.ensureConnected()\n    const pattern = `${this.makeTracePrefix(traceId)}*`\n    const keys = await this.scanKeys(pattern)\n\n    if (keys.length === 0) return []\n\n    const values = await this.client.mGet(keys)\n    return values.filter((v): v is string => v !== null).map((v) => JSON.parse(v))\n  }\n\n  async clear(traceId: string): Promise<void> {\n    await this.ensureConnected()\n    const pattern = `${this.makeTracePrefix(traceId)}*`\n    const keys = await this.scanKeys(pattern)\n\n    if (keys.length > 0) {\n      await this.client.del(keys)\n    }\n  }\n\n  async cleanup(): Promise<void> {\n    if (!this.isExternalClient && this.client.isOpen) {\n      await this.client.quit()\n    }\n  }\n\n  async keys(traceId: string): Promise<string[]> {\n    await this.ensureConnected()\n    const pattern = `${this.makeTracePrefix(traceId)}*`\n    const keys = await this.scanKeys(pattern)\n    return keys.map((key) => this.extractKey(key, traceId))\n  }\n\n  async traceIds(): Promise<string[]> {\n    await this.ensureConnected()\n    const pattern = `${this.keyPrefix}*`\n    const keys = await this.scanKeys(pattern)\n\n    const traceIdSet = new Set<string>()\n    for (const key of keys) {\n      const withoutPrefix = key.slice(this.keyPrefix.length)\n      const traceId = withoutPrefix.split(':')[0]\n      if (traceId) {\n        traceIdSet.add(traceId)\n      }\n    }\n\n    return Array.from(traceIdSet)\n  }\n\n  async items(input: StateItemsInput): Promise<StateItem[]> {\n    await this.ensureConnected()\n    const items: StateItem[] = []\n\n    if (input.groupId) {\n      const pattern = `${this.makeTracePrefix(input.groupId)}*`\n      const keys = await this.scanKeys(pattern)\n\n      for (const fullKey of keys) {\n        const value = await this.client.get(fullKey)\n        if (value !== null) {\n          const key = this.extractKey(fullKey, input.groupId)\n          const parsedValue = JSON.parse(value)\n          items.push({\n            groupId: input.groupId,\n            key,\n            type: this.determineType(parsedValue),\n            value: parsedValue,\n          })\n        }\n      }\n    } else {\n      const traceIds = await this.traceIds()\n      for (const traceId of traceIds) {\n        const pattern = `${this.makeTracePrefix(traceId)}*`\n        const keys = await this.scanKeys(pattern)\n\n        for (const fullKey of keys) {\n          const value = await this.client.get(fullKey)\n          if (value !== null) {\n            const key = this.extractKey(fullKey, traceId)\n            const parsedValue = JSON.parse(value)\n            items.push({\n              groupId: traceId,\n              key,\n              type: this.determineType(parsedValue),\n              value: parsedValue,\n            })\n          }\n        }\n      }\n    }\n\n    if (input.filter && input.filter.length > 0) {\n      return this.applyFilters(items, input.filter)\n    }\n\n    return items\n  }\n\n  private async scanKeys(pattern: string): Promise<string[]> {\n    const keys: string[] = []\n    let cursor: string | number = '0'\n\n    do {\n      const result = await this.client.scan(cursor.toString(), {\n        MATCH: pattern,\n        COUNT: 100,\n      })\n      cursor = result.cursor\n      keys.push(...result.keys)\n    } while (String(cursor) !== '0')\n\n    return keys\n  }\n\n  private applyFilters(items: StateItem[], filters: StateFilter[]): StateItem[] {\n    return items.filter((item) => {\n      return filters.every((filter) => this.matchesFilter(item, filter))\n    })\n  }\n\n  private matchesFilter(item: StateItem, filter: StateFilter): boolean {\n    const value =\n      typeof item.value === 'object' && item.value !== null ? (item.value as any)[filter.valueKey] : item.value\n\n    const filterValue = filter.value\n\n    switch (filter.operation) {\n      case 'eq':\n        return value === filterValue\n      case 'neq':\n        return value !== filterValue\n      case 'gt':\n        return value > filterValue\n      case 'gte':\n        return value >= filterValue\n      case 'lt':\n        return value < filterValue\n      case 'lte':\n        return value <= filterValue\n      case 'contains':\n        return typeof value === 'string' && value.includes(filterValue)\n      case 'notContains':\n        return typeof value === 'string' && !value.includes(filterValue)\n      case 'startsWith':\n        return typeof value === 'string' && value.startsWith(filterValue)\n      case 'endsWith':\n        return typeof value === 'string' && value.endsWith(filterValue)\n      case 'isNotNull':\n        return value !== null && value !== undefined\n      case 'isNull':\n        return value === null || value === undefined\n      default:\n        return false\n    }\n  }\n}\n"],"mappings":"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"}