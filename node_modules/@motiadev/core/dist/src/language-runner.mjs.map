{"version":3,"file":"language-runner.mjs","names":[],"sources":["../../src/language-runner.ts"],"sourcesContent":["import { createRequire } from 'module'\nimport path from 'path'\nimport { fileURLToPath } from 'url'\n\nexport type LanguageRunnerConfig = {\n  command: string\n  runner: string\n  args: string[]\n}\n\nexport type LanguageRunnerOverrides = {\n  python?: string\n  ruby?: string\n  node?: {\n    js: string\n    ts?: string\n  }\n}\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\nconst require = createRequire(import.meta.url)\n\nconst getTsxPath = () => {\n  try {\n    const tsxModule = require.resolve('tsx/package.json')\n    return path.join(path.dirname(tsxModule), 'dist', 'cli.mjs')\n  } catch {\n    return 'tsx'\n  }\n}\n\nexport const getLanguageBasedRunner = (\n  stepFilePath = '',\n  overrides?: LanguageRunnerOverrides,\n): LanguageRunnerConfig => {\n  const isPython = stepFilePath.endsWith('.py')\n  const isRuby = stepFilePath.endsWith('.rb')\n  const isNode = stepFilePath.endsWith('.js') || stepFilePath.endsWith('.ts')\n\n  if (isPython) {\n    const pythonRunner = path.join(__dirname, 'python', overrides?.python ?? 'python-runner.py')\n    return { runner: pythonRunner, command: 'python', args: [] }\n  } else if (isRuby) {\n    const rubyRunner = path.join(__dirname, 'ruby', overrides?.ruby ?? 'ruby-runner.rb')\n    return { runner: rubyRunner, command: 'ruby', args: [] }\n  } else if (isNode) {\n    const defaultNodeOverrides = overrides?.node\n    const isTypeScript = stepFilePath.endsWith('.ts')\n\n    if (process.env._MOTIA_TEST_MODE === 'true') {\n      const runnerFile = defaultNodeOverrides?.ts ?? 'node-runner.ts'\n      return {\n        runner: path.join(__dirname, 'node', runnerFile),\n        command: 'node',\n        args: ['--loader', 'ts-node/esm', '--no-warnings=ExperimentalWarning'],\n      }\n    }\n    const jsRunner = path.join(__dirname, 'node', defaultNodeOverrides?.js ?? 'node-runner.mjs')\n\n    if (isTypeScript) {\n      return { runner: jsRunner, command: 'node', args: [] }\n    }\n\n    const tsxPath = getTsxPath()\n    // When tsx resolves to a file path, run it through node (tsx CLI is an .mjs file)\n    // When tsx falls back to 'tsx' string, use it directly as a command (assumes tsx is in PATH)\n    if (tsxPath !== 'tsx') {\n      return { runner: jsRunner, command: 'node', args: [tsxPath] }\n    }\n    return { runner: jsRunner, command: tsxPath, args: [] }\n  }\n\n  throw Error(`Unsupported file extension ${stepFilePath}`)\n}\n"],"mappings":";;;;;AAmBA,MAAM,YAAY,KAAK,QAAQ,cAAc,OAAO,KAAK,IAAI,CAAC;AAC9D,MAAM,UAAU,cAAc,OAAO,KAAK,IAAI;AAE9C,MAAM,mBAAmB;AACvB,KAAI;EACF,MAAM,YAAY,QAAQ,QAAQ,mBAAmB;AACrD,SAAO,KAAK,KAAK,KAAK,QAAQ,UAAU,EAAE,QAAQ,UAAU;SACtD;AACN,SAAO;;;AAIX,MAAa,0BACX,eAAe,IACf,cACyB;CACzB,MAAM,WAAW,aAAa,SAAS,MAAM;CAC7C,MAAM,SAAS,aAAa,SAAS,MAAM;CAC3C,MAAM,SAAS,aAAa,SAAS,MAAM,IAAI,aAAa,SAAS,MAAM;AAE3E,KAAI,SAEF,QAAO;EAAE,QADY,KAAK,KAAK,WAAW,UAAU,WAAW,UAAU,mBAAmB;EAC7D,SAAS;EAAU,MAAM,EAAE;EAAE;UACnD,OAET,QAAO;EAAE,QADU,KAAK,KAAK,WAAW,QAAQ,WAAW,QAAQ,iBAAiB;EACvD,SAAS;EAAQ,MAAM,EAAE;EAAE;UAC/C,QAAQ;EACjB,MAAM,uBAAuB,WAAW;EACxC,MAAM,eAAe,aAAa,SAAS,MAAM;AAEjD,MAAI,QAAQ,IAAI,qBAAqB,QAAQ;GAC3C,MAAM,aAAa,sBAAsB,MAAM;AAC/C,UAAO;IACL,QAAQ,KAAK,KAAK,WAAW,QAAQ,WAAW;IAChD,SAAS;IACT,MAAM;KAAC;KAAY;KAAe;KAAoC;IACvE;;EAEH,MAAM,WAAW,KAAK,KAAK,WAAW,QAAQ,sBAAsB,MAAM,kBAAkB;AAE5F,MAAI,aACF,QAAO;GAAE,QAAQ;GAAU,SAAS;GAAQ,MAAM,EAAE;GAAE;EAGxD,MAAM,UAAU,YAAY;AAG5B,MAAI,YAAY,MACd,QAAO;GAAE,QAAQ;GAAU,SAAS;GAAQ,MAAM,CAAC,QAAQ;GAAE;AAE/D,SAAO;GAAE,QAAQ;GAAU,SAAS;GAAS,MAAM,EAAE;GAAE;;AAGzD,OAAM,MAAM,8BAA8B,eAAe"}