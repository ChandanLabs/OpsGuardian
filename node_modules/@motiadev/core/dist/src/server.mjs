import { globalLogger } from "./logger.mjs";
import { trackEvent } from "./analytics/utils.mjs";
import { isApiStep } from "./guards.mjs";
import { callStepFile } from "./call-step-file.mjs";
import { generateTraceId } from "./generate-trace-id.mjs";
import { setupCronHandlers } from "./cron-handler.mjs";
import { Printer } from "./printer.mjs";
import { analyticsEndpoint } from "./endpoints/analytics-endpoint.mjs";
import { flowsConfigEndpoint } from "./endpoints/flows-config-endpoint.mjs";
import { flowsEndpoint } from "./endpoints/flows-endpoint.mjs";
import { stepEndpoint } from "./endpoints/step-endpoint.mjs";
import { BaseLoggerFactory } from "./logger-factory.mjs";
import { createTracerFactory } from "./observability/tracer.mjs";
import { runStreamCanAccess } from "./run-stream-can-access.mjs";
import { createSocketServer } from "./socket-server.mjs";
import { createStepHandlers } from "./step-handlers.mjs";
import { systemSteps } from "./steps/index.mjs";
import { RedisLogsStream } from "./streams/redis-logs-stream.mjs";
import bodyParser from "body-parser";
import express from "express";
import http from "http";

//#region src/server.ts
const createServer = (lockedData, state, config, adapters, configureApp) => {
	const printer = config.printer ?? new Printer(process.cwd());
	const app = express();
	if (configureApp) configureApp(app);
	const server = http.createServer(app);
	const streamAuth = lockedData.getStreamAuthConfig();
	const authorizeSubscription = async (subscription, authContext) => {
		const stream = lockedData.getStreamByName(subscription.streamName);
		if (!stream) throw new Error(`Stream ${subscription.streamName} not found`);
		const accessContext = {
			groupId: subscription.groupId,
			id: subscription.id
		};
		if (typeof stream.config.canAccess === "function") try {
			const allowed = await stream.config.canAccess(accessContext, authContext);
			return Boolean(allowed);
		} catch (error) {
			globalLogger.error("[Streams] Inline canAccess evaluation failed", {
				streamName: subscription.streamName,
				groupId: subscription.groupId,
				error
			});
			return false;
		}
		if (!stream.config.__motia_hasCanAccess) {
			globalLogger.debug("[Streams] No canAccess function found, allowing access", {
				streamName: subscription.streamName,
				groupId: subscription.groupId
			});
			return true;
		}
		try {
			const allowed = await runStreamCanAccess({
				file: stream.filePath,
				subscription: accessContext,
				authContext,
				projectRoot: lockedData.baseDir
			});
			return Boolean(allowed);
		} catch (error) {
			globalLogger.error("[Streams] canAccess evaluation failed", {
				streamName: subscription.streamName,
				groupId: subscription.groupId,
				error
			});
			return false;
		}
	};
	const { pushEvent, socketServer } = createSocketServer({
		server,
		authenticate: streamAuth?.authenticate,
		authorize: authorizeSubscription,
		onJoin: async (streamName, groupId, id) => {
			const stream = lockedData.getStreams()[streamName];
			if (stream) {
				const result = await stream().get(groupId, id);
				delete result?.__motia;
				return result;
			}
		},
		onJoinGroup: async (streamName, groupId) => {
			const stream = lockedData.getStreams()[streamName];
			if (stream) return (stream ? await stream().getGroup(groupId) : []).map(({ __motia, ...rest }) => rest);
		}
	});
	lockedData.applyStreamWrapper((streamName, stream) => {
		return () => {
			const main = stream();
			const wrapObject = (groupId, id, object) => {
				if (!object) return null;
				return {
					...object,
					__motia: {
						type: "state-stream",
						streamName,
						groupId,
						id
					}
				};
			};
			const mainGetGroup = main.getGroup;
			const mainGet = main.get;
			const mainSet = main.set;
			const mainDelete = main.delete;
			main.send = async (channel, event) => {
				pushEvent({
					streamName,
					...channel,
					event: {
						type: "event",
						event
					}
				});
			};
			main.getGroup = async (groupId) => {
				return (await mainGetGroup.apply(main, [groupId])).map((object) => wrapObject(groupId, object.id, object));
			};
			main.get = async (groupId, id) => {
				return wrapObject(groupId, id, await mainGet.apply(main, [groupId, id]));
			};
			main.set = async (groupId, id, data) => {
				if (!data) return null;
				const exists = await main.get(groupId, id);
				const result = await mainSet.apply(main, [
					groupId,
					id,
					data
				]) ?? data;
				const wrappedResult = wrapObject(groupId, id, result);
				pushEvent({
					streamName,
					groupId,
					id,
					event: {
						type: exists ? "update" : "create",
						data: result
					}
				});
				return wrappedResult;
			};
			main.delete = async (groupId, id) => {
				const result = await mainDelete.apply(main, [groupId, id]);
				pushEvent({
					streamName,
					groupId,
					id,
					event: {
						type: "delete",
						data: result
					}
				});
				return wrapObject(groupId, id, result);
			};
			return main;
		};
	});
	const logStream = lockedData.createStream({
		filePath: "__motia.logs",
		hidden: true,
		config: {
			name: "__motia.logs",
			baseConfig: {
				storageType: "custom",
				factory: () => {
					if (!lockedData.redisClient) throw new Error("Redis client is required for server operation. Please provide a redisClient when creating LockedData.");
					return new RedisLogsStream(lockedData.redisClient);
				}
			},
			schema: null
		}
	})();
	const allSteps = [...systemSteps, ...lockedData.activeSteps];
	const loggerFactory = new BaseLoggerFactory(config.isVerbose, logStream);
	const tracerFactory = createTracerFactory(lockedData);
	const motia = {
		loggerFactory,
		eventAdapter: adapters.eventAdapter,
		state,
		lockedData,
		printer,
		tracerFactory,
		app,
		stateAdapter: state
	};
	const cronManager = setupCronHandlers(motia, adapters?.cronAdapter);
	const motiaEventManager = createStepHandlers(motia, adapters.eventAdapter);
	const asyncHandler = (step) => {
		return async (req, res) => {
			const traceId = generateTraceId();
			const { name: stepName, flows } = step.config;
			const logger = loggerFactory.create({
				traceId,
				flows,
				stepName
			});
			logger.debug("[API] Received request, processing step", { path: req.path });
			const rawBody = req.rawBody || "";
			const data = {
				body: req.body,
				headers: req.headers,
				pathParams: req.params,
				queryParams: req.query,
				rawBody
			};
			try {
				let result;
				if ("handler" in step && typeof step.handler === "function") {
					const context = {
						traceId,
						flows,
						state,
						emit: async (event) => {
							const eventObj = {
								...event,
								traceId,
								flows,
								logger,
								tracer: null
							};
							await adapters.eventAdapter.emit(eventObj);
						},
						logger,
						streams: lockedData.getStreams()
					};
					result = await step.handler(data, context);
				} else result = await callStepFile({
					data,
					step,
					logger,
					tracer: await motia.tracerFactory.createTracer(traceId, step, logger),
					traceId
				}, motia);
				trackEvent("api_call_success", { stepName });
				if (!result) {
					console.log("no result");
					res.status(500).json({ error: "Internal server error" });
					return;
				}
				if (result.headers) Object.entries(result.headers).forEach(([key, value]) => res.setHeader(key, value));
				res.status(result.status);
				if (Buffer.isBuffer(result.body) || typeof result.body === "string") res.send(result.body);
				else res.json(result.body);
			} catch (error) {
				trackEvent("api_call_error", {
					stepName,
					traceId,
					error: error instanceof Error ? error.message : "Unknown error"
				});
				logger.error("[API] Internal server error", { error });
				console.log(error);
				res.status(500).json({ error: "Internal server error" });
			}
		};
	};
	app.use((req, _, next) => {
		req.rawBody = "";
		next();
	});
	app.use(bodyParser.json({
		limit: "1gb",
		verify: (req, _, buf, encoding) => {
			req.rawBody = buf.toString(encoding || "utf8");
		}
	}));
	app.use(bodyParser.urlencoded({
		extended: true,
		limit: "1gb",
		verify: (req, _, buf, encoding) => {
			req.rawBody = buf.toString(encoding || "utf8");
		}
	}));
	app.use(bodyParser.text({
		limit: "1gb",
		verify: (req, _, buf, encoding) => {
			req.rawBody = buf.toString(encoding || "utf8");
		}
	}));
	const router = express.Router();
	const addRoute = (step) => {
		const { method, path } = step.config;
		globalLogger.debug("[API] Registering route", step.config);
		const handler = asyncHandler(step);
		const methodHandler = {
			GET: () => router.get(path, handler),
			POST: () => router.post(path, handler),
			PUT: () => router.put(path, handler),
			DELETE: () => router.delete(path, handler),
			PATCH: () => router.patch(path, handler),
			OPTIONS: () => router.options(path, handler),
			HEAD: () => router.head(path, handler)
		}[method];
		if (!methodHandler) throw new Error(`Unsupported method: ${method}`);
		methodHandler();
	};
	const removeRoute = (step) => {
		const { path, method } = step.config;
		router.stack = router.stack.filter((layer) => {
			if (layer.route) return !(layer.route.path === path && layer.route.methods[method.toLowerCase()]);
			return true;
		});
	};
	allSteps.filter(isApiStep).forEach(addRoute);
	app.options("*", (_req, res) => {
		res.header("Access-Control-Allow-Origin", "*");
		res.header("Access-Control-Allow-Methods", "*");
		res.header("Access-Control-Allow-Headers", "*");
		res.header("Access-Control-Max-Age", "600");
		res.header("Access-Control-Allow-Credentials", "true");
		res.header("Access-Control-Allow-Private-Network", "true");
		res.status(204).end();
	});
	app.use((_req, res, next) => {
		res.header("Access-Control-Allow-Origin", "*");
		res.header("Access-Control-Allow-Methods", "*");
		res.header("Access-Control-Allow-Headers", "*");
		res.header("Access-Control-Max-Age", "600");
		res.header("Access-Control-Allow-Credentials", "true");
		res.header("Access-Control-Allow-Private-Network", "true");
		next();
	});
	app.use(router);
	flowsEndpoint(lockedData);
	flowsConfigEndpoint(app, process.cwd(), lockedData);
	analyticsEndpoint(app, process.cwd());
	stepEndpoint(app, lockedData);
	server.on("error", (error) => {
		if (error.code !== "EADDRINUSE") console.error("Server error:", error);
	});
	socketServer.on("error", (error) => {
		if (error.code !== "EADDRINUSE") console.error("WebSocket server error:", error);
	});
	const close = async () => {
		await cronManager.close();
		socketServer.close();
		if (adapters?.eventAdapter) await adapters.eventAdapter.shutdown();
	};
	return {
		app,
		server,
		socketServer,
		close,
		removeRoute,
		addRoute,
		cronManager,
		motiaEventManager,
		motia,
		printer
	};
};

//#endregion
export { createServer };
//# sourceMappingURL=server.mjs.map