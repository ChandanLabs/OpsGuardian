import { RpcProcessor } from "../step-handler-rpc-processor.mjs";
import { RpcStdinProcessor } from "../step-handler-rpc-stdin-processor.mjs";
import { createCommunicationConfig } from "./communication-config.mjs";
import { spawn } from "child_process";

//#region src/process-communication/process-manager.ts
var ProcessManager = class {
	constructor(options) {
		this.options = options;
	}
	async spawn() {
		const { command, args, logger, context = "Process", projectRoot } = this.options;
		const commConfig = createCommunicationConfig(command, projectRoot);
		this.communicationType = commConfig.type;
		logger.debug(`[${context}] Spawning process`, {
			command,
			args,
			communicationType: this.communicationType
		});
		this.child = spawn(command, args, commConfig.spawnOptions);
		this.processor = this.communicationType === "rpc" ? new RpcStdinProcessor(this.child) : new RpcProcessor(this.child);
		await this.processor.init();
		return this.child;
	}
	handler(method, handler) {
		if (!this.processor) throw new Error("Process not spawned yet. Call spawn() first.");
		this.processor.handler(method, handler);
	}
	onMessage(callback) {
		if (!this.processor) throw new Error("Process not spawned yet. Call spawn() first.");
		this.processor.onMessage(callback);
	}
	onProcessClose(callback) {
		if (!this.child) throw new Error("Process not spawned yet. Call spawn() first.");
		this.child.on("close", callback);
	}
	onProcessError(callback) {
		if (!this.child) throw new Error("Process not spawned yet. Call spawn() first.");
		this.child.on("error", callback);
	}
	onStderr(callback) {
		if (!this.child) throw new Error("Process not spawned yet. Call spawn() first.");
		this.child.stderr?.on("data", callback);
	}
	onStdout(callback) {
		if (!this.child) throw new Error("Process not spawned yet. Call spawn() first.");
		if (this.communicationType !== "rpc") this.child.stdout?.on("data", callback);
	}
	kill() {
		if (this.child) this.child.kill("SIGKILL");
	}
	close() {
		if (this.child) {
			this.child.removeAllListeners();
			this.child.stdout?.removeAllListeners();
			this.child.stderr?.removeAllListeners();
		}
		if (this.processor) {
			this.processor.close();
			this.processor = void 0;
		}
	}
	get process() {
		return this.child;
	}
	get commType() {
		return this.communicationType;
	}
};

//#endregion
export { ProcessManager };
//# sourceMappingURL=process-manager.mjs.map