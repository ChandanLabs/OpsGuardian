import { globalLogger } from "./logger.mjs";
import { getLanguageBasedRunner } from "./language-runner.mjs";
import { ProcessManager } from "./process-communication/process-manager.mjs";

//#region src/run-stream-can-access.ts
const runStreamCanAccess = async ({ file, subscription, authContext, projectRoot }) => {
	const { runner, command, args } = getLanguageBasedRunner(file, {
		python: "can-access.py",
		ruby: "can-access.rb",
		node: {
			js: "can-access.mjs",
			ts: "can-access.ts"
		}
	});
	const payload = JSON.stringify({
		subscription,
		authContext
	});
	return new Promise((resolve, reject) => {
		let result = null;
		const processManager = new ProcessManager({
			command,
			args: [
				...args,
				runner,
				file,
				payload
			],
			logger: globalLogger,
			context: "StreamCanAccess",
			projectRoot
		});
		processManager.spawn().then(() => {
			processManager.onMessage((message) => {
				result = Boolean(message);
				resolve(result);
				processManager.kill();
			});
			processManager.onProcessClose((code) => {
				processManager.close();
				if (result !== null) return;
				if (code !== 0) reject(`Process exited with code ${code}`);
				else reject("Stream canAccess evaluation returned no result");
			});
			processManager.onProcessError((error) => {
				processManager.close();
				if (error.code === "ENOENT") reject(`Executable ${command} not found`);
				else reject(error);
			});
		}).catch((error) => {
			processManager.close();
			reject(`Failed to spawn process: ${error}`);
		});
	});
};

//#endregion
export { runStreamCanAccess };
//# sourceMappingURL=run-stream-can-access.mjs.map