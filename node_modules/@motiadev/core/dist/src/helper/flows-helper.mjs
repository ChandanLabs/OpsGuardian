import { isApiStep, isCronStep, isEventStep, isNoopStep } from "../guards.mjs";
import { getStepLanguage } from "../get-step-language.mjs";
import { v5 } from "uuid";
import fs from "fs";
import path from "path";

//#region src/helper/flows-helper.ts
const getNodeComponentPath = (filePath) => {
	const filePathWithoutExtension = filePath.replace(/\.[^/.]+$/, "");
	const tsxPath = filePathWithoutExtension + ".tsx";
	const jsxPath = filePathWithoutExtension + ".jsx";
	if (fs.existsSync(tsxPath)) return tsxPath;
	if (fs.existsSync(jsxPath)) return jsxPath;
};
const getRelativePath = (filePath) => {
	const baseDir = process.cwd();
	return path.relative(baseDir, filePath);
};
const createEdge = (sourceId, targetId, topic, label, variant, conditional) => ({
	id: `${sourceId}-${targetId}`,
	source: sourceId,
	target: targetId,
	data: {
		variant,
		label,
		topic,
		labelVariant: conditional ? "conditional" : "default"
	}
});
const processEmit = (emit) => {
	const isString = typeof emit === "string";
	return {
		topic: isString ? emit : emit.topic,
		label: isString ? void 0 : emit.label,
		conditional: isString ? void 0 : emit.conditional
	};
};
const createEdgesForEmits = (sourceStep, targetSteps, emits, variant) => {
	const edges = [];
	emits.forEach((emit) => {
		const { topic, label, conditional } = processEmit(emit);
		targetSteps.forEach((targetStep) => {
			if (targetStep.subscribes?.includes(topic) || targetStep.virtualSubscribes?.includes(topic)) edges.push(createEdge(sourceStep.id, targetStep.id, topic, label, variant, conditional));
		});
	});
	return edges;
};
const createBaseStepResponse = (step, id) => ({
	id,
	name: step.config.name,
	description: step.config.description,
	nodeComponentPath: getNodeComponentPath(step.filePath),
	filePath: getRelativePath(step.filePath),
	language: getStepLanguage(step.filePath),
	virtualEmits: step.config.virtualEmits ?? void 0,
	virtualSubscribes: step.config.virtualSubscribes ?? void 0
});
const createApiStepResponse = (step, id) => {
	if (!isApiStep(step)) throw new Error("Attempted to create API step response with non-API step");
	return {
		...createBaseStepResponse(step, id),
		type: "api",
		emits: step.config.emits,
		subscribes: step.config.virtualSubscribes ?? void 0,
		action: "webhook",
		webhookUrl: `${step.config.method} ${step.config.path}`,
		bodySchema: step.config.bodySchema ?? void 0
	};
};
const createEventStepResponse = (step, id) => {
	if (!isEventStep(step)) throw new Error("Attempted to create Event step response with non-Event step");
	return {
		...createBaseStepResponse(step, id),
		type: "event",
		emits: step.config.emits,
		subscribes: step.config.subscribes
	};
};
const createNoopStepResponse = (step, id) => {
	if (!isNoopStep(step)) throw new Error("Attempted to create Noop step response with non-Noop step");
	return {
		...createBaseStepResponse(step, id),
		type: "noop",
		emits: [],
		subscribes: step.config.virtualSubscribes
	};
};
const createCronStepResponse = (step, id) => {
	if (!isCronStep(step)) throw new Error("Attempted to create Cron step response with non-Cron step");
	return {
		...createBaseStepResponse(step, id),
		type: "cron",
		emits: step.config.emits,
		cronExpression: step.config.cron
	};
};
const STEP_NAMESPACE = "7f1c3ff2-9b00-4d0a-bdd7-efb8bca49d4f";
const generateStepId = (filePath) => {
	return v5(filePath, STEP_NAMESPACE);
};
const createStepResponse = (step) => {
	const id = generateStepId(step.filePath);
	if (isApiStep(step)) return createApiStepResponse(step, id);
	if (isEventStep(step)) return createEventStepResponse(step, id);
	if (isNoopStep(step)) return createNoopStepResponse(step, id);
	if (isCronStep(step)) return createCronStepResponse(step, id);
	throw new Error(`Unknown step type for step: ${step.config.name}`);
};
const createEdgesForStep = (sourceStep, allSteps) => {
	const regularEdges = createEdgesForEmits(sourceStep, allSteps, sourceStep.emits, "event");
	const virtualEdges = sourceStep.virtualEmits ? createEdgesForEmits(sourceStep, allSteps, sourceStep.virtualEmits, "virtual") : [];
	return [...regularEdges, ...virtualEdges];
};
const generateFlow = (flowId, flowSteps) => {
	const steps = flowSteps.map(createStepResponse);
	return {
		id: flowId,
		name: flowId,
		steps,
		edges: steps.flatMap((step) => createEdgesForStep(step, steps))
	};
};

//#endregion
export { generateFlow, generateStepId };
//# sourceMappingURL=flows-helper.mjs.map