import { Logger } from "./logger.mjs";
import { composeMiddleware } from "./middleware-compose.mjs";
import { RpcSender } from "./rpc.mjs";
import { RpcStateManager } from "./rpc-state-manager.mjs";
import path from "path";
import { pathToFileURL } from "url";
import dotenv from "dotenv";

//#region src/node/node-runner.ts
dotenv.config();
function parseArgs(arg$1) {
	try {
		return JSON.parse(arg$1);
	} catch {
		return arg$1;
	}
}
const importCompiledModule = async (filePath$1) => {
	try {
		return import(pathToFileURL(path.resolve(filePath$1)).href);
	} catch (importError) {
		const err = importError;
		throw {
			message: `Failed to import module ${filePath$1}: ${err.message}`,
			code: err.code || "IMPORT_ERROR",
			stack: err.stack || ""
		};
	}
};
async function runTypescriptModule(filePath$1, event) {
	const sender = new RpcSender(process);
	try {
		sender.init();
		const importedModule = await importCompiledModule(filePath$1);
		const handler = importedModule.handler || importedModule.default?.handler;
		const config = importedModule.config || importedModule.default?.config || {};
		if (typeof handler !== "function") throw new Error(`Function handler not found in module ${filePath$1}`);
		const { traceId, flows, contextInFirstArg } = event;
		const logger = new Logger(traceId, flows, sender);
		const state = new RpcStateManager(sender);
		const emit = async (data) => sender.send("emit", data);
		const context = {
			traceId,
			flows,
			logger,
			state,
			emit,
			streams: (event.streams ?? []).reduce((acc, streams) => {
				acc[streams.name] = {
					get: (groupId, id) => sender.send(`streams.${streams.name}.get`, {
						groupId,
						id
					}),
					set: (groupId, id, data) => sender.send(`streams.${streams.name}.set`, {
						groupId,
						id,
						data
					}),
					delete: (groupId, id) => sender.send(`streams.${streams.name}.delete`, {
						groupId,
						id
					}),
					getGroup: (groupId) => sender.send(`streams.${streams.name}.getGroup`, { groupId }),
					send: (channel, event$1) => sender.send(`streams.${streams.name}.send`, {
						channel,
						event: event$1
					})
				};
				return acc;
			}, {})
		};
		const composedMiddleware = composeMiddleware(...Array.isArray(config.middleware) ? config.middleware : []);
		const handlerFn = () => {
			return contextInFirstArg ? handler(context) : handler(event.data, context);
		};
		const result = await composedMiddleware(event.data, context, handlerFn);
		if (result !== void 0 && result !== null) await sender.send("result", result);
		sender.sendNoWait("close", void 0);
		await sender.close();
		process.exit(0);
	} catch (err) {
		const error = err;
		const stack = error.stack?.split("\n") ?? [];
		if (stack) {
			const index = stack.findIndex((line) => line.includes("src/node/node-runner"));
			stack.splice(index, stack.length - index);
			stack.splice(0, 1);
		}
		const errorObj = {
			message: error.message || "",
			code: error.code || null,
			stack: stack.join("\n")
		};
		sender.sendNoWait("close", errorObj);
	}
}
const [, , filePath, arg] = process.argv;
if (!filePath) {
	console.error("Usage: node node-runner.mjs <file-path> <arg>");
	process.exit(1);
}
runTypescriptModule(filePath, parseArgs(arg)).catch((err) => {
	console.error("Error:", err);
	process.exit(1);
});

//#endregion
export {  };
//# sourceMappingURL=node-runner.mjs.map