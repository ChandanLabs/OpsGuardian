import { createTrace } from "./create-trace.mjs";

//#region src/observability/stream-tracer.ts
var StreamTracer = class StreamTracer {
	constructor(manager, traceGroup, trace, logger) {
		this.manager = manager;
		this.traceGroup = traceGroup;
		this.trace = trace;
		logger.addListener(async (level, msg, args) => {
			await this.addEvent({
				type: "log",
				timestamp: Date.now(),
				level,
				message: msg,
				metadata: args
			});
		});
	}
	async end(err) {
		if (this.trace.endTime) return;
		this.trace.status = err ? "failed" : "completed";
		this.trace.endTime = Date.now();
		this.trace.error = err;
		await this.manager.updateTrace();
	}
	async stateOperation(operation, input) {
		await this.addEvent({
			type: "state",
			timestamp: Date.now(),
			operation,
			data: input
		});
	}
	async emitOperation(topic, data, success) {
		await this.addEvent({
			type: "emit",
			timestamp: Date.now(),
			topic,
			success,
			data
		});
	}
	async streamOperation(streamName, operation, input) {
		if (operation === "set") {
			const lastEvent = this.trace.events[this.trace.events.length - 1];
			if (lastEvent && lastEvent.type === "stream" && lastEvent.streamName === streamName && lastEvent.data.groupId === input.groupId && lastEvent.data.id === input.id) {
				lastEvent.calls++;
				lastEvent.data.data = input.data;
				lastEvent.maxTimestamp = Date.now();
				await this.manager.updateTrace();
				return;
			}
		}
		await this.addEvent({
			type: "stream",
			timestamp: Date.now(),
			operation,
			data: input,
			streamName,
			calls: 1
		});
	}
	child(step, logger) {
		const trace = createTrace(this.traceGroup, step);
		return new StreamTracer(this.manager.child(trace), this.traceGroup, trace, logger);
	}
	async addEvent(event) {
		this.trace.events.push(event);
		await this.manager.updateTrace();
	}
};

//#endregion
export { StreamTracer };
//# sourceMappingURL=stream-tracer.mjs.map