{"version":3,"file":"get-step-config.mjs","names":["config: T | null"],"sources":["../../src/get-step-config.ts"],"sourcesContent":["import { getLanguageBasedRunner } from './language-runner'\nimport { globalLogger } from './logger'\nimport { ProcessManager } from './process-communication/process-manager'\nimport { compile } from './ts-compiler'\nimport type { StepConfig } from './types'\nimport type { StreamConfig } from './types-stream'\n\nconst getConfig = async <T>(file: string, projectRoot?: string): Promise<T | null> => {\n  const filePathToExecute = file.endsWith('.ts') ? await compile(file, projectRoot || process.cwd()) : file\n\n  const { runner, command, args } = getLanguageBasedRunner(file, {\n    python: 'get-config.py',\n    ruby: 'get-config.rb',\n    node: { js: 'get-config.mjs', ts: 'get-config.ts' },\n  })\n\n  const processManager = new ProcessManager({\n    command,\n    args: [...args, runner, filePathToExecute],\n    logger: globalLogger,\n    context: 'Config',\n    projectRoot,\n  })\n\n  return new Promise((resolve, reject) => {\n    let config: T | null = null\n\n    processManager\n      .spawn()\n      .then(() => {\n        processManager.onMessage<T>((message) => {\n          config = message\n          globalLogger.debug(`[Config] Read config via ${processManager.commType?.toUpperCase()}`, {\n            config,\n            communicationType: processManager.commType,\n          })\n          resolve(config)\n          processManager.kill()\n        })\n\n        processManager.onProcessClose((code) => {\n          processManager.close()\n          if (config) {\n            return\n          } else if (code !== 0) {\n            reject(`Process exited with code ${code}`)\n          } else if (!config) {\n            reject(`No config found for file ${file}`)\n          }\n        })\n\n        processManager.onProcessError((error) => {\n          processManager.close()\n          if (error.code === 'ENOENT') {\n            reject(`Executable ${command} not found`)\n          } else {\n            reject(error)\n          }\n        })\n      })\n      .catch((error) => {\n        reject(`Failed to spawn process: ${error}`)\n      })\n  })\n}\n\nexport const getStepConfig = (file: string, projectRoot?: string): Promise<StepConfig | null> => {\n  return getConfig<StepConfig>(file, projectRoot)\n}\n\nexport const getStreamConfig = (file: string, projectRoot?: string): Promise<StreamConfig | null> => {\n  return getConfig<StreamConfig>(file, projectRoot)\n}\n\nexport { invalidate } from './ts-compiler'\n"],"mappings":";;;;;;AAOA,MAAM,YAAY,OAAU,MAAc,gBAA4C;CACpF,MAAM,oBAAoB,KAAK,SAAS,MAAM,GAAG,MAAM,QAAQ,MAAM,eAAe,QAAQ,KAAK,CAAC,GAAG;CAErG,MAAM,EAAE,QAAQ,SAAS,SAAS,uBAAuB,MAAM;EAC7D,QAAQ;EACR,MAAM;EACN,MAAM;GAAE,IAAI;GAAkB,IAAI;GAAiB;EACpD,CAAC;CAEF,MAAM,iBAAiB,IAAI,eAAe;EACxC;EACA,MAAM;GAAC,GAAG;GAAM;GAAQ;GAAkB;EAC1C,QAAQ;EACR,SAAS;EACT;EACD,CAAC;AAEF,QAAO,IAAI,SAAS,SAAS,WAAW;EACtC,IAAIA,SAAmB;AAEvB,iBACG,OAAO,CACP,WAAW;AACV,kBAAe,WAAc,YAAY;AACvC,aAAS;AACT,iBAAa,MAAM,4BAA4B,eAAe,UAAU,aAAa,IAAI;KACvF;KACA,mBAAmB,eAAe;KACnC,CAAC;AACF,YAAQ,OAAO;AACf,mBAAe,MAAM;KACrB;AAEF,kBAAe,gBAAgB,SAAS;AACtC,mBAAe,OAAO;AACtB,QAAI,OACF;aACS,SAAS,EAClB,QAAO,4BAA4B,OAAO;aACjC,CAAC,OACV,QAAO,4BAA4B,OAAO;KAE5C;AAEF,kBAAe,gBAAgB,UAAU;AACvC,mBAAe,OAAO;AACtB,QAAI,MAAM,SAAS,SACjB,QAAO,cAAc,QAAQ,YAAY;QAEzC,QAAO,MAAM;KAEf;IACF,CACD,OAAO,UAAU;AAChB,UAAO,4BAA4B,QAAQ;IAC3C;GACJ;;AAGJ,MAAa,iBAAiB,MAAc,gBAAqD;AAC/F,QAAO,UAAsB,MAAM,YAAY;;AAGjD,MAAa,mBAAmB,MAAc,gBAAuD;AACnG,QAAO,UAAwB,MAAM,YAAY"}