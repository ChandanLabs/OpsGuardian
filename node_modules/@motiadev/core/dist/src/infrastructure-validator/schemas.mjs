import { z } from "zod";

//#region src/infrastructure-validator/schemas.ts
const AWS_LAMBDA_LIMITS = {
	MIN_RAM_MB: 128,
	MAX_RAM_MB: 10240,
	MIN_TIMEOUT_SECONDS: 1,
	MAX_TIMEOUT_SECONDS: 900
};
const AWS_LAMBDA_CPU_RATIO = {
	128: .0625,
	256: .125,
	512: .25,
	1024: .5,
	1536: .75,
	2048: 1,
	3008: 1.5,
	4096: 2,
	5120: 2.5,
	6144: 3,
	7168: 3.5,
	8192: 4,
	9216: 4.5,
	10240: 5
};
function getProportionalCpu(ramMb) {
	const ramValues = Object.keys(AWS_LAMBDA_CPU_RATIO).map(Number).sort((a, b) => a - b);
	const exact = AWS_LAMBDA_CPU_RATIO[ramMb];
	if (exact !== void 0) return exact;
	for (let i = 0; i < ramValues.length - 1; i++) {
		const lower = ramValues[i];
		const upper = ramValues[i + 1];
		if (ramMb > lower && ramMb < upper) {
			const lowerCpu = AWS_LAMBDA_CPU_RATIO[lower];
			const upperCpu = AWS_LAMBDA_CPU_RATIO[upper];
			const ratio = (ramMb - lower) / (upper - lower);
			return lowerCpu + (upperCpu - lowerCpu) * ratio;
		}
	}
	return ramMb <= ramValues[0] ? AWS_LAMBDA_CPU_RATIO[ramValues[0]] : AWS_LAMBDA_CPU_RATIO[ramValues[ramValues.length - 1]];
}
const handlerBaseSchema = z.object({
	ram: z.number().min(AWS_LAMBDA_LIMITS.MIN_RAM_MB, `RAM must be at least ${AWS_LAMBDA_LIMITS.MIN_RAM_MB} MB`).max(AWS_LAMBDA_LIMITS.MAX_RAM_MB, `RAM cannot exceed ${AWS_LAMBDA_LIMITS.MAX_RAM_MB} MB`),
	timeout: z.number().min(AWS_LAMBDA_LIMITS.MIN_TIMEOUT_SECONDS, `Timeout must be at least ${AWS_LAMBDA_LIMITS.MIN_TIMEOUT_SECONDS}s`).max(AWS_LAMBDA_LIMITS.MAX_TIMEOUT_SECONDS, `Timeout cannot exceed ${AWS_LAMBDA_LIMITS.MAX_TIMEOUT_SECONDS}s`),
	cpu: z.number().optional()
});
const handlerSchema = handlerBaseSchema.partial().superRefine((handler, ctx) => {
	if (handler.cpu === void 0 || handler.ram === void 0) return;
	const expectedCpu = getProportionalCpu(handler.ram);
	if (Math.abs(handler.cpu - expectedCpu) > .1) ctx.addIssue({
		code: z.ZodIssueCode.custom,
		path: ["handler", "cpu"],
		message: `CPU (${handler.cpu} vCPU) is not proportional to RAM (${handler.ram} MB). Expected approximately ${expectedCpu.toFixed(2)} vCPU`
	});
});
const queueSchema = z.object({
	type: z.enum(["standard", "fifo"]),
	visibilityTimeout: z.number(),
	maxRetries: z.number().min(0, "maxRetries cannot be negative"),
	delaySeconds: z.number().min(0, "delaySeconds cannot be negative").max(900, "delaySeconds cannot exceed 900 seconds (15 minutes)").optional()
});
const infrastructureSchema = z.object({
	handler: handlerSchema.optional(),
	queue: queueSchema.partial().optional()
}).superRefine((config, ctx) => {
	if (config.queue?.visibilityTimeout !== void 0 && config.handler?.timeout !== void 0) {
		if (config.queue.visibilityTimeout <= config.handler.timeout) ctx.addIssue({
			code: z.ZodIssueCode.custom,
			path: ["queue", "visibilityTimeout"],
			message: `Visibility timeout (${config.queue.visibilityTimeout}s) must be greater than handler timeout (${config.handler.timeout}s) to prevent premature message redelivery`
		});
	}
});

//#endregion
export { AWS_LAMBDA_CPU_RATIO, AWS_LAMBDA_LIMITS, getProportionalCpu, handlerBaseSchema, handlerSchema, infrastructureSchema, queueSchema };
//# sourceMappingURL=schemas.mjs.map