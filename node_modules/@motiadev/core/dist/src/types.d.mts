import { Logger } from "./logger.mjs";
import { Tracer } from "./adapters/interfaces/observability-adapter.interface.mjs";
import "./observability/index.mjs";
import { JsonSchema } from "./types/schema.types.mjs";
import { AdapterConfig, Config, MotiaPlugin, MotiaPluginBuilder, RedisConfig, StreamAuthConfig, StreamAuthRequest, WorkbenchPlugin } from "./types/app-config-types.mjs";
import { ZodArray, ZodObject } from "zod";

//#region src/types.d.ts
type ZodInput = ZodObject<any> | ZodArray<any>;
type StepSchemaInput = ZodInput | JsonSchema;
type InternalStateManager = {
  get<T>(groupId: string, key: string): Promise<T | null>;
  set<T>(groupId: string, key: string, value: T): Promise<T>;
  delete<T>(groupId: string, key: string): Promise<T | null>;
  getGroup<T>(groupId: string): Promise<T[]>;
  clear(groupId: string): Promise<void>;
};
type EmitData = {
  topic: '';
  data: unknown;
  messageGroupId?: string;
};
type Emitter<TData> = (event: TData) => Promise<void>;
interface FlowContextStateStreams {}
interface FlowContext<TEmitData = never> {
  emit: Emitter<TEmitData>;
  traceId: string;
  state: InternalStateManager;
  logger: Logger;
  streams: FlowContextStateStreams;
}
type EventHandler<TInput, TEmitData> = (input: TInput, ctx: FlowContext<TEmitData>) => Promise<void>;
type Emit = string | {
  topic: string;
  label?: string;
  conditional?: boolean;
};
type HandlerConfig = {
  ram: number;
  cpu?: number;
  timeout: number;
};
type QueueConfig = {
  type: 'fifo';
  maxRetries: number;
  visibilityTimeout: number;
  delaySeconds: number;
} | {
  type: 'standard';
  maxRetries: number;
  visibilityTimeout: number;
  delaySeconds: number;
  concurrency?: number;
};
type InfrastructureConfig = {
  handler?: Partial<HandlerConfig>;
  queue?: Partial<QueueConfig>;
};
type EventConfig = {
  type: 'event';
  name: string;
  description?: string;
  subscribes: string[];
  emits: Emit[];
  virtualEmits?: Emit[];
  virtualSubscribes?: string[];
  input?: StepSchemaInput;
  flows?: string[];
  /**
   * Files to include in the step bundle.
   * Needs to be relative to the step file.
   */
  includeFiles?: string[];
  infrastructure?: Partial<InfrastructureConfig>;
};
type NoopConfig = {
  type: 'noop';
  name: string;
  description?: string;
  virtualEmits: Emit[];
  virtualSubscribes: string[];
  flows?: string[];
};
type ApiRouteMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'OPTIONS' | 'HEAD';
type ApiMiddleware<TBody = unknown, TEmitData = never, TResult = unknown> = (req: ApiRequest<TBody>, ctx: FlowContext<TEmitData>, next: () => Promise<ApiResponse<number, TResult>>) => Promise<ApiResponse<number, TResult>>;
interface QueryParam {
  name: string;
  description: string;
}
interface ApiRouteConfig {
  type: 'api';
  name: string;
  description?: string;
  path: string;
  method: ApiRouteMethod;
  emits: Emit[];
  virtualEmits?: Emit[];
  virtualSubscribes?: string[];
  flows?: string[];
  middleware?: ApiMiddleware<any, any, any>[];
  bodySchema?: StepSchemaInput;
  responseSchema?: Record<number, StepSchemaInput>;
  queryParams?: QueryParam[];
  /**
   * Files to include in the step bundle.
   * Needs to be relative to the step file.
   */
  includeFiles?: string[];
}
interface ApiRequest<TBody = unknown> {
  pathParams: Record<string, string>;
  queryParams: Record<string, string | string[]>;
  body: TBody;
  headers: Record<string, string | string[]>;
  /**
   * The raw unparsed request body as a string.
   * This is the same body that was sent but without type enforcement/parsing.
   */
  rawBody: string;
}
type ApiResponse<TStatus extends number = number, TBody = string | Buffer | Record<string, unknown>> = {
  status: TStatus;
  headers?: Record<string, string>;
  body: TBody;
};
type ApiRouteHandler<TRequestBody = unknown, TResponseBody extends ApiResponse<number, unknown> = ApiResponse<number, unknown>, TEmitData = never> = (req: ApiRequest<TRequestBody>, ctx: FlowContext<TEmitData>) => Promise<TResponseBody>;
type CronConfig = {
  type: 'cron';
  name: string;
  description?: string;
  cron: string;
  virtualEmits?: Emit[];
  virtualSubscribes?: string[];
  emits: Emit[];
  flows?: string[];
  /**
   * Files to include in the step bundle.
   * Needs to be relative to the step file.
   */
  includeFiles?: string[];
};
type CronHandler<TEmitData = never> = (ctx: FlowContext<TEmitData>) => Promise<void>;
/**
 * @deprecated Use `Handlers` instead.
 */
type StepHandler<T> = T extends EventConfig ? EventHandler<unknown, {
  topic: string;
  data: any;
}> : T extends ApiRouteConfig ? ApiRouteHandler<any, ApiResponse<number, any>, {
  topic: string;
  data: any;
}> : T extends CronConfig ? CronHandler<{
  topic: string;
  data: any;
}> : never;
type Event<TData = unknown> = {
  topic: string;
  data: TData;
  traceId: string;
  flows?: string[];
  logger?: Logger;
  tracer?: Tracer;
  messageGroupId?: string;
};
type Handler<TData = unknown> = (event: Event<TData>) => Promise<void>;
type SubscribeConfig<TData> = {
  event: string;
  handlerName: string;
  filePath: string;
  handler: Handler<TData>;
};
type UnsubscribeConfig = {
  filePath: string;
  event: string;
};
type StepConfig = EventConfig | NoopConfig | ApiRouteConfig | CronConfig;
type Step<TConfig extends StepConfig = StepConfig> = {
  filePath: string;
  version: string;
  config: TConfig;
};
type PluginStep<TConfig extends StepConfig = ApiRouteConfig> = Step<TConfig> & {
  handler?: ApiRouteHandler<any, any, any>;
};
type Flow = {
  name: string;
  description?: string;
  steps: Step[];
};
interface Handlers {}
declare module 'http' {
  interface IncomingMessage {
    authContext?: unknown | null;
    rawBody?: string;
  }
}
//# sourceMappingURL=types.d.ts.map
//#endregion
export { ApiMiddleware, ApiRequest, ApiResponse, ApiRouteConfig, ApiRouteHandler, ApiRouteMethod, CronConfig, CronHandler, Emit, EmitData, Emitter, Event, EventConfig, EventHandler, Flow, FlowContext, FlowContextStateStreams, Handler, HandlerConfig, Handlers, InfrastructureConfig, InternalStateManager, NoopConfig, PluginStep, QueryParam, QueueConfig, Step, StepConfig, StepHandler, StepSchemaInput, SubscribeConfig, UnsubscribeConfig, ZodInput };
//# sourceMappingURL=types.d.mts.map