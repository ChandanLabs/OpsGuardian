{"version":3,"file":"socket-server.mjs","names":["authRequest: StreamAuthRequest","rooms: Record<string, Map<string, WebSocket>>","subscriptions: Map<WebSocket, Map<string, string>>","authContexts: Map<WebSocket, unknown>","messageQueue: Promise<void>","resultMessage: EventMessage<typeof item>","resultMessage: EventMessage<typeof items>","message: Message"],"sources":["../../src/socket-server.ts"],"sourcesContent":["import type { Server } from 'http'\nimport { WebSocket, WebSocketServer } from 'ws'\nimport { globalLogger } from './logger'\nimport {\n  type BaseMessage,\n  type EventMessage,\n  getRoom,\n  type JoinMessage,\n  sendAccessDenied,\n  sendError,\n} from './socket-server/helpers'\nimport type { StreamAuthRequest } from './types/app-config-types'\n\ntype Message = { type: 'join' | 'leave'; data: JoinMessage }\n\ntype Props = {\n  server: Server\n  onJoin: <TData>(streamName: string, groupId: string, id: string) => Promise<TData>\n  onJoinGroup: <TData>(streamName: string, groupId: string) => Promise<TData[] | undefined>\n  authenticate?: (request: StreamAuthRequest) => Promise<unknown | null> | unknown | null\n  authorize?: (\n    subscription: { streamName: string; groupId: string; id?: string },\n    authContext?: unknown,\n  ) => Promise<boolean> | boolean\n}\n\nconst AUTH_ERROR_CODE = 401\nexport const createSocketServer = ({ server, onJoin, onJoinGroup, authenticate, authorize }: Props) => {\n  const socketServer = new WebSocketServer({\n    server,\n    verifyClient: async (info, callback) => {\n      if (authenticate) {\n        try {\n          const authRequest: StreamAuthRequest = {\n            headers: info.req.headers,\n            url: info.req.url,\n          }\n          info.req.authContext = await authenticate(authRequest)\n          callback(true)\n        } catch {\n          globalLogger.debug('[Socket Server] Authentication failed')\n          callback(false, AUTH_ERROR_CODE, 'Authentication failed')\n        }\n      } else {\n        callback(true)\n      }\n    },\n  })\n  const rooms: Record<string, Map<string, WebSocket>> = {}\n  const subscriptions: Map<WebSocket, Map<string, string>> = new Map()\n  const authContexts: Map<WebSocket, unknown> = new Map()\n\n  const isAuthorized = async (socket: WebSocket, data: BaseMessage): Promise<boolean> => {\n    if (!authorize) {\n      return true\n    }\n\n    try {\n      const authContext = authContexts.get(socket)\n      const result = await authorize(data, authContext)\n      return result !== false\n    } catch (error) {\n      sendError(socket, data, error as Error)\n      globalLogger.error('[Socket Server] Failed to authorize stream subscription')\n      return false\n    }\n  }\n\n  socketServer.on('connection', async (socket, request) => {\n    authContexts.set(socket, request.authContext)\n\n    subscriptions.set(socket, new Map())\n\n    // Message queue to ensure messages are processed in order\n    // This prevents race conditions where async join handlers allow leave to overtake join\n    let messageQueue: Promise<void> = Promise.resolve()\n\n    const processMessage = async (message: Message) => {\n      if (message.type === 'join') {\n        const authorized = await isAuthorized(socket, message.data)\n\n        if (!authorized) {\n          sendAccessDenied(socket, message.data)\n          return\n        }\n\n        const room = getRoom(message.data)\n\n        if (!rooms[room]) {\n          rooms[room] = new Map()\n        }\n\n        if (message.data.id) {\n          const item = await onJoin(message.data.streamName, message.data.groupId, message.data.id)\n\n          if (item) {\n            const resultMessage: EventMessage<typeof item> = {\n              timestamp: Date.now(),\n              streamName: message.data.streamName,\n              groupId: message.data.groupId,\n              id: message.data.id,\n              event: { type: 'sync', data: item },\n            }\n\n            socket.send(JSON.stringify(resultMessage))\n          }\n        } else {\n          const items = await onJoinGroup(message.data.streamName, message.data.groupId)\n\n          if (items) {\n            const resultMessage: EventMessage<typeof items> = {\n              timestamp: Date.now(),\n              streamName: message.data.streamName,\n              groupId: message.data.groupId,\n              event: { type: 'sync', data: items },\n            }\n\n            socket.send(JSON.stringify(resultMessage))\n          }\n        }\n\n        rooms[room].set(message.data.subscriptionId, socket)\n        subscriptions.get(socket)?.set(message.data.subscriptionId, room)\n      } else if (message.type === 'leave') {\n        if (!message.data.subscriptionId) {\n          globalLogger.error('[Socket Server] Subscription ID is required for leave message')\n          return\n        }\n\n        const room = getRoom(message.data)\n        if (rooms[room]) {\n          rooms[room].delete(message.data.subscriptionId)\n          if (rooms[room].size === 0) {\n            delete rooms[room]\n          }\n        }\n\n        subscriptions.get(socket)?.delete(message.data.subscriptionId)\n      }\n    }\n\n    socket.on('message', (payload: Buffer) => {\n      const message: Message = JSON.parse(payload.toString())\n      // Chain messages to ensure they are processed in order\n      messageQueue = messageQueue\n        .then(() => processMessage(message))\n        .catch((error) => {\n          globalLogger.error('[Socket Server] Error processing message', error)\n        })\n    })\n\n    socket.on('close', () => {\n      subscriptions.get(socket)?.forEach((room, subscriptionId) => {\n        rooms[room]?.delete(subscriptionId)\n\n        if (rooms[room]?.size === 0) {\n          delete rooms[room]\n        }\n      })\n      subscriptions.delete(socket)\n      authContexts.delete(socket)\n    })\n  })\n\n  const pushEvent = <TData>(message: Omit<EventMessage<TData>, 'timestamp'>) => {\n    const { groupId, streamName, id } = message\n    const groupRoom = getRoom({ streamName, groupId })\n    const eventMessage = JSON.stringify({ timestamp: Date.now(), ...message })\n\n    const safeSend = (socket: WebSocket) => {\n      if (socket.readyState === WebSocket.OPEN) {\n        try {\n          socket.send(eventMessage)\n        } catch (error) {\n          globalLogger.debug('[Socket Server] Failed to send message to socket', error)\n        }\n      }\n    }\n\n    if (rooms[groupRoom]) {\n      rooms[groupRoom].forEach(safeSend)\n    }\n\n    if (id) {\n      const itemRoom = getRoom({ groupId, streamName, id })\n\n      if (rooms[itemRoom]) {\n        rooms[itemRoom].forEach(safeSend)\n      }\n    }\n  }\n\n  return { pushEvent, socketServer }\n}\n"],"mappings":";;;;;AA0BA,MAAM,kBAAkB;AACxB,MAAa,sBAAsB,EAAE,QAAQ,QAAQ,aAAa,cAAc,gBAAuB;CACrG,MAAM,eAAe,IAAI,gBAAgB;EACvC;EACA,cAAc,OAAO,MAAM,aAAa;AACtC,OAAI,aACF,KAAI;IACF,MAAMA,cAAiC;KACrC,SAAS,KAAK,IAAI;KAClB,KAAK,KAAK,IAAI;KACf;AACD,SAAK,IAAI,cAAc,MAAM,aAAa,YAAY;AACtD,aAAS,KAAK;WACR;AACN,iBAAa,MAAM,wCAAwC;AAC3D,aAAS,OAAO,iBAAiB,wBAAwB;;OAG3D,UAAS,KAAK;;EAGnB,CAAC;CACF,MAAMC,QAAgD,EAAE;CACxD,MAAMC,gCAAqD,IAAI,KAAK;CACpE,MAAMC,+BAAwC,IAAI,KAAK;CAEvD,MAAM,eAAe,OAAO,QAAmB,SAAwC;AACrF,MAAI,CAAC,UACH,QAAO;AAGT,MAAI;AAGF,UADe,MAAM,UAAU,MADX,aAAa,IAAI,OAAO,CACK,KAC/B;WACX,OAAO;AACd,aAAU,QAAQ,MAAM,MAAe;AACvC,gBAAa,MAAM,0DAA0D;AAC7E,UAAO;;;AAIX,cAAa,GAAG,cAAc,OAAO,QAAQ,YAAY;AACvD,eAAa,IAAI,QAAQ,QAAQ,YAAY;AAE7C,gBAAc,IAAI,wBAAQ,IAAI,KAAK,CAAC;EAIpC,IAAIC,eAA8B,QAAQ,SAAS;EAEnD,MAAM,iBAAiB,OAAO,YAAqB;AACjD,OAAI,QAAQ,SAAS,QAAQ;AAG3B,QAAI,CAFe,MAAM,aAAa,QAAQ,QAAQ,KAAK,EAE1C;AACf,sBAAiB,QAAQ,QAAQ,KAAK;AACtC;;IAGF,MAAM,OAAO,QAAQ,QAAQ,KAAK;AAElC,QAAI,CAAC,MAAM,MACT,OAAM,wBAAQ,IAAI,KAAK;AAGzB,QAAI,QAAQ,KAAK,IAAI;KACnB,MAAM,OAAO,MAAM,OAAO,QAAQ,KAAK,YAAY,QAAQ,KAAK,SAAS,QAAQ,KAAK,GAAG;AAEzF,SAAI,MAAM;MACR,MAAMC,gBAA2C;OAC/C,WAAW,KAAK,KAAK;OACrB,YAAY,QAAQ,KAAK;OACzB,SAAS,QAAQ,KAAK;OACtB,IAAI,QAAQ,KAAK;OACjB,OAAO;QAAE,MAAM;QAAQ,MAAM;QAAM;OACpC;AAED,aAAO,KAAK,KAAK,UAAU,cAAc,CAAC;;WAEvC;KACL,MAAM,QAAQ,MAAM,YAAY,QAAQ,KAAK,YAAY,QAAQ,KAAK,QAAQ;AAE9E,SAAI,OAAO;MACT,MAAMC,gBAA4C;OAChD,WAAW,KAAK,KAAK;OACrB,YAAY,QAAQ,KAAK;OACzB,SAAS,QAAQ,KAAK;OACtB,OAAO;QAAE,MAAM;QAAQ,MAAM;QAAO;OACrC;AAED,aAAO,KAAK,KAAK,UAAU,cAAc,CAAC;;;AAI9C,UAAM,MAAM,IAAI,QAAQ,KAAK,gBAAgB,OAAO;AACpD,kBAAc,IAAI,OAAO,EAAE,IAAI,QAAQ,KAAK,gBAAgB,KAAK;cACxD,QAAQ,SAAS,SAAS;AACnC,QAAI,CAAC,QAAQ,KAAK,gBAAgB;AAChC,kBAAa,MAAM,gEAAgE;AACnF;;IAGF,MAAM,OAAO,QAAQ,QAAQ,KAAK;AAClC,QAAI,MAAM,OAAO;AACf,WAAM,MAAM,OAAO,QAAQ,KAAK,eAAe;AAC/C,SAAI,MAAM,MAAM,SAAS,EACvB,QAAO,MAAM;;AAIjB,kBAAc,IAAI,OAAO,EAAE,OAAO,QAAQ,KAAK,eAAe;;;AAIlE,SAAO,GAAG,YAAY,YAAoB;GACxC,MAAMC,UAAmB,KAAK,MAAM,QAAQ,UAAU,CAAC;AAEvD,kBAAe,aACZ,WAAW,eAAe,QAAQ,CAAC,CACnC,OAAO,UAAU;AAChB,iBAAa,MAAM,4CAA4C,MAAM;KACrE;IACJ;AAEF,SAAO,GAAG,eAAe;AACvB,iBAAc,IAAI,OAAO,EAAE,SAAS,MAAM,mBAAmB;AAC3D,UAAM,OAAO,OAAO,eAAe;AAEnC,QAAI,MAAM,OAAO,SAAS,EACxB,QAAO,MAAM;KAEf;AACF,iBAAc,OAAO,OAAO;AAC5B,gBAAa,OAAO,OAAO;IAC3B;GACF;CAEF,MAAM,aAAoB,YAAoD;EAC5E,MAAM,EAAE,SAAS,YAAY,OAAO;EACpC,MAAM,YAAY,QAAQ;GAAE;GAAY;GAAS,CAAC;EAClD,MAAM,eAAe,KAAK,UAAU;GAAE,WAAW,KAAK,KAAK;GAAE,GAAG;GAAS,CAAC;EAE1E,MAAM,YAAY,WAAsB;AACtC,OAAI,OAAO,eAAe,UAAU,KAClC,KAAI;AACF,WAAO,KAAK,aAAa;YAClB,OAAO;AACd,iBAAa,MAAM,oDAAoD,MAAM;;;AAKnF,MAAI,MAAM,WACR,OAAM,WAAW,QAAQ,SAAS;AAGpC,MAAI,IAAI;GACN,MAAM,WAAW,QAAQ;IAAE;IAAS;IAAY;IAAI,CAAC;AAErD,OAAI,MAAM,UACR,OAAM,UAAU,QAAQ,SAAS;;;AAKvC,QAAO;EAAE;EAAW;EAAc"}