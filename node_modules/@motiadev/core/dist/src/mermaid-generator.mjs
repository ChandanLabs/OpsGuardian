import { isApiStep, isCronStep, isEventStep, isNoopStep } from "./guards.mjs";
import fs from "fs";
import path from "path";

//#region src/mermaid-generator.ts
const ensureDiagramsDirectory = (diagramsDir) => {
	if (!fs.existsSync(diagramsDir)) fs.mkdirSync(diagramsDir, { recursive: true });
};
const getNodeId = (step, baseDir) => {
	return path.relative(baseDir, step.filePath).replace(/\.(ts|js|tsx|jsx)$/, "").replace(/[^a-zA-Z0-9]/g, "_");
};
const getNodeLabel = (step) => {
	const displayName = step.config.name || path.basename(step.filePath, path.extname(step.filePath));
	let prefix = "";
	if (isApiStep(step)) prefix = "ðŸŒ ";
	else if (isEventStep(step)) prefix = "âš¡ ";
	else if (isCronStep(step)) prefix = "â° ";
	else if (isNoopStep(step)) prefix = "âš™ï¸ ";
	return `["${prefix}${displayName}"]`;
};
const getNodeStyle = (step) => {
	if (isApiStep(step)) return ":::apiStyle";
	if (isEventStep(step)) return ":::eventStyle";
	if (isCronStep(step)) return ":::cronStyle";
	if (isNoopStep(step)) return ":::noopStyle";
	return "";
};
const generateConnections = (emits, sourceStep, steps, sourceId, baseDir) => {
	const connections = [];
	if (!emits || !Array.isArray(emits) || emits.length === 0) return "";
	const stepSubscribesToTopic = (step, topic) => {
		if (isEventStep(step) && step.config.subscribes && Array.isArray(step.config.subscribes) && step.config.subscribes.includes(topic)) return true;
		if ((isNoopStep(step) || isApiStep(step)) && step.config.virtualSubscribes && Array.isArray(step.config.virtualSubscribes) && step.config.virtualSubscribes.includes(topic)) return true;
		return false;
	};
	emits.forEach((emit) => {
		const topic = typeof emit === "string" ? emit : emit.topic;
		const label = typeof emit === "string" ? topic : emit.label || topic;
		steps.forEach((targetStep) => {
			if (stepSubscribesToTopic(targetStep, topic)) {
				const targetId = getNodeId(targetStep, baseDir);
				connections.push(`    ${sourceId} -->|${label}| ${targetId}`);
			}
		});
	});
	return connections.join("\n");
};
const generateFlowDiagram = (flowName, steps, baseDir) => {
	let diagram = `flowchart TD\n`;
	diagram += [
		`    classDef apiStyle fill:#f96,stroke:#333,stroke-width:2px,color:#fff`,
		`    classDef eventStyle fill:#69f,stroke:#333,stroke-width:2px,color:#fff`,
		`    classDef cronStyle fill:#9c6,stroke:#333,stroke-width:2px,color:#fff`,
		`    classDef noopStyle fill:#3f3a50,stroke:#333,stroke-width:2px,color:#fff`
	].join("\n") + "\n";
	if (!steps || steps.length === 0) return diagram + "    empty[No steps in this flow]";
	steps.forEach((step) => {
		const nodeId = getNodeId(step, baseDir);
		const nodeLabel = getNodeLabel(step);
		const nodeStyle = getNodeStyle(step);
		diagram += `    ${nodeId}${nodeLabel}${nodeStyle}\n`;
	});
	let connectionsStr = "";
	steps.forEach((sourceStep) => {
		const sourceId = getNodeId(sourceStep, baseDir);
		function processEmissions(emissionsArray, stepSource, stepsCollection, sourceIdentifier) {
			if (emissionsArray && Array.isArray(emissionsArray)) return generateConnections(emissionsArray, stepSource, stepsCollection, sourceIdentifier, baseDir);
			return "";
		}
		const supportsEmits = isApiStep(sourceStep) || isEventStep(sourceStep) || isCronStep(sourceStep);
		const supportsVirtualEmits = supportsEmits || isNoopStep(sourceStep);
		if (supportsEmits) {
			const emitConnections = processEmissions(sourceStep.config.emits, sourceStep, steps, sourceId);
			if (emitConnections) connectionsStr += emitConnections + "\n";
		}
		if (supportsVirtualEmits) {
			const virtualEmitConnections = processEmissions(sourceStep.config.virtualEmits, sourceStep, steps, sourceId);
			if (virtualEmitConnections) connectionsStr += virtualEmitConnections + "\n";
		}
	});
	diagram += connectionsStr;
	return diagram;
};
const saveDiagram = (diagramsDir, flowName, diagram) => {
	const filePath = path.join(diagramsDir, `${flowName}.mmd`);
	fs.writeFileSync(filePath, diagram);
};
const removeDiagram = (diagramsDir, flowName) => {
	const filePath = path.join(diagramsDir, `${flowName}.mmd`);
	if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
};
const generateAndSaveDiagram = (diagramsDir, flowName, flow, baseDir) => {
	saveDiagram(diagramsDir, flowName, generateFlowDiagram(flowName, flow.steps, baseDir));
};
const createMermaidGenerator = (baseDir) => {
	const diagramsDir = path.join(baseDir, ".mermaid");
	ensureDiagramsDirectory(diagramsDir);
	const handleFlowCreated = (flowName, flow) => {
		generateAndSaveDiagram(diagramsDir, flowName, flow, baseDir);
	};
	const handleFlowUpdated = (flowName, flow) => {
		generateAndSaveDiagram(diagramsDir, flowName, flow, baseDir);
	};
	const handleFlowRemoved = (flowName) => {
		removeDiagram(diagramsDir, flowName);
	};
	const initialize = (lockedData) => {
		lockedData.on("flow-created", (flowName) => {
			handleFlowCreated(flowName, lockedData.flows[flowName]);
		});
		lockedData.on("flow-updated", (flowName) => {
			handleFlowUpdated(flowName, lockedData.flows[flowName]);
		});
		lockedData.on("flow-removed", (flowName) => {
			handleFlowRemoved(flowName);
		});
		if (lockedData.flows && typeof lockedData.flows === "object") Object.entries(lockedData.flows).forEach(([flowName, flow]) => {
			generateAndSaveDiagram(diagramsDir, flowName, flow, baseDir);
		});
	};
	return { initialize };
};

//#endregion
export { createMermaidGenerator };
//# sourceMappingURL=mermaid-generator.mjs.map