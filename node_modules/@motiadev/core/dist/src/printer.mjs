import { isApiStep, isCronStep, isEventStep, isNoopStep } from "./guards.mjs";
import pc from "picocolors";
import path from "path";

//#region src/printer.ts
const stepTag = pc.bold(pc.magenta("Step"));
const flowTag = pc.bold(pc.blue("Flow"));
const streamTag = pc.bold(pc.green("Stream"));
const registered = pc.green("➜ [REGISTERED]");
const building = pc.yellow("⚡ [BUILDING]");
const built = pc.green("✓ [BUILT]");
const updated = pc.yellow("➜ [UPDATED]");
const removed = pc.red("➜ [REMOVED]");
const invalidEmit = pc.red("➜ [INVALID EMIT]");
const error = pc.red("[ERROR]");
const warning = pc.yellow("[WARNING]");
const warnIcon = pc.yellow("⚠");
const infoIcon = pc.blue("ℹ");
const errorIcon = pc.red("✖");
var Printer = class {
	constructor(baseDir) {
		this.baseDir = baseDir;
		this.stepTag = stepTag;
		this.flowTag = flowTag;
		this.registered = registered;
		this.building = building;
		this.built = built;
		this.updated = updated;
		this.removed = removed;
	}
	printEventInputValidationError(emit, details) {
		const emitPath = pc.bold(pc.cyan(`Emit ${emit.topic}`));
		console.log(`${warnIcon} ${warning} ${emitPath} validation issues:`);
		if (!(details.missingFields?.length || details.extraFields?.length || details.typeMismatches?.length)) {
			console.log(`${pc.yellow("│")} No issues found.`);
			console.log(`${pc.yellow("└─")} Validation passed.`);
			return;
		}
		if (details.missingFields?.length) console.log(`${pc.yellow("│")} ${pc.yellow(`⚠ Missing fields: ${details.missingFields.join(", ")}`)}`);
		if (details.extraFields?.length) console.log(`${pc.yellow("│")} ${pc.yellow(`⚠ Extra fields: ${details.extraFields.join(", ")}`)}`);
		if (details.typeMismatches?.length) console.log(`${pc.yellow("│")} ${pc.yellow(`⚠ Type mismatches: ${details.typeMismatches.join(", ")}`)}`);
		console.log(`${pc.yellow("└─")} ${pc.yellow("Payload does not match schema.")}`);
	}
	printInvalidEmit(step, emit) {
		console.log(`${invalidEmit} ${stepTag} ${this.getStepType(step)} ${this.getStepPath(step)} tried to emit an event not defined in the step config: ${pc.yellow(emit)}`);
	}
	printStepCreated(step) {
		console.log(`${registered} ${stepTag} ${this.getStepType(step)} ${this.getStepPath(step)} registered`);
	}
	printStepUpdated(step) {
		console.log(`${updated} ${stepTag} ${this.getStepType(step)} ${this.getStepPath(step)} updated`);
	}
	printStepRemoved(step) {
		console.log(`${removed} ${stepTag} ${this.getStepType(step)} ${this.getStepPath(step)} removed`);
	}
	printFlowCreated(flowName) {
		console.log(`${registered} ${flowTag} ${pc.bold(pc.cyan(flowName))} registered`);
	}
	printFlowUpdated(flowName) {
		console.log(`${updated} ${flowTag} ${pc.bold(pc.cyan(flowName))} updated`);
	}
	printFlowRemoved(flowName) {
		console.log(`${removed} ${flowTag} ${pc.bold(pc.cyan(flowName))} removed`);
	}
	printStreamCreated(stream) {
		console.log(`${registered} ${streamTag} ${this.getStreamPath(stream)} registered`);
	}
	printStreamUpdated(stream) {
		console.log(`${updated} ${streamTag} ${this.getStreamPath(stream)} updated`);
	}
	printStreamRemoved(stream) {
		console.log(`${removed} ${streamTag} ${this.getStreamPath(stream)} removed`);
	}
	printInvalidEmitConfiguration(step, emit) {
		console.log(`${warnIcon} ${warning} ${stepTag} ${this.getStepType(step)} ${this.getStepPath(step)} emits to ${pc.yellow(emit)}, but there is no subscriber defined`);
	}
	printInvalidSchema(topic, step) {
		console.log(`${error} Topic ${pc.bold(pc.blue(topic))} has incompatible schemas in the following steps:`);
		step.forEach((step$1) => {
			console.log(`${pc.red("  ✖")} ${this.getStepPath(step$1)}`);
		});
	}
	printValidationError(stepPath, validationError) {
		const relativePath = this.getRelativePath(stepPath);
		console.log(`${error} ${pc.bold(pc.cyan(relativePath))}`);
		validationError.errors?.forEach((error$1) => {
			if (error$1.path) console.log(`${pc.red("│")} ${pc.yellow(`✖ ${error$1.path}`)}: ${error$1.message}`);
			else console.log(`${pc.red("│")} ${pc.yellow("✖")} ${error$1.message}`);
		});
		console.log(`${pc.red("└─")} ${pc.red(validationError.error)}  `);
	}
	getRelativePath(filePath) {
		return path.relative(this.baseDir, filePath);
	}
	getStepType(step) {
		if (isApiStep(step)) return pc.gray("(API)");
		if (isEventStep(step)) return pc.gray("(Event)");
		if (isCronStep(step)) return pc.gray("(Cron)");
		if (isNoopStep(step)) return pc.gray("(Noop)");
		return pc.gray("(Unknown)");
	}
	getStepPath(step) {
		const stepPath = this.getRelativePath(step.filePath);
		return pc.bold(pc.cyan(stepPath));
	}
	getStreamPath(stream) {
		const streamPath = this.getRelativePath(stream.filePath);
		return pc.bold(pc.magenta(streamPath));
	}
	printPluginLog(message) {
		const pluginTag = pc.bold(pc.cyan("[motia-plugins]"));
		console.log(`${infoIcon} ${pluginTag} ${message}`);
	}
	printPluginWarn(message) {
		const pluginTag = pc.bold(pc.cyan("[motia-plugins]"));
		console.warn(`${warnIcon} ${pluginTag} ${pc.yellow(message)}`);
	}
	printPluginError(message, ...args) {
		const pluginTag = pc.bold(pc.cyan("[motia-plugins]"));
		console.error(`${errorIcon} ${pluginTag} ${pc.red(message)}`, ...args);
	}
};
var NoPrinter = class extends Printer {
	constructor() {
		super("");
	}
	printEventInputValidationError() {}
	printInvalidEmit() {}
	printStepCreated() {}
	printStepUpdated() {}
	printStepRemoved() {}
	printFlowCreated() {}
	printFlowUpdated() {}
	printFlowRemoved() {}
	printStepType() {}
	printStepPath() {}
	printStreamCreated() {}
	printStreamUpdated() {}
	printStreamRemoved() {}
	printPluginLog() {}
	printPluginWarn() {}
	printPluginError() {}
};

//#endregion
export { NoPrinter, Printer };
//# sourceMappingURL=printer.mjs.map