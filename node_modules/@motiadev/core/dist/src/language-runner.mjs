import path from "path";
import { createRequire } from "module";
import { fileURLToPath } from "url";

//#region src/language-runner.ts
const __dirname = path.dirname(fileURLToPath(import.meta.url));
const require = createRequire(import.meta.url);
const getTsxPath = () => {
	try {
		const tsxModule = require.resolve("tsx/package.json");
		return path.join(path.dirname(tsxModule), "dist", "cli.mjs");
	} catch {
		return "tsx";
	}
};
const getLanguageBasedRunner = (stepFilePath = "", overrides) => {
	const isPython = stepFilePath.endsWith(".py");
	const isRuby = stepFilePath.endsWith(".rb");
	const isNode = stepFilePath.endsWith(".js") || stepFilePath.endsWith(".ts");
	if (isPython) return {
		runner: path.join(__dirname, "python", overrides?.python ?? "python-runner.py"),
		command: "python",
		args: []
	};
	else if (isRuby) return {
		runner: path.join(__dirname, "ruby", overrides?.ruby ?? "ruby-runner.rb"),
		command: "ruby",
		args: []
	};
	else if (isNode) {
		const defaultNodeOverrides = overrides?.node;
		const isTypeScript = stepFilePath.endsWith(".ts");
		if (process.env._MOTIA_TEST_MODE === "true") {
			const runnerFile = defaultNodeOverrides?.ts ?? "node-runner.ts";
			return {
				runner: path.join(__dirname, "node", runnerFile),
				command: "node",
				args: [
					"--loader",
					"ts-node/esm",
					"--no-warnings=ExperimentalWarning"
				]
			};
		}
		const jsRunner = path.join(__dirname, "node", defaultNodeOverrides?.js ?? "node-runner.mjs");
		if (isTypeScript) return {
			runner: jsRunner,
			command: "node",
			args: []
		};
		const tsxPath = getTsxPath();
		if (tsxPath !== "tsx") return {
			runner: jsRunner,
			command: "node",
			args: [tsxPath]
		};
		return {
			runner: jsRunner,
			command: tsxPath,
			args: []
		};
	}
	throw Error(`Unsupported file extension ${stepFilePath}`);
};

//#endregion
export { getLanguageBasedRunner };
//# sourceMappingURL=language-runner.mjs.map