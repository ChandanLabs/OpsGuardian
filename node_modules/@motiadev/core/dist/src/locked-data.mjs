import { isApiStep, isCronStep, isEventStep } from "./guards.mjs";
import { PLUGIN_FLOW_ID } from "./motia.mjs";
import { validateStep } from "./step-validator.mjs";
import { generateTypeFromSchema } from "./types/generate-type-from-schema.mjs";
import { generateTypesFromSteps, generateTypesFromStreams, generateTypesString } from "./types/generate-types.mjs";
import fs from "fs";
import path from "path";

//#region src/locked-data.ts
var LockedData = class {
	constructor(baseDir, streamAdapter, printer, redisClient) {
		this.baseDir = baseDir;
		this.streamAdapter = streamAdapter;
		this.printer = printer;
		this.redisClient = redisClient;
		this.flows = {};
		this.activeSteps = [];
		this.devSteps = [];
		this.stepsMap = {};
		this.handlers = {
			"flow-created": [],
			"flow-removed": [],
			"flow-updated": []
		};
		this.stepHandlers = {
			"step-created": [],
			"step-removed": [],
			"step-updated": []
		};
		this.streamHandlers = {
			"stream-created": [],
			"stream-removed": [],
			"stream-updated": []
		};
		this.streams = {};
	}
	applyStreamWrapper(streamWrapper) {
		this.streamWrapper = streamWrapper;
	}
	setStreamAuthConfig(config) {
		this.streamAuthConfig = config ? { authenticate: config.authenticate } : void 0;
		this.streamAuthContextType = config?.contextSchema ? generateTypeFromSchema(config.contextSchema) : void 0;
	}
	getStreamAuthConfig() {
		return this.streamAuthConfig;
	}
	saveTypes() {
		const typesString = generateTypesString(generateTypesFromSteps(this.activeSteps, this.printer), generateTypesFromStreams(this.streams), this.streamAuthContextType);
		fs.writeFileSync(path.join(this.baseDir, "types.d.ts"), typesString);
	}
	on(event, handler) {
		this.handlers[event].push(handler);
	}
	onStep(event, handler) {
		this.stepHandlers[event].push(handler);
	}
	onStream(event, handler) {
		this.streamHandlers[event].push(handler);
	}
	getActiveSteps() {
		return this.activeSteps.filter((step) => !step.config.flows?.includes(PLUGIN_FLOW_ID));
	}
	eventSteps() {
		return this.getActiveSteps().filter(isEventStep);
	}
	apiSteps() {
		return this.getActiveSteps().filter(isApiStep);
	}
	cronSteps() {
		return this.getActiveSteps().filter(isCronStep);
	}
	pythonSteps() {
		return this.getActiveSteps().filter((step) => step.filePath.endsWith(".py"));
	}
	tsSteps() {
		return this.getActiveSteps().filter((step) => step.filePath.endsWith(".ts"));
	}
	getStreams() {
		const streams = {};
		for (const [key, value] of Object.entries(this.streams)) streams[key] = value.factory;
		return streams;
	}
	listStreams() {
		return Object.values(this.streams);
	}
	getStreamByName(streamName) {
		return this.streams[streamName];
	}
	findStream(path$1) {
		return Object.values(this.streams).find((stream) => stream.filePath === path$1);
	}
	updateStep(oldStep, newStep, options = {}) {
		if (!this.isValidStep(newStep)) {
			this.deleteStep(oldStep);
			return false;
		}
		if (oldStep.config.type !== newStep.config.type) {
			this.activeSteps = this.activeSteps.filter((s) => s.filePath !== oldStep.filePath);
			this.devSteps = this.devSteps.filter((s) => s.filePath !== oldStep.filePath);
			if (newStep.config.type === "noop") this.devSteps.push(newStep);
			else this.activeSteps.push(newStep);
		}
		const savedStep = this.stepsMap[newStep.filePath];
		const addedFlows = newStep.config.flows?.filter((flowName) => !oldStep.config.flows?.includes(flowName)) ?? [];
		const removedFlows = oldStep.config.flows?.filter((flowName) => !newStep.config.flows?.includes(flowName)) ?? [];
		const untouchedFlows = oldStep.config.flows?.filter((flowName) => newStep.config.flows?.includes(flowName)) ?? [];
		savedStep.config = newStep.config;
		untouchedFlows.forEach((flowName) => this.onFlowUpdated(flowName));
		for (const flowName of addedFlows) if (!this.flows[flowName]) this.createFlow(flowName).steps.push(savedStep);
		else {
			this.flows[flowName].steps.push(savedStep);
			this.onFlowUpdated(flowName);
		}
		for (const flowName of removedFlows) {
			const flowSteps = this.flows[flowName].steps;
			this.flows[flowName].steps = flowSteps.filter(({ filePath }) => filePath !== newStep.filePath);
			if (this.flows[flowName].steps.length === 0) this.removeFlow(flowName);
			else this.onFlowUpdated(flowName);
		}
		if (!options.disableTypeCreation) this.saveTypes();
		this.stepHandlers["step-updated"].forEach((handler) => handler(newStep));
		this.printer.printStepUpdated(newStep);
		return true;
	}
	createStep(step, options = {}) {
		if (!this.isValidStep(step)) return false;
		this.stepsMap[step.filePath] = step;
		if (step.config.type === "noop") this.devSteps.push(step);
		else this.activeSteps.push(step);
		for (const flowName of step.config.flows ?? []) if (!this.flows[flowName]) this.createFlow(flowName).steps.push(step);
		else {
			this.flows[flowName].steps.push(step);
			this.onFlowUpdated(flowName);
		}
		if (!options.disableTypeCreation) this.saveTypes();
		this.stepHandlers["step-created"].forEach((handler) => handler(step));
		this.printer.printStepCreated(step);
		return true;
	}
	deleteStep(step, options = {}) {
		this.activeSteps = this.activeSteps.filter(({ filePath }) => filePath !== step.filePath);
		this.devSteps = this.devSteps.filter(({ filePath }) => filePath !== step.filePath);
		delete this.stepsMap[step.filePath];
		for (const flowName of step.config.flows ?? []) {
			const stepFlows = this.flows[flowName]?.steps;
			if (stepFlows) this.flows[flowName].steps = stepFlows.filter(({ filePath }) => filePath !== step.filePath);
			if (this.flows[flowName].steps.length === 0) this.removeFlow(flowName);
			else this.onFlowUpdated(flowName);
		}
		if (!options.disableTypeCreation) this.saveTypes();
		this.stepHandlers["step-removed"].forEach((handler) => handler(step));
		this.printer.printStepRemoved(step);
	}
	createFactoryWrapper(stream, factory) {
		return () => {
			return (this.streamWrapper ? this.streamWrapper(stream.config.name, factory) : factory)();
		};
	}
	createStream(baseStream, options = {}) {
		const stream = baseStream;
		this.streams[stream.config.name] = stream;
		this.streamHandlers["stream-created"].forEach((handler) => handler(stream));
		if (stream.config.baseConfig.storageType === "default") stream.factory = this.createFactoryWrapper(stream, () => this.createStreamAdapter(stream.config.name));
		else stream.factory = this.createFactoryWrapper(stream, stream.config.baseConfig.factory);
		if (!stream.hidden) {
			this.printer.printStreamCreated(stream);
			if (!options.disableTypeCreation) this.saveTypes();
		}
		return stream.factory;
	}
	deleteStream(stream, options = {}) {
		Object.entries(this.streams).forEach(([streamName, { filePath }]) => {
			if (stream.filePath === filePath) delete this.streams[streamName];
		});
		this.streamHandlers["stream-removed"].forEach((handler) => handler(stream));
		if (!stream.hidden) {
			this.printer.printStreamRemoved(stream);
			if (!options.disableTypeCreation) this.saveTypes();
		}
	}
	updateStream(oldStream, stream, options = {}) {
		if (oldStream.config.name !== stream.config.name) delete this.streams[oldStream.config.name];
		if (stream.config.baseConfig.storageType === "default") stream.factory = this.createFactoryWrapper(stream, () => this.createStreamAdapter(stream.config.name));
		else stream.factory = this.createFactoryWrapper(stream, stream.config.baseConfig.factory);
		this.streams[stream.config.name] = stream;
		this.streamHandlers["stream-updated"].forEach((handler) => handler(stream));
		if (!stream.hidden) {
			this.printer.printStreamUpdated(stream);
			if (!options.disableTypeCreation) this.saveTypes();
		}
	}
	createFlow(flowName) {
		const flow = {
			name: flowName,
			description: "",
			steps: []
		};
		this.flows[flowName] = flow;
		this.handlers["flow-created"].forEach((handler) => handler(flowName));
		this.printer.printFlowCreated(flowName);
		return flow;
	}
	removeFlow(flowName) {
		delete this.flows[flowName];
		this.handlers["flow-removed"].forEach((handler) => handler(flowName));
		this.printer.printFlowRemoved(flowName);
	}
	onFlowUpdated(flowName) {
		this.handlers["flow-updated"].forEach((handler) => handler(flowName));
	}
	isValidStep(step) {
		const validationResult = validateStep(step);
		if (!validationResult.success) this.printer.printValidationError(step.filePath, validationResult);
		return validationResult.success;
	}
	createStreamAdapter(streamName) {
		return this.streamAdapter.createStream(streamName);
	}
};

//#endregion
export { LockedData };
//# sourceMappingURL=locked-data.mjs.map