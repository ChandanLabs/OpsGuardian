{"version":3,"file":"queue-manager.mjs","names":["attempts: number","queuedMessage: QueuedMessage<TData>","result: Record<string, QueueMetrics>"],"sources":["../../src/queue-manager.ts"],"sourcesContent":["import { randomUUID } from 'crypto'\nimport { EventEmitter } from 'events'\nimport { globalLogger, type Logger } from './logger'\nimport type { Event, Handler, QueueConfig } from './types'\n\nexport class QueueError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'QueueError'\n  }\n}\n\nexport class HandlerTimeoutError extends QueueError {\n  constructor(message: string) {\n    super(message)\n    this.name = 'HandlerTimeoutError'\n  }\n}\n\nexport class MaxRetriesError extends QueueError {\n  constructor(\n    message: string,\n    public readonly attempts: number,\n  ) {\n    super(message)\n    this.name = 'MaxRetriesError'\n  }\n}\n\ntype QueuedMessage<TData = unknown> = {\n  id: string\n  event: Event<TData>\n  attempts: number\n  visibleAt: number\n  messageGroupId?: string\n  queueConfig: QueueConfig\n  subscriptionId: string\n  internalSubscriptionId: string\n}\n\ntype QueueSubscription = {\n  handler: Handler\n  queueConfig: QueueConfig\n  subscriptionId: string\n  internalSubscriptionId: string\n}\n\nexport type QueueMetrics = {\n  queueDepth: number\n  processingCount: number\n  retriesCount: number\n  dlqCount: number\n}\n\nexport class QueueManager {\n  private logger: Logger\n  private queues: Record<string, QueuedMessage[]> = {}\n  private subscriptions: Record<string, QueueSubscription[]> = {}\n  private lockedGroups: Set<string> = new Set()\n  private queueEmitter = new EventEmitter()\n  private scheduledTimeouts: Map<string, NodeJS.Timeout> = new Map()\n  private metrics: Map<string, QueueMetrics> = new Map()\n  private processingMessages: Set<string> = new Set()\n\n  constructor(logger?: Logger) {\n    this.logger = logger || globalLogger\n    this.queueEmitter.on('process', (topic: string) => {\n      this.processQueue(topic)\n    })\n  }\n\n  private initMetrics(topic: string): void {\n    if (!this.metrics.has(topic)) {\n      this.metrics.set(topic, {\n        queueDepth: 0,\n        processingCount: 0,\n        retriesCount: 0,\n        dlqCount: 0,\n      })\n    }\n  }\n\n  private updateMetric(topic: string, key: keyof QueueMetrics, delta: number): void {\n    this.initMetrics(topic)\n    const metrics = this.metrics.get(topic)!\n    metrics[key] = Math.max(0, metrics[key] + delta)\n  }\n\n  private processQueue(topic: string): void {\n    const queue = this.queues[topic]\n    if (!queue || queue.length === 0) {\n      return\n    }\n\n    const now = Date.now()\n    const visibleMessages = queue.filter((msg) => msg.visibleAt <= now && !this.processingMessages.has(msg.id))\n\n    for (const message of visibleMessages) {\n      if (message.queueConfig.type === 'fifo' && message.messageGroupId) {\n        const lockKey = `${topic}:${message.messageGroupId}`\n        if (this.lockedGroups.has(lockKey)) {\n          continue\n        }\n\n        this.processingMessages.add(message.id)\n        this.lockedGroups.add(lockKey)\n        void this.processMessage(topic, message, lockKey)\n      } else {\n        this.processingMessages.add(message.id)\n        void this.processMessage(topic, message)\n      }\n    }\n  }\n\n  private async processMessage(topic: string, message: QueuedMessage, lockKey?: string): Promise<void> {\n    const handlers = this.subscriptions[topic] || []\n    const handler =\n      handlers.find((s) => s.internalSubscriptionId === message.internalSubscriptionId) ||\n      handlers.find((s) => s.subscriptionId === message.subscriptionId) ||\n      handlers[0]\n\n    if (!handler) {\n      this.processingMessages.delete(message.id)\n      this.removeMessageFromQueue(topic, message.id)\n      if (lockKey) {\n        this.lockedGroups.delete(lockKey)\n      }\n      return\n    }\n\n    const handlerChanged = message.internalSubscriptionId !== handler.internalSubscriptionId\n    if (handlerChanged && message.attempts > 0) {\n      message.attempts = 0\n      message.internalSubscriptionId = handler.internalSubscriptionId\n      message.subscriptionId = handler.subscriptionId\n      message.visibleAt = Date.now()\n    }\n\n    this.updateMetric(topic, 'processingCount', 1)\n\n    try {\n      await handler.handler(message.event)\n      this.updateMetric(topic, 'processingCount', -1)\n      this.processingMessages.delete(message.id)\n      this.removeMessageFromQueue(topic, message.id)\n\n      if (lockKey) {\n        this.lockedGroups.delete(lockKey)\n      }\n      this.scheduleProcessing(topic, 0)\n    } catch (error) {\n      this.updateMetric(topic, 'processingCount', -1)\n      this.processingMessages.delete(message.id)\n      message.attempts++\n\n      if (message.attempts >= handler.queueConfig.maxRetries) {\n        const maxRetriesError = new MaxRetriesError(\n          `Message failed after ${message.attempts} attempts`,\n          message.attempts,\n        )\n        this.logger.error('[Queue DLQ] Message moved to dead-letter queue after max retries', {\n          topic,\n          messageId: message.id,\n          attempts: message.attempts,\n          originalError: error instanceof Error ? error.message : 'Unknown error',\n          error: maxRetriesError.message,\n        })\n\n        this.updateMetric(topic, 'dlqCount', 1)\n        this.removeMessageFromQueue(topic, message.id)\n\n        if (lockKey) {\n          this.lockedGroups.delete(lockKey)\n        }\n        this.scheduleProcessing(topic, 0)\n      } else {\n        this.updateMetric(topic, 'retriesCount', 1)\n        message.visibleAt = Date.now() + handler.queueConfig.visibilityTimeout * 1000\n        if (lockKey) {\n          this.lockedGroups.delete(lockKey)\n        }\n        this.scheduleProcessing(topic, handler.queueConfig.visibilityTimeout * 1000)\n      }\n    }\n  }\n\n  private removeMessageFromQueue(topic: string, messageId: string): void {\n    const queue = this.queues[topic]\n    if (!queue) {\n      return\n    }\n\n    const index = queue.findIndex((msg) => msg.id === messageId)\n    if (index !== -1) {\n      queue.splice(index, 1)\n      this.updateMetric(topic, 'queueDepth', -1)\n    }\n\n    if (queue.length === 0) {\n      delete this.queues[topic]\n    }\n  }\n\n  private scheduleProcessing(topic: string, delayMs: number): void {\n    const existingTimeout = this.scheduledTimeouts.get(topic)\n    if (existingTimeout) {\n      clearTimeout(existingTimeout)\n    }\n\n    const timeout = setTimeout(() => {\n      this.queueEmitter.emit('process', topic)\n      this.scheduledTimeouts.delete(topic)\n    }, delayMs)\n\n    this.scheduledTimeouts.set(topic, timeout)\n  }\n\n  async enqueue<TData>(topic: string, event: Event<TData>, messageGroupId?: string): Promise<void> {\n    const handlers = this.subscriptions[topic] || []\n\n    if (handlers.length === 0) {\n      return\n    }\n\n    const effectiveMessageGroupId = messageGroupId ?? event.messageGroupId\n\n    for (const subscription of handlers) {\n      const delayMs = subscription.queueConfig.delaySeconds * 1000\n      const visibleAt = Date.now() + delayMs\n\n      const queuedMessage: QueuedMessage<TData> = {\n        id: randomUUID(),\n        event,\n        attempts: 0,\n        visibleAt,\n        messageGroupId: effectiveMessageGroupId,\n        queueConfig: subscription.queueConfig,\n        subscriptionId: subscription.subscriptionId,\n        internalSubscriptionId: subscription.internalSubscriptionId,\n      }\n\n      if (!this.queues[topic]) {\n        this.queues[topic] = []\n      }\n\n      this.queues[topic].push(queuedMessage as QueuedMessage)\n      this.updateMetric(topic, 'queueDepth', 1)\n\n      this.scheduleProcessing(topic, delayMs)\n    }\n  }\n\n  subscribe(topic: string, handler: Handler, queueConfig: QueueConfig, subscriptionId: string): void {\n    if (!this.subscriptions[topic]) {\n      this.subscriptions[topic] = []\n    }\n\n    const internalSubscriptionId = randomUUID()\n    this.subscriptions[topic].push({ handler, queueConfig, subscriptionId, internalSubscriptionId })\n\n    if (this.queues[topic] && this.queues[topic].length > 0) {\n      const now = Date.now()\n      let madeVisible = false\n      for (const message of this.queues[topic]) {\n        if (message.internalSubscriptionId !== internalSubscriptionId && message.attempts > 0) {\n          message.visibleAt = now\n          madeVisible = true\n        }\n      }\n      if (madeVisible) {\n        this.scheduleProcessing(topic, 0)\n      }\n    }\n  }\n\n  unsubscribe(topic: string, handler: Handler): void {\n    if (!this.subscriptions[topic]) {\n      return\n    }\n\n    this.subscriptions[topic] = this.subscriptions[topic].filter((sub) => sub.handler !== handler)\n\n    if (this.subscriptions[topic].length === 0) {\n      delete this.subscriptions[topic]\n      const hasQueuedMessages = this.queues[topic] && this.queues[topic].length > 0\n      if (!hasQueuedMessages) {\n        const timeout = this.scheduledTimeouts.get(topic)\n        if (timeout) {\n          clearTimeout(timeout)\n          this.scheduledTimeouts.delete(topic)\n        }\n      }\n    }\n  }\n\n  getMetrics(topic: string): QueueMetrics | undefined {\n    return this.metrics.get(topic)\n  }\n\n  getAllMetrics(): Record<string, QueueMetrics> {\n    const result: Record<string, QueueMetrics> = {}\n    this.metrics.forEach((metrics, topic) => {\n      result[topic] = { ...metrics }\n    })\n    return result\n  }\n\n  reset(): void {\n    this.scheduledTimeouts.forEach((timeout) => clearTimeout(timeout))\n    this.scheduledTimeouts.clear()\n    this.queueEmitter.removeAllListeners()\n    this.queues = {}\n    this.subscriptions = {}\n    this.lockedGroups = new Set()\n    this.processingMessages = new Set()\n    this.metrics.clear()\n  }\n}\n"],"mappings":"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"}