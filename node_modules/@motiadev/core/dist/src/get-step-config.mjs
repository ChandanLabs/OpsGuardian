import { globalLogger } from "./logger.mjs";
import { getLanguageBasedRunner } from "./language-runner.mjs";
import { ProcessManager } from "./process-communication/process-manager.mjs";
import { compile, invalidate } from "./ts-compiler.mjs";

//#region src/get-step-config.ts
const getConfig = async (file, projectRoot) => {
	const filePathToExecute = file.endsWith(".ts") ? await compile(file, projectRoot || process.cwd()) : file;
	const { runner, command, args } = getLanguageBasedRunner(file, {
		python: "get-config.py",
		ruby: "get-config.rb",
		node: {
			js: "get-config.mjs",
			ts: "get-config.ts"
		}
	});
	const processManager = new ProcessManager({
		command,
		args: [
			...args,
			runner,
			filePathToExecute
		],
		logger: globalLogger,
		context: "Config",
		projectRoot
	});
	return new Promise((resolve, reject) => {
		let config = null;
		processManager.spawn().then(() => {
			processManager.onMessage((message) => {
				config = message;
				globalLogger.debug(`[Config] Read config via ${processManager.commType?.toUpperCase()}`, {
					config,
					communicationType: processManager.commType
				});
				resolve(config);
				processManager.kill();
			});
			processManager.onProcessClose((code) => {
				processManager.close();
				if (config) return;
				else if (code !== 0) reject(`Process exited with code ${code}`);
				else if (!config) reject(`No config found for file ${file}`);
			});
			processManager.onProcessError((error) => {
				processManager.close();
				if (error.code === "ENOENT") reject(`Executable ${command} not found`);
				else reject(error);
			});
		}).catch((error) => {
			reject(`Failed to spawn process: ${error}`);
		});
	});
};
const getStepConfig = (file, projectRoot) => {
	return getConfig(file, projectRoot);
};
const getStreamConfig = (file, projectRoot) => {
	return getConfig(file, projectRoot);
};

//#endregion
export { getStepConfig, getStreamConfig };
//# sourceMappingURL=get-step-config.mjs.map