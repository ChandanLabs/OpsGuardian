import readline from "readline";

//#region src/step-handler-rpc-stdin-processor.ts
var RpcStdinProcessor = class {
	constructor(child) {
		this.child = child;
		this.handlers = {};
		this.isClosed = false;
	}
	handler(method, handler) {
		this.handlers[method] = handler;
	}
	onMessage(callback) {
		this.messageCallback = callback;
	}
	async handle(method, input) {
		const handler = this.handlers[method];
		if (!handler) throw new Error(`Handler for method ${method} not found`);
		return handler(input);
	}
	response(id, result, error) {
		if (id && !this.isClosed && this.child.stdin && !this.child.killed) {
			const responseMessage = {
				type: "rpc_response",
				id,
				result: error ? void 0 : result,
				error: error ? String(error) : void 0
			};
			const messageStr = JSON.stringify(responseMessage);
			this.child.stdin.write(messageStr + "\n");
		}
	}
	async init() {
		if (this.child.stdout) {
			this.rl = readline.createInterface({
				input: this.child.stdout,
				crlfDelay: Infinity
			});
			this.rl.on("line", (line) => {
				try {
					const msg = JSON.parse(line.trim());
					if (this.messageCallback) this.messageCallback(msg);
					if (msg && msg.type === "rpc_request") {
						const { id, method, args } = msg;
						this.handle(method, args).then((result) => this.response(id, result, null)).catch((error) => this.response(id, null, error));
					}
				} catch (error) {
					console.error("Failed to parse RPC message:", error, "Raw line:", line);
				}
			});
			this.rl.on("close", () => {
				this.isClosed = true;
			});
		}
		this.child.on("exit", () => {
			this.isClosed = true;
		});
		this.child.on("close", () => {
			this.isClosed = true;
		});
	}
	close() {
		this.isClosed = true;
		this.messageCallback = void 0;
		this.handlers = {};
		if (this.rl) {
			this.rl.removeAllListeners();
			this.rl.close();
		}
	}
};

//#endregion
export { RpcStdinProcessor };
//# sourceMappingURL=step-handler-rpc-stdin-processor.mjs.map