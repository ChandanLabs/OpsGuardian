import { trackEvent } from "./analytics/utils.mjs";
import { getLanguageBasedRunner } from "./language-runner.mjs";
import { ProcessManager } from "./process-communication/process-manager.mjs";
import { compile } from "./ts-compiler.mjs";
import { isAllowedToEmit } from "./utils.mjs";

//#region src/call-step-file.ts
const callStepFile = (options, motia) => {
	const { step, traceId, data, tracer, logger, contextInFirstArg = false, infrastructure } = options;
	const flows = step.config.flows;
	return (async () => {
		try {
			const streamConfig = motia.lockedData.getStreams();
			const streams = Object.keys(streamConfig).map((name) => ({ name }));
			const jsonData = JSON.stringify({
				data,
				flows,
				traceId,
				contextInFirstArg,
				streams
			});
			const filePathToExecute = step.filePath.endsWith(".ts") ? await compile(step.filePath, motia.lockedData.baseDir) : step.filePath;
			const { runner, command, args } = getLanguageBasedRunner(step.filePath);
			let result;
			let timeoutId;
			return new Promise((resolve, reject) => {
				const processManager = new ProcessManager({
					command,
					args: [
						...args,
						runner,
						filePathToExecute,
						jsonData
					],
					logger,
					context: "StepExecution",
					projectRoot: motia.lockedData.baseDir
				});
				trackEvent("step_execution_started", {
					stepName: step.config.name,
					language: command,
					type: step.config.type,
					streams: streams.length
				});
				const timeoutSeconds = infrastructure?.handler?.timeout;
				if (timeoutSeconds) timeoutId = setTimeout(async () => {
					processManager.kill();
					const errorMessage = `Step execution timed out after ${timeoutSeconds} seconds`;
					logger.error(errorMessage, {
						step: step.config.name,
						timeout: timeoutSeconds
					});
					tracer.end({ message: errorMessage });
					trackEvent("step_execution_timeout", {
						stepName: step.config.name,
						traceId,
						timeout: timeoutSeconds
					});
					reject(new Error(errorMessage));
				}, timeoutSeconds * 1e3);
				processManager.spawn().then(() => {
					processManager.handler("close", async (err) => {
						if (err) {
							if (timeoutId) clearTimeout(timeoutId);
							processManager.close();
							trackEvent("step_execution_error", {
								stepName: step.config.name,
								traceId,
								message: err.message
							});
							tracer.end({
								message: err.message,
								code: err.code,
								stack: err.stack?.replace(/* @__PURE__ */ new RegExp(`${motia.lockedData.baseDir}/`), "")
							});
							reject(err ?? /* @__PURE__ */ new Error("Handler execution failed"));
						} else tracer.end();
						processManager.kill();
					});
					processManager.handler("log", async (input) => logger.log(input));
					processManager.handler("state.get", async (input) => {
						tracer.stateOperation("get", input);
						return motia.state.get(input.traceId, input.key);
					});
					processManager.handler("state.set", async (input) => {
						tracer.stateOperation("set", {
							traceId: input.traceId,
							key: input.key,
							value: input.value
						});
						return motia.state.set(input.traceId, input.key, input.value);
					});
					processManager.handler("state.delete", async (input) => {
						tracer.stateOperation("delete", input);
						return motia.state.delete(input.traceId, input.key);
					});
					processManager.handler("state.clear", async (input) => {
						tracer.stateOperation("clear", input);
						return motia.state.clear(input.traceId);
					});
					processManager.handler(`state.getGroup`, async (input) => {
						tracer.stateOperation("getGroup", input);
						return motia.state.getGroup(input.groupId);
					});
					processManager.handler("result", async (input) => {
						const inputWithBody = input;
						if (inputWithBody.body && inputWithBody.body.type === "Buffer") inputWithBody.body = Buffer.from(inputWithBody.body.data || []);
						result = inputWithBody;
					});
					processManager.handler("emit", async (input) => {
						const flows$1 = step.config.flows;
						if (!isAllowedToEmit(step, input.topic)) {
							tracer.emitOperation(input.topic, input.data, false);
							return motia.printer.printInvalidEmit(step, input.topic);
						}
						tracer.emitOperation(input.topic, input.data, true);
						return motia.eventAdapter.emit({
							...input,
							traceId,
							flows: flows$1,
							logger,
							tracer
						});
					});
					Object.entries(streamConfig).forEach(([name, streamFactory]) => {
						const stateStream = streamFactory();
						processManager.handler(`streams.${name}.get`, async (input) => {
							tracer.streamOperation(name, "get", input);
							return stateStream.get(input.groupId, input.id);
						});
						processManager.handler(`streams.${name}.set`, async (input) => {
							tracer.streamOperation(name, "set", {
								groupId: input.groupId,
								id: input.id,
								data: input.data
							});
							return stateStream.set(input.groupId, input.id, input.data);
						});
						processManager.handler(`streams.${name}.delete`, async (input) => {
							tracer.streamOperation(name, "delete", input);
							return stateStream.delete(input.groupId, input.id);
						});
						processManager.handler(`streams.${name}.getGroup`, async (input) => {
							tracer.streamOperation(name, "getGroup", input);
							return stateStream.getGroup(input.groupId);
						});
						processManager.handler(`streams.${name}.send`, async (input) => {
							tracer.streamOperation(name, "send", input);
							return stateStream.send(input.channel, input.event);
						});
					});
					processManager.onStdout((data$1) => {
						try {
							const message = JSON.parse(data$1.toString());
							logger.log(message);
						} catch {
							logger.info(Buffer.from(data$1).toString());
						}
					});
					processManager.onStderr((data$1) => logger.error(Buffer.from(data$1).toString()));
					processManager.onProcessClose(async (code) => {
						if (timeoutId) clearTimeout(timeoutId);
						processManager.close();
						if (code !== 0 && code !== null) {
							const error = {
								message: `Process exited with code ${code}`,
								code
							};
							tracer.end(error);
							trackEvent("step_execution_error", {
								stepName: step.config.name,
								traceId,
								code
							});
							reject(`Process exited with code ${code}`);
						} else {
							tracer.end();
							resolve(result);
						}
					});
					processManager.onProcessError(async (error) => {
						if (timeoutId) clearTimeout(timeoutId);
						processManager.close();
						tracer.end({
							message: error.message,
							code: error.code,
							stack: error.stack
						});
						if (error.code === "ENOENT") {
							trackEvent("step_execution_error", {
								stepName: step.config.name,
								traceId,
								code: error.code,
								message: error.message
							});
							reject(`Executable ${command} not found`);
						} else reject(error);
					});
				}).catch(async (error) => {
					if (timeoutId) clearTimeout(timeoutId);
					tracer.end({
						message: error.message,
						code: error.code,
						stack: error.stack
					});
					trackEvent("step_execution_error", {
						stepName: step.config.name,
						traceId,
						code: error.code,
						message: error.message
					});
					reject(`Failed to spawn process: ${error}`);
				});
			});
		} catch (error) {
			const err = error;
			tracer.end({
				message: err.message,
				code: err.code,
				stack: err.stack
			});
			trackEvent("step_execution_error", {
				stepName: step.config.name,
				traceId,
				code: err.code,
				message: err.message
			});
			throw err;
		}
	})();
};

//#endregion
export { callStepFile };
//# sourceMappingURL=call-step-file.mjs.map