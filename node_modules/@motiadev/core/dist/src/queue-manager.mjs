import { globalLogger } from "./logger.mjs";
import { randomUUID } from "crypto";
import { EventEmitter } from "events";

//#region src/queue-manager.ts
var QueueError = class extends Error {
	constructor(message) {
		super(message);
		this.name = "QueueError";
	}
};
var MaxRetriesError = class extends QueueError {
	constructor(message, attempts) {
		super(message);
		this.attempts = attempts;
		this.name = "MaxRetriesError";
	}
};
var QueueManager = class {
	constructor(logger) {
		this.queues = {};
		this.subscriptions = {};
		this.lockedGroups = /* @__PURE__ */ new Set();
		this.queueEmitter = new EventEmitter();
		this.scheduledTimeouts = /* @__PURE__ */ new Map();
		this.metrics = /* @__PURE__ */ new Map();
		this.processingMessages = /* @__PURE__ */ new Set();
		this.logger = logger || globalLogger;
		this.queueEmitter.on("process", (topic) => {
			this.processQueue(topic);
		});
	}
	initMetrics(topic) {
		if (!this.metrics.has(topic)) this.metrics.set(topic, {
			queueDepth: 0,
			processingCount: 0,
			retriesCount: 0,
			dlqCount: 0
		});
	}
	updateMetric(topic, key, delta) {
		this.initMetrics(topic);
		const metrics = this.metrics.get(topic);
		metrics[key] = Math.max(0, metrics[key] + delta);
	}
	processQueue(topic) {
		const queue = this.queues[topic];
		if (!queue || queue.length === 0) return;
		const now = Date.now();
		const visibleMessages = queue.filter((msg) => msg.visibleAt <= now && !this.processingMessages.has(msg.id));
		for (const message of visibleMessages) if (message.queueConfig.type === "fifo" && message.messageGroupId) {
			const lockKey = `${topic}:${message.messageGroupId}`;
			if (this.lockedGroups.has(lockKey)) continue;
			this.processingMessages.add(message.id);
			this.lockedGroups.add(lockKey);
			this.processMessage(topic, message, lockKey);
		} else {
			this.processingMessages.add(message.id);
			this.processMessage(topic, message);
		}
	}
	async processMessage(topic, message, lockKey) {
		const handlers = this.subscriptions[topic] || [];
		const handler = handlers.find((s) => s.internalSubscriptionId === message.internalSubscriptionId) || handlers.find((s) => s.subscriptionId === message.subscriptionId) || handlers[0];
		if (!handler) {
			this.processingMessages.delete(message.id);
			this.removeMessageFromQueue(topic, message.id);
			if (lockKey) this.lockedGroups.delete(lockKey);
			return;
		}
		if (message.internalSubscriptionId !== handler.internalSubscriptionId && message.attempts > 0) {
			message.attempts = 0;
			message.internalSubscriptionId = handler.internalSubscriptionId;
			message.subscriptionId = handler.subscriptionId;
			message.visibleAt = Date.now();
		}
		this.updateMetric(topic, "processingCount", 1);
		try {
			await handler.handler(message.event);
			this.updateMetric(topic, "processingCount", -1);
			this.processingMessages.delete(message.id);
			this.removeMessageFromQueue(topic, message.id);
			if (lockKey) this.lockedGroups.delete(lockKey);
			this.scheduleProcessing(topic, 0);
		} catch (error) {
			this.updateMetric(topic, "processingCount", -1);
			this.processingMessages.delete(message.id);
			message.attempts++;
			if (message.attempts >= handler.queueConfig.maxRetries) {
				const maxRetriesError = new MaxRetriesError(`Message failed after ${message.attempts} attempts`, message.attempts);
				this.logger.error("[Queue DLQ] Message moved to dead-letter queue after max retries", {
					topic,
					messageId: message.id,
					attempts: message.attempts,
					originalError: error instanceof Error ? error.message : "Unknown error",
					error: maxRetriesError.message
				});
				this.updateMetric(topic, "dlqCount", 1);
				this.removeMessageFromQueue(topic, message.id);
				if (lockKey) this.lockedGroups.delete(lockKey);
				this.scheduleProcessing(topic, 0);
			} else {
				this.updateMetric(topic, "retriesCount", 1);
				message.visibleAt = Date.now() + handler.queueConfig.visibilityTimeout * 1e3;
				if (lockKey) this.lockedGroups.delete(lockKey);
				this.scheduleProcessing(topic, handler.queueConfig.visibilityTimeout * 1e3);
			}
		}
	}
	removeMessageFromQueue(topic, messageId) {
		const queue = this.queues[topic];
		if (!queue) return;
		const index = queue.findIndex((msg) => msg.id === messageId);
		if (index !== -1) {
			queue.splice(index, 1);
			this.updateMetric(topic, "queueDepth", -1);
		}
		if (queue.length === 0) delete this.queues[topic];
	}
	scheduleProcessing(topic, delayMs) {
		const existingTimeout = this.scheduledTimeouts.get(topic);
		if (existingTimeout) clearTimeout(existingTimeout);
		const timeout = setTimeout(() => {
			this.queueEmitter.emit("process", topic);
			this.scheduledTimeouts.delete(topic);
		}, delayMs);
		this.scheduledTimeouts.set(topic, timeout);
	}
	async enqueue(topic, event, messageGroupId) {
		const handlers = this.subscriptions[topic] || [];
		if (handlers.length === 0) return;
		const effectiveMessageGroupId = messageGroupId ?? event.messageGroupId;
		for (const subscription of handlers) {
			const delayMs = subscription.queueConfig.delaySeconds * 1e3;
			const visibleAt = Date.now() + delayMs;
			const queuedMessage = {
				id: randomUUID(),
				event,
				attempts: 0,
				visibleAt,
				messageGroupId: effectiveMessageGroupId,
				queueConfig: subscription.queueConfig,
				subscriptionId: subscription.subscriptionId,
				internalSubscriptionId: subscription.internalSubscriptionId
			};
			if (!this.queues[topic]) this.queues[topic] = [];
			this.queues[topic].push(queuedMessage);
			this.updateMetric(topic, "queueDepth", 1);
			this.scheduleProcessing(topic, delayMs);
		}
	}
	subscribe(topic, handler, queueConfig, subscriptionId) {
		if (!this.subscriptions[topic]) this.subscriptions[topic] = [];
		const internalSubscriptionId = randomUUID();
		this.subscriptions[topic].push({
			handler,
			queueConfig,
			subscriptionId,
			internalSubscriptionId
		});
		if (this.queues[topic] && this.queues[topic].length > 0) {
			const now = Date.now();
			let madeVisible = false;
			for (const message of this.queues[topic]) if (message.internalSubscriptionId !== internalSubscriptionId && message.attempts > 0) {
				message.visibleAt = now;
				madeVisible = true;
			}
			if (madeVisible) this.scheduleProcessing(topic, 0);
		}
	}
	unsubscribe(topic, handler) {
		if (!this.subscriptions[topic]) return;
		this.subscriptions[topic] = this.subscriptions[topic].filter((sub) => sub.handler !== handler);
		if (this.subscriptions[topic].length === 0) {
			delete this.subscriptions[topic];
			if (!(this.queues[topic] && this.queues[topic].length > 0)) {
				const timeout = this.scheduledTimeouts.get(topic);
				if (timeout) {
					clearTimeout(timeout);
					this.scheduledTimeouts.delete(topic);
				}
			}
		}
	}
	getMetrics(topic) {
		return this.metrics.get(topic);
	}
	getAllMetrics() {
		const result = {};
		this.metrics.forEach((metrics, topic) => {
			result[topic] = { ...metrics };
		});
		return result;
	}
	reset() {
		this.scheduledTimeouts.forEach((timeout) => clearTimeout(timeout));
		this.scheduledTimeouts.clear();
		this.queueEmitter.removeAllListeners();
		this.queues = {};
		this.subscriptions = {};
		this.lockedGroups = /* @__PURE__ */ new Set();
		this.processingMessages = /* @__PURE__ */ new Set();
		this.metrics.clear();
	}
};

//#endregion
export { QueueManager };
//# sourceMappingURL=queue-manager.mjs.map