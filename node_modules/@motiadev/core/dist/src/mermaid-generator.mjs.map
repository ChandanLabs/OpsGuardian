{"version":3,"file":"mermaid-generator.mjs","names":["connections: string[]"],"sources":["../../src/mermaid-generator.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport { isApiStep, isCronStep, isEventStep, isNoopStep } from './guards'\nimport type { LockedData } from './locked-data'\nimport type { Flow, Step } from './types'\n\n// Pure function to ensure diagrams directory exists\nconst ensureDiagramsDirectory = (diagramsDir: string): void => {\n  if (!fs.existsSync(diagramsDir)) {\n    fs.mkdirSync(diagramsDir, { recursive: true })\n  }\n}\n\n// Pure function to get node ID\nconst getNodeId = (step: Step, baseDir: string): string => {\n  // Get relative path from the base directory\n  const relativePath = path.relative(baseDir, step.filePath)\n\n  // Remove common file extensions\n  const pathWithoutExtension = relativePath.replace(/\\.(ts|js|tsx|jsx)$/, '')\n\n  // Replace slashes with underscores and dots with underscores\n  // Only keep alphanumeric characters and underscores\n  return pathWithoutExtension.replace(/[^a-zA-Z0-9]/g, '_')\n}\n\n// Pure function to get node label\nconst getNodeLabel = (step: Step): string => {\n  // Get display name for node\n  const displayName = step.config.name || path.basename(step.filePath, path.extname(step.filePath))\n\n  // Add node type prefix to help distinguish types\n  let prefix = ''\n  if (isApiStep(step)) prefix = 'ðŸŒ '\n  else if (isEventStep(step)) prefix = 'âš¡ '\n  else if (isCronStep(step)) prefix = 'â° '\n  else if (isNoopStep(step)) prefix = 'âš™ï¸ '\n\n  // Create a node label with the step name\n  return `[\"${prefix}${displayName}\"]`\n}\n\n// Pure function to get node style\nconst getNodeStyle = (step: Step): string => {\n  // Apply style class based on step type\n  if (isApiStep(step)) return ':::apiStyle'\n  if (isEventStep(step)) return ':::eventStyle'\n  if (isCronStep(step)) return ':::cronStyle'\n  if (isNoopStep(step)) return ':::noopStyle'\n  return ''\n}\n\n// Pure function to generate connections\nconst generateConnections = (\n  emits: Array<string | { topic: string; label?: string }>,\n  sourceStep: Step,\n  steps: Step[],\n  sourceId: string,\n  baseDir: string,\n): string => {\n  const connections: string[] = []\n\n  if (!emits || !Array.isArray(emits) || emits.length === 0) {\n    return ''\n  }\n\n  // Helper function to check if a step subscribes to a topic\n  const stepSubscribesToTopic = (step: Step, topic: string): boolean => {\n    // Event steps use regular subscribes\n    if (\n      isEventStep(step) &&\n      step.config.subscribes &&\n      Array.isArray(step.config.subscribes) &&\n      step.config.subscribes.includes(topic)\n    ) {\n      return true\n    }\n\n    // Noop and API steps use virtualSubscribes\n    if (\n      (isNoopStep(step) || isApiStep(step)) &&\n      step.config.virtualSubscribes &&\n      Array.isArray(step.config.virtualSubscribes) &&\n      step.config.virtualSubscribes.includes(topic)\n    ) {\n      return true\n    }\n\n    return false\n  }\n\n  emits.forEach((emit) => {\n    const topic = typeof emit === 'string' ? emit : emit.topic\n    const label = typeof emit === 'string' ? topic : emit.label || topic\n\n    steps.forEach((targetStep) => {\n      if (stepSubscribesToTopic(targetStep, topic)) {\n        const targetId = getNodeId(targetStep, baseDir)\n        connections.push(`    ${sourceId} -->|${label}| ${targetId}`)\n      }\n    })\n  })\n\n  return connections.join('\\n')\n}\n\n// Pure function to generate flow diagram\nconst generateFlowDiagram = (flowName: string, steps: Step[], baseDir: string): string => {\n  // Start mermaid flowchart with top-down direction\n  let diagram = `flowchart TD\\n`\n\n  // Add class definitions for styling with explicit text color\n  const classDefinitions = [\n    `    classDef apiStyle fill:#f96,stroke:#333,stroke-width:2px,color:#fff`,\n    `    classDef eventStyle fill:#69f,stroke:#333,stroke-width:2px,color:#fff`,\n    `    classDef cronStyle fill:#9c6,stroke:#333,stroke-width:2px,color:#fff`,\n    `    classDef noopStyle fill:#3f3a50,stroke:#333,stroke-width:2px,color:#fff`,\n  ]\n  diagram += classDefinitions.join('\\n') + '\\n'\n\n  // Check if we have any steps\n  if (!steps || steps.length === 0) {\n    return diagram + '    empty[No steps in this flow]'\n  }\n\n  // Create node definitions with proper format\n  steps.forEach((step) => {\n    const nodeId = getNodeId(step, baseDir)\n    const nodeLabel = getNodeLabel(step)\n    const nodeStyle = getNodeStyle(step)\n    diagram += `    ${nodeId}${nodeLabel}${nodeStyle}\\n`\n  })\n\n  // Create connections between nodes\n  let connectionsStr = ''\n\n  steps.forEach((sourceStep) => {\n    const sourceId = getNodeId(sourceStep, baseDir)\n\n    // Helper function to process emissions if they exist\n    function processEmissions(\n      emissionsArray: Array<string | { topic: string; label?: string }> | undefined,\n      stepSource: Step,\n      stepsCollection: Step[],\n      sourceIdentifier: string,\n    ): string {\n      if (emissionsArray && Array.isArray(emissionsArray)) {\n        return generateConnections(emissionsArray, stepSource, stepsCollection, sourceIdentifier, baseDir)\n      }\n      return ''\n    }\n\n    // Semantic variables to clarify which step types support which emission types\n    const supportsEmits = isApiStep(sourceStep) || isEventStep(sourceStep) || isCronStep(sourceStep)\n    const supportsVirtualEmits = supportsEmits || isNoopStep(sourceStep)\n\n    // Process regular emissions if supported\n    if (supportsEmits) {\n      const emitConnections = processEmissions(sourceStep.config.emits, sourceStep, steps, sourceId)\n      if (emitConnections) {\n        connectionsStr += emitConnections + '\\n'\n      }\n    }\n\n    // Process virtual emissions if supported\n    if (supportsVirtualEmits) {\n      const virtualEmitConnections = processEmissions(sourceStep.config.virtualEmits, sourceStep, steps, sourceId)\n      if (virtualEmitConnections) {\n        connectionsStr += virtualEmitConnections + '\\n'\n      }\n    }\n  })\n\n  // Add connections to the diagram\n  diagram += connectionsStr\n\n  return diagram\n}\n\n// Function to save a diagram to a file\nconst saveDiagram = (diagramsDir: string, flowName: string, diagram: string): void => {\n  const filePath = path.join(diagramsDir, `${flowName}.mmd`)\n  fs.writeFileSync(filePath, diagram)\n}\n\n// Function to remove a diagram file\nconst removeDiagram = (diagramsDir: string, flowName: string): void => {\n  const filePath = path.join(diagramsDir, `${flowName}.mmd`)\n  if (fs.existsSync(filePath)) {\n    fs.unlinkSync(filePath)\n  }\n}\n\n// Function to generate and save a diagram\nconst generateAndSaveDiagram = (diagramsDir: string, flowName: string, flow: Flow, baseDir: string): void => {\n  const diagram = generateFlowDiagram(flowName, flow.steps, baseDir)\n  saveDiagram(diagramsDir, flowName, diagram)\n}\n\n// Main exported function that creates the mermaid generator\nexport const createMermaidGenerator = (baseDir: string) => {\n  const diagramsDir = path.join(baseDir, '.mermaid')\n  ensureDiagramsDirectory(diagramsDir)\n\n  // Event handlers\n  const handleFlowCreated = (flowName: string, flow: Flow): void => {\n    generateAndSaveDiagram(diagramsDir, flowName, flow, baseDir)\n  }\n\n  const handleFlowUpdated = (flowName: string, flow: Flow): void => {\n    generateAndSaveDiagram(diagramsDir, flowName, flow, baseDir)\n  }\n\n  const handleFlowRemoved = (flowName: string): void => {\n    removeDiagram(diagramsDir, flowName)\n  }\n\n  // Initialize function to hook into LockedData events\n  const initialize = (lockedData: LockedData): void => {\n    // Hook into flow events\n    lockedData.on('flow-created', (flowName: string) => {\n      handleFlowCreated(flowName, lockedData.flows[flowName])\n    })\n\n    lockedData.on('flow-updated', (flowName: string) => {\n      handleFlowUpdated(flowName, lockedData.flows[flowName])\n    })\n\n    lockedData.on('flow-removed', (flowName: string) => {\n      handleFlowRemoved(flowName)\n    })\n\n    // Generate diagrams for all existing flows\n    if (lockedData.flows && typeof lockedData.flows === 'object') {\n      Object.entries(lockedData.flows).forEach(([flowName, flow]) => {\n        generateAndSaveDiagram(diagramsDir, flowName, flow as Flow, baseDir)\n      })\n    }\n  }\n\n  // Return the public API\n  return {\n    initialize,\n  }\n}\n"],"mappings":"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"}