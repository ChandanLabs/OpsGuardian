import { isApiStep, isCronStep, isEventStep } from "../guards.mjs";
import { generateTypeFromSchema } from "./generate-type-from-schema.mjs";
import { schemaToJsonSchema } from "../schema-utils.mjs";
import { generateTypesFromResponse } from "./generate-types-from-response.mjs";
import { mergeSchemas } from "./merge-schemas.mjs";

//#region src/types/generate-types.ts
const generateTypesString = (handlers, streams, streamAuthContextType) => {
	return `/**
 * Automatically generated types for motia
 * Do NOT edit this file manually.
 * 
 * Consider adding this file to .prettierignore and eslint ignore.
 */
import { EventHandler, ApiRouteHandler, ApiResponse, MotiaStream, CronHandler } from 'motia'

declare module 'motia' {
  interface FlowContextStateStreams {
    ${Object.entries(streams).map(([key, value]) => `'${key}': MotiaStream<${value}>`).join("\n    ").trim()}
  }

  interface Handlers {
    ${Object.entries(handlers).map(([key, { type, generics }]) => `'${key}': ${type}<${generics.join(", ")}>`).join("\n    ").trim()}
  }
    ${streamAuthContextType ? `interface StreamAuthContext ${streamAuthContextType}` : ""}
}`;
};
const generateTypesFromSteps = (steps, printer) => {
	const handlers = {};
	const topics = {};
	const topicsSchemas = {};
	const topicsSteps = {};
	const topicIsFifo = {};
	for (const step of steps) if (isEventStep(step)) {
		if (!step.config.input) {
			for (const topic of step.config.subscribes) if (!topics[topic]) topics[topic] = "never";
			continue;
		}
		for (const topic of step.config.subscribes) {
			const existingSchema = topicsSchemas[topic];
			topicsSteps[topic] = topicsSteps[topic] ?? [];
			topicsSteps[topic].push(step);
			if (step.config.infrastructure?.queue?.type === "fifo") topicIsFifo[topic] = true;
			try {
				const input = step.config.input;
				const schema = existingSchema ? mergeSchemas(existingSchema, input) : schemaToJsonSchema(input) ?? input;
				topics[topic] = generateTypeFromSchema(schema);
				topicsSchemas[topic] = schema;
			} catch (error) {
				printer.printInvalidSchema(topic, topicsSteps[topic]);
				topics[topic] = "never";
			}
		}
	}
	const generateEmitData = (emit, step) => {
		const emits = emit.reduce((acc, emit$1) => {
			const topic = typeof emit$1 === "string" ? emit$1 : emit$1.topic;
			const topicType = topics[topic];
			if (topicType) if (topicIsFifo[topic]) acc.push(`{ topic: '${topic.replace(/'/g, "\\'")}'; data: ${topicType}; messageGroupId: string }`);
			else acc.push(`{ topic: '${topic.replace(/'/g, "\\'")}'; data: ${topicType} }`);
			else printer.printInvalidEmitConfiguration(step, topic);
			return acc;
		}, []).join(" | ");
		return emits.length === 0 ? "never" : emits;
	};
	for (const step of steps) {
		const emits = "emits" in step.config ? generateEmitData(step.config.emits, step) : "never";
		if (isEventStep(step)) {
			const input = step.config.input ? generateTypeFromSchema(step.config.input) : "never";
			handlers[step.config.name] = {
				type: "EventHandler",
				generics: [input, emits]
			};
		} else if (isApiStep(step)) {
			const input = step.config.bodySchema ? generateTypeFromSchema(step.config.bodySchema) : "Record<string, unknown>";
			const result = step.config.responseSchema ? generateTypesFromResponse(step.config.responseSchema) : "unknown";
			handlers[step.config.name] = {
				type: "ApiRouteHandler",
				generics: [
					input,
					result,
					emits
				]
			};
		} else if (isCronStep(step)) handlers[step.config.name] = {
			type: "CronHandler",
			generics: [emits]
		};
	}
	return handlers;
};
const generateTypesFromStreams = (streams) => {
	return Object.entries(streams).reduce((acc, [key, stream]) => {
		if (!stream.hidden) acc[key] = generateTypeFromSchema(stream.config.schema);
		return acc;
	}, {});
};

//#endregion
export { generateTypesFromSteps, generateTypesFromStreams, generateTypesString };
//# sourceMappingURL=generate-types.mjs.map