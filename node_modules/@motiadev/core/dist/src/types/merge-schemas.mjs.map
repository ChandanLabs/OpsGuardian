{"version":3,"file":"merge-schemas.mjs","names":["z","mergedProperties: Record<string, JSONSchema._JSONSchema>"],"sources":["../../../src/types/merge-schemas.ts"],"sourcesContent":["import * as z from 'zod'\nimport type { JSONSchema } from 'zod/v4/core'\nimport { isZodSchema, type SchemaInput, schemaToJsonSchema } from '../schema-utils'\nimport { isAnyOf, type JsonSchema, JsonSchemaError } from './schema.types'\n\nconst isJsonSchema = (value: unknown): value is JsonSchema => {\n  return typeof value === 'object' && value !== null && !Array.isArray(value) && typeof value !== 'boolean'\n}\n\nexport const isCompatible = (schema: JsonSchema, otherSchema: JsonSchema): boolean => {\n  if (isAnyOf(schema)) {\n    return schema.anyOf.every((item) => isCompatible(item, otherSchema))\n  } else if (isAnyOf(otherSchema)) {\n    return otherSchema.anyOf.every((item) => isCompatible(schema, item))\n  }\n\n  if (schema.type !== otherSchema.type) {\n    return false\n  }\n\n  if (schema.type === 'array' && otherSchema.type === 'array') {\n    if (!schema.items || !otherSchema.items) {\n      return schema.items === otherSchema.items\n    }\n    if (Array.isArray(schema.items) || Array.isArray(otherSchema.items)) {\n      return false\n    }\n    if (isJsonSchema(schema.items) && isJsonSchema(otherSchema.items)) {\n      return isCompatible(schema.items, otherSchema.items)\n    }\n    return schema.items === otherSchema.items\n  }\n\n  if (schema.type === 'object' && otherSchema.type === 'object') {\n    const schemaProps = schema.properties\n    const otherSchemaProps = otherSchema.properties\n    if (!schemaProps || !otherSchemaProps) {\n      return schemaProps === otherSchemaProps\n    }\n    const keysFromSchema = Object.keys(schemaProps)\n    const keysFromOtherSchema = Object.keys(otherSchemaProps)\n    const commonKeys = keysFromSchema.filter((key) => keysFromOtherSchema.includes(key))\n\n    if (schema.required?.some((key) => !keysFromOtherSchema.includes(key))) {\n      return false\n    } else if (otherSchema.required?.some((key) => !keysFromSchema.includes(key))) {\n      return false\n    }\n\n    if (commonKeys.length > 0) {\n      return commonKeys.every((key) => {\n        const prop1 = schemaProps[key]\n        const prop2 = otherSchemaProps[key]\n        if (isJsonSchema(prop1) && isJsonSchema(prop2)) {\n          return isCompatible(prop1, prop2)\n        }\n        return prop1 === prop2\n      })\n    }\n  }\n\n  return true\n}\n\nconst mergeZodSchemas = (schema: z.ZodType, otherSchema: z.ZodType): z.ZodType => {\n  try {\n    return z.intersection(schema, otherSchema)\n  } catch (error) {\n    throw new JsonSchemaError(`Cannot merge Zod schemas: ${error instanceof Error ? error.message : 'Unknown error'}`)\n  }\n}\n\nexport const mergeSchemas = (schema: SchemaInput, otherSchema: SchemaInput): JsonSchema => {\n  if (isZodSchema(schema) && isZodSchema(otherSchema)) {\n    const mergedZodSchema = mergeZodSchemas(schema, otherSchema)\n    const jsonSchema = schemaToJsonSchema(mergedZodSchema)\n    if (!jsonSchema) {\n      throw new JsonSchemaError('Failed to convert merged Zod schema to JSON Schema')\n    }\n    return jsonSchema as JsonSchema\n  }\n\n  const schemaJsonResult = schemaToJsonSchema(schema)\n  const otherSchemaJsonResult = schemaToJsonSchema(otherSchema)\n\n  if (!schemaJsonResult || !otherSchemaJsonResult) {\n    throw new JsonSchemaError('Cannot merge schemas: failed to convert to JSON Schema')\n  }\n\n  const schemaJson = schemaJsonResult as JsonSchema\n  const otherSchemaJson = otherSchemaJsonResult as JsonSchema\n\n  if (!isCompatible(schemaJson, otherSchemaJson)) {\n    throw new JsonSchemaError('Cannot merge schemas of different types')\n  }\n\n  if (isAnyOf(schemaJson)) {\n    return {\n      anyOf: schemaJson.anyOf.map((item) => mergeSchemas(item, otherSchemaJson)),\n    }\n  } else if (isAnyOf(otherSchemaJson)) {\n    return {\n      anyOf: otherSchemaJson.anyOf.map((item) => mergeSchemas(schemaJson, item)),\n    }\n  }\n\n  if (schemaJson.type === 'object' && otherSchemaJson.type === 'object') {\n    const schemaProps = schemaJson.properties as Record<string, JSONSchema._JSONSchema> | undefined\n    const otherSchemaProps = otherSchemaJson.properties as Record<string, JSONSchema._JSONSchema> | undefined\n    if (!schemaProps || !otherSchemaProps) {\n      throw new JsonSchemaError('Cannot merge object schemas without properties')\n    }\n    const mergedProperties: Record<string, JSONSchema._JSONSchema> = { ...schemaProps, ...otherSchemaProps }\n    const otherSchemaKeys = Object.keys(otherSchemaProps).reduce(\n      (acc, key) => {\n        acc[key] = true\n        return acc\n      },\n      {} as Record<string, boolean>,\n    )\n\n    for (const key in schemaProps) {\n      if (otherSchemaKeys[key]) {\n        const prop1 = schemaProps[key]\n        const prop2 = otherSchemaProps[key]\n        if (isJsonSchema(prop1) && isJsonSchema(prop2)) {\n          mergedProperties[key] = mergeSchemas(prop1, prop2)\n        } else {\n          mergedProperties[key] = prop2\n        }\n      }\n    }\n\n    const schemaRequired = schemaJson.required as string[] | undefined\n    const otherSchemaRequired = otherSchemaJson.required as string[] | undefined\n    const mergedRequired = new Set([...(schemaRequired ?? []), ...(otherSchemaRequired ?? [])])\n\n    return {\n      type: 'object',\n      properties: mergedProperties,\n      required: Array.from(mergedRequired),\n    }\n  }\n\n  if (schemaJson.type === 'array' && otherSchemaJson.type === 'array') {\n    if (!schemaJson.items || !otherSchemaJson.items) {\n      throw new JsonSchemaError('Cannot merge array schemas without items')\n    }\n    if (Array.isArray(schemaJson.items) || Array.isArray(otherSchemaJson.items)) {\n      throw new JsonSchemaError('Cannot merge array schemas with array items')\n    }\n    if (!isJsonSchema(schemaJson.items) || !isJsonSchema(otherSchemaJson.items)) {\n      throw new JsonSchemaError('Cannot merge array schemas with non-object items')\n    }\n    return {\n      type: 'array',\n      items: mergeSchemas(schemaJson.items, otherSchemaJson.items),\n    }\n  }\n\n  return {\n    type: schemaJson.type as JSONSchema.BaseSchema['type'],\n    description: (schemaJson.description ?? otherSchemaJson.description) as string | undefined,\n  }\n}\n"],"mappings":"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"}