import { isAnyOf } from "./schema.types.mjs";

//#region src/types/generate-type-from-schema.ts
const generateTypeFromSchema = (schema) => {
	if (!schema) return "unknown";
	if (isAnyOf(schema)) return schema.anyOf.map(generateTypeFromSchema).join(" | ");
	if (schema.type === "array") return `Array<${schema.items ? generateTypeFromSchema(schema.items) : "unknown"}>`;
	if (schema.type === "object" && schema.properties) {
		const props = Object.entries(schema.properties).map(([key, prop]) => {
			const isRequired = schema.required?.includes(key);
			const propType = generateTypeFromSchema(prop);
			return `${key}${isRequired ? "" : "?"}: ${propType}`;
		});
		return props.length > 0 ? `{ ${props.join("; ")} }` : "{}";
	} else if (schema.type === "object" && schema.additionalProperties) return `Record<string, ${generateTypeFromSchema(schema.additionalProperties)}>`;
	if (schema.type === "string") {
		if (schema.format === "binary") return "Buffer";
		return schema.enum && schema.enum.length > 0 ? schema.enum.map((value) => `'${value}'`).join(" | ") : "string";
	}
	if (typeof schema === "object" && schema !== null && "not" in schema) return "undefined";
	switch (schema.type) {
		case "number": return "number";
		case "boolean": return "boolean";
		default: return "unknown";
	}
};

//#endregion
export { generateTypeFromSchema };
//# sourceMappingURL=generate-type-from-schema.mjs.map