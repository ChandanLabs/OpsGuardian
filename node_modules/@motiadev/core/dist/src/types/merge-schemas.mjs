import { JsonSchemaError, isAnyOf } from "./schema.types.mjs";
import { isZodSchema, schemaToJsonSchema } from "../schema-utils.mjs";
import * as z$1 from "zod";

//#region src/types/merge-schemas.ts
const isJsonSchema = (value) => {
	return typeof value === "object" && value !== null && !Array.isArray(value) && typeof value !== "boolean";
};
const isCompatible = (schema, otherSchema) => {
	if (isAnyOf(schema)) return schema.anyOf.every((item) => isCompatible(item, otherSchema));
	else if (isAnyOf(otherSchema)) return otherSchema.anyOf.every((item) => isCompatible(schema, item));
	if (schema.type !== otherSchema.type) return false;
	if (schema.type === "array" && otherSchema.type === "array") {
		if (!schema.items || !otherSchema.items) return schema.items === otherSchema.items;
		if (Array.isArray(schema.items) || Array.isArray(otherSchema.items)) return false;
		if (isJsonSchema(schema.items) && isJsonSchema(otherSchema.items)) return isCompatible(schema.items, otherSchema.items);
		return schema.items === otherSchema.items;
	}
	if (schema.type === "object" && otherSchema.type === "object") {
		const schemaProps = schema.properties;
		const otherSchemaProps = otherSchema.properties;
		if (!schemaProps || !otherSchemaProps) return schemaProps === otherSchemaProps;
		const keysFromSchema = Object.keys(schemaProps);
		const keysFromOtherSchema = Object.keys(otherSchemaProps);
		const commonKeys = keysFromSchema.filter((key) => keysFromOtherSchema.includes(key));
		if (schema.required?.some((key) => !keysFromOtherSchema.includes(key))) return false;
		else if (otherSchema.required?.some((key) => !keysFromSchema.includes(key))) return false;
		if (commonKeys.length > 0) return commonKeys.every((key) => {
			const prop1 = schemaProps[key];
			const prop2 = otherSchemaProps[key];
			if (isJsonSchema(prop1) && isJsonSchema(prop2)) return isCompatible(prop1, prop2);
			return prop1 === prop2;
		});
	}
	return true;
};
const mergeZodSchemas = (schema, otherSchema) => {
	try {
		return z$1.intersection(schema, otherSchema);
	} catch (error) {
		throw new JsonSchemaError(`Cannot merge Zod schemas: ${error instanceof Error ? error.message : "Unknown error"}`);
	}
};
const mergeSchemas = (schema, otherSchema) => {
	if (isZodSchema(schema) && isZodSchema(otherSchema)) {
		const jsonSchema = schemaToJsonSchema(mergeZodSchemas(schema, otherSchema));
		if (!jsonSchema) throw new JsonSchemaError("Failed to convert merged Zod schema to JSON Schema");
		return jsonSchema;
	}
	const schemaJsonResult = schemaToJsonSchema(schema);
	const otherSchemaJsonResult = schemaToJsonSchema(otherSchema);
	if (!schemaJsonResult || !otherSchemaJsonResult) throw new JsonSchemaError("Cannot merge schemas: failed to convert to JSON Schema");
	const schemaJson = schemaJsonResult;
	const otherSchemaJson = otherSchemaJsonResult;
	if (!isCompatible(schemaJson, otherSchemaJson)) throw new JsonSchemaError("Cannot merge schemas of different types");
	if (isAnyOf(schemaJson)) return { anyOf: schemaJson.anyOf.map((item) => mergeSchemas(item, otherSchemaJson)) };
	else if (isAnyOf(otherSchemaJson)) return { anyOf: otherSchemaJson.anyOf.map((item) => mergeSchemas(schemaJson, item)) };
	if (schemaJson.type === "object" && otherSchemaJson.type === "object") {
		const schemaProps = schemaJson.properties;
		const otherSchemaProps = otherSchemaJson.properties;
		if (!schemaProps || !otherSchemaProps) throw new JsonSchemaError("Cannot merge object schemas without properties");
		const mergedProperties = {
			...schemaProps,
			...otherSchemaProps
		};
		const otherSchemaKeys = Object.keys(otherSchemaProps).reduce((acc, key) => {
			acc[key] = true;
			return acc;
		}, {});
		for (const key in schemaProps) if (otherSchemaKeys[key]) {
			const prop1 = schemaProps[key];
			const prop2 = otherSchemaProps[key];
			if (isJsonSchema(prop1) && isJsonSchema(prop2)) mergedProperties[key] = mergeSchemas(prop1, prop2);
			else mergedProperties[key] = prop2;
		}
		const schemaRequired = schemaJson.required;
		const otherSchemaRequired = otherSchemaJson.required;
		const mergedRequired = new Set([...schemaRequired ?? [], ...otherSchemaRequired ?? []]);
		return {
			type: "object",
			properties: mergedProperties,
			required: Array.from(mergedRequired)
		};
	}
	if (schemaJson.type === "array" && otherSchemaJson.type === "array") {
		if (!schemaJson.items || !otherSchemaJson.items) throw new JsonSchemaError("Cannot merge array schemas without items");
		if (Array.isArray(schemaJson.items) || Array.isArray(otherSchemaJson.items)) throw new JsonSchemaError("Cannot merge array schemas with array items");
		if (!isJsonSchema(schemaJson.items) || !isJsonSchema(otherSchemaJson.items)) throw new JsonSchemaError("Cannot merge array schemas with non-object items");
		return {
			type: "array",
			items: mergeSchemas(schemaJson.items, otherSchemaJson.items)
		};
	}
	return {
		type: schemaJson.type,
		description: schemaJson.description ?? otherSchemaJson.description
	};
};

//#endregion
export { mergeSchemas };
//# sourceMappingURL=merge-schemas.mjs.map