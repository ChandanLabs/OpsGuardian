import { existsSync, mkdirSync, statSync, writeFileSync } from "fs";
import path from "path";
import * as esbuild from "esbuild";

//#region src/ts-compiler.ts
const COMPILED_DIR = ".motia/compiled";
const TS_EXTENSIONS = [
	".ts",
	".tsx",
	".stream.ts",
	".stream"
];
const EXT_TO_JS_MAP = {
	".stream.ts": ".stream.js",
	".tsx": ".js",
	".ts": ".js",
	".stream": ".stream.js"
};
const cache = /* @__PURE__ */ new Map();
const getCompiledPath = (tsFilePath, projectRoot) => {
	const compiledRelativePath = path.relative(projectRoot, tsFilePath).replace(/\.ts$/, ".js");
	return path.join(projectRoot, COMPILED_DIR, compiledRelativePath);
};
const getSourceMtime = (filePath) => {
	try {
		return statSync(filePath).mtimeMs;
	} catch {
		return 0;
	}
};
const ensureCompiledDir = (compiledPath) => {
	const dir = path.dirname(compiledPath);
	if (!existsSync(dir)) mkdirSync(dir, { recursive: true });
};
const replaceExtensionWithJs = (filePath) => {
	for (const [ext, jsExt] of Object.entries(EXT_TO_JS_MAP)) if (filePath.endsWith(ext)) return filePath.replace(/* @__PURE__ */ new RegExp(`${ext.replace(".", "\\.")}$`), jsExt);
	return filePath;
};
const resolveImportPath = (importPath, dir, projectRoot, compiledPath) => {
	const fullImportPath = path.resolve(dir, importPath);
	for (const ext of TS_EXTENSIONS) {
		const testPath = fullImportPath + (ext.startsWith(".") ? ext : `.${ext}`);
		if (existsSync(testPath)) {
			const compiledFileName = replaceExtensionWithJs(path.relative(projectRoot, testPath));
			const compiledImportPath = path.join(COMPILED_DIR, compiledFileName);
			const relativeCompiledPath = path.relative(path.dirname(compiledPath), path.join(projectRoot, compiledImportPath)).replace(/\\/g, "/");
			return {
				sourcePath: testPath,
				compiledImportPath: relativeCompiledPath.startsWith(".") ? relativeCompiledPath : `./${relativeCompiledPath}`
			};
		}
	}
	return null;
};
const transformImportPaths = (code, tsFilePath, compiledPath, projectRoot) => {
	const dir = path.dirname(tsFilePath);
	const dependencies = [];
	return {
		code: code.replace(/from\s+['"](\.\/?[^'"]+)['"]/g, (match, importPath) => {
			if (!importPath.startsWith(".")) return match;
			if (importPath.endsWith(".js") || importPath.endsWith(".json")) return match;
			const resolved = resolveImportPath(importPath, dir, projectRoot, compiledPath);
			if (resolved) {
				dependencies.push(resolved.sourcePath);
				return match.replace(importPath, resolved.compiledImportPath);
			}
			if (!importPath.match(/\.(ts|tsx|js|jsx|json|stream)$/)) return match.replace(importPath, `${importPath}.js`);
			return match.replace(importPath, importPath.replace(/\.(ts|tsx|stream\.ts|stream)$/, ".js"));
		}),
		dependencies: dependencies.filter((dep) => dep.endsWith(".ts") || dep.endsWith(".tsx") || dep.endsWith(".stream.ts"))
	};
};
const isCacheValid = (tsFilePath) => {
	const cached = cache.get(tsFilePath);
	if (!cached) return false;
	const sourceMtime = getSourceMtime(tsFilePath);
	return cached.sourceMtime === sourceMtime && existsSync(cached.compiledPath);
};
const buildWithEsbuild = async (tsFilePath, compiledPath) => {
	const result = await esbuild.build({
		entryPoints: [tsFilePath],
		bundle: false,
		format: "esm",
		target: "node18",
		platform: "node",
		outfile: compiledPath,
		sourcemap: "inline",
		write: false,
		resolveExtensions: [
			".ts",
			".tsx",
			".js",
			".jsx",
			".json"
		],
		packages: "external"
	});
	if (!result.outputFiles || result.outputFiles.length === 0) throw new Error(`Failed to compile ${tsFilePath}`);
	return result.outputFiles[0].text;
};
const compileDependencies = async (dependencies, projectRoot) => {
	for (const dep of dependencies) await compile(dep, projectRoot);
};
const updateCache = (tsFilePath, compiledPath) => {
	const sourceMtime = getSourceMtime(tsFilePath);
	cache.set(tsFilePath, {
		compiledPath,
		sourceMtime
	});
};
const compile = async (tsFilePath, projectRoot) => {
	const compiledPath = getCompiledPath(tsFilePath, projectRoot);
	if (isCacheValid(tsFilePath)) {
		const cached = cache.get(tsFilePath);
		if (cached) return cached.compiledPath;
	}
	ensureCompiledDir(compiledPath);
	const { code, dependencies } = transformImportPaths(await buildWithEsbuild(tsFilePath, compiledPath), tsFilePath, compiledPath, projectRoot);
	await compileDependencies(dependencies, projectRoot);
	writeFileSync(compiledPath, code, "utf-8");
	updateCache(tsFilePath, compiledPath);
	return compiledPath;
};
const invalidate = (tsFilePath) => {
	cache.delete(tsFilePath);
};

//#endregion
export { compile, invalidate };
//# sourceMappingURL=ts-compiler.mjs.map