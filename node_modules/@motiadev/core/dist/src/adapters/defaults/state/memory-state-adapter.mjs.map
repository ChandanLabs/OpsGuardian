{"version":3,"file":"memory-state-adapter.mjs","names":[],"sources":["../../../../../src/adapters/defaults/state/memory-state-adapter.ts"],"sourcesContent":["import type { StateAdapter, StateItem, StateItemsInput } from '../../interfaces/state-adapter.interface'\nimport { filterItem, inferType } from './utils'\n\nexport class MemoryStateAdapter implements StateAdapter {\n  private state: Record<string, unknown> = {}\n\n  constructor() {\n    this.state = {}\n  }\n\n  async getGroup<T>(groupId: string): Promise<T[]> {\n    return Object.entries(this.state)\n      .filter(([key]) => key.startsWith(groupId))\n      .map(([, value]) => value as T)\n  }\n\n  async get<T>(traceId: string, key: string): Promise<T | null> {\n    const fullKey = this._makeKey(traceId, key)\n\n    return this.state[fullKey] ? (this.state[fullKey] as T) : null\n  }\n\n  async set<T>(traceId: string, key: string, value: T) {\n    const fullKey = this._makeKey(traceId, key)\n\n    this.state[fullKey] = value\n\n    return value\n  }\n\n  async delete<T>(traceId: string, key: string): Promise<T | null> {\n    const fullKey = this._makeKey(traceId, key)\n    const value = await this.get<T>(traceId, key)\n\n    if (value) {\n      delete this.state[fullKey]\n    }\n\n    return value\n  }\n\n  async clear(traceId: string) {\n    const pattern = this._makeKey(traceId, '')\n\n    for (const key in this.state) {\n      if (key.startsWith(pattern)) {\n        delete this.state[key]\n      }\n    }\n  }\n\n  async keys(traceId: string) {\n    return Object.keys(this.state)\n      .filter((key) => key.startsWith(this._makeKey(traceId, '')))\n      .map((key) => key.replace(this._makeKey(traceId, ''), ''))\n  }\n\n  async traceIds() {\n    const traceIds = new Set<string>()\n\n    Object.keys(this.state).forEach((key) => traceIds.add(key.split(':')[0]))\n\n    return Array.from(traceIds)\n  }\n\n  async items(input: StateItemsInput): Promise<StateItem[]> {\n    return Object.entries(this.state)\n      .map(([key, value]) => {\n        const [groupId, ...keyParts] = key.split(':')\n        return {\n          groupId,\n          key: keyParts.join(':'),\n          type: inferType(value),\n          value: value as StateItem['value'],\n        }\n      })\n      .filter((item) => (input.groupId ? item.groupId === input.groupId : true))\n      .filter((item) => (input.filter ? filterItem(item, input.filter) : true))\n  }\n\n  async cleanup() {}\n\n  private _makeKey(traceId: string, key: string) {\n    return `${traceId}:${key}`\n  }\n}\n"],"mappings":";;;AAGA,IAAa,qBAAb,MAAwD;CAGtD,cAAc;eAF2B,EAAE;AAGzC,OAAK,QAAQ,EAAE;;CAGjB,MAAM,SAAY,SAA+B;AAC/C,SAAO,OAAO,QAAQ,KAAK,MAAM,CAC9B,QAAQ,CAAC,SAAS,IAAI,WAAW,QAAQ,CAAC,CAC1C,KAAK,GAAG,WAAW,MAAW;;CAGnC,MAAM,IAAO,SAAiB,KAAgC;EAC5D,MAAM,UAAU,KAAK,SAAS,SAAS,IAAI;AAE3C,SAAO,KAAK,MAAM,WAAY,KAAK,MAAM,WAAiB;;CAG5D,MAAM,IAAO,SAAiB,KAAa,OAAU;EACnD,MAAM,UAAU,KAAK,SAAS,SAAS,IAAI;AAE3C,OAAK,MAAM,WAAW;AAEtB,SAAO;;CAGT,MAAM,OAAU,SAAiB,KAAgC;EAC/D,MAAM,UAAU,KAAK,SAAS,SAAS,IAAI;EAC3C,MAAM,QAAQ,MAAM,KAAK,IAAO,SAAS,IAAI;AAE7C,MAAI,MACF,QAAO,KAAK,MAAM;AAGpB,SAAO;;CAGT,MAAM,MAAM,SAAiB;EAC3B,MAAM,UAAU,KAAK,SAAS,SAAS,GAAG;AAE1C,OAAK,MAAM,OAAO,KAAK,MACrB,KAAI,IAAI,WAAW,QAAQ,CACzB,QAAO,KAAK,MAAM;;CAKxB,MAAM,KAAK,SAAiB;AAC1B,SAAO,OAAO,KAAK,KAAK,MAAM,CAC3B,QAAQ,QAAQ,IAAI,WAAW,KAAK,SAAS,SAAS,GAAG,CAAC,CAAC,CAC3D,KAAK,QAAQ,IAAI,QAAQ,KAAK,SAAS,SAAS,GAAG,EAAE,GAAG,CAAC;;CAG9D,MAAM,WAAW;EACf,MAAM,2BAAW,IAAI,KAAa;AAElC,SAAO,KAAK,KAAK,MAAM,CAAC,SAAS,QAAQ,SAAS,IAAI,IAAI,MAAM,IAAI,CAAC,GAAG,CAAC;AAEzE,SAAO,MAAM,KAAK,SAAS;;CAG7B,MAAM,MAAM,OAA8C;AACxD,SAAO,OAAO,QAAQ,KAAK,MAAM,CAC9B,KAAK,CAAC,KAAK,WAAW;GACrB,MAAM,CAAC,SAAS,GAAG,YAAY,IAAI,MAAM,IAAI;AAC7C,UAAO;IACL;IACA,KAAK,SAAS,KAAK,IAAI;IACvB,MAAM,UAAU,MAAM;IACf;IACR;IACD,CACD,QAAQ,SAAU,MAAM,UAAU,KAAK,YAAY,MAAM,UAAU,KAAM,CACzE,QAAQ,SAAU,MAAM,SAAS,WAAW,MAAM,MAAM,OAAO,GAAG,KAAM;;CAG7E,MAAM,UAAU;CAEhB,AAAQ,SAAS,SAAiB,KAAa;AAC7C,SAAO,GAAG,QAAQ,GAAG"}