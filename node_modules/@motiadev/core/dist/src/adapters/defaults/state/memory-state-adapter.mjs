import { filterItem, inferType } from "./utils.mjs";

//#region src/adapters/defaults/state/memory-state-adapter.ts
var MemoryStateAdapter = class {
	constructor() {
		this.state = {};
		this.state = {};
	}
	async getGroup(groupId) {
		return Object.entries(this.state).filter(([key]) => key.startsWith(groupId)).map(([, value]) => value);
	}
	async get(traceId, key) {
		const fullKey = this._makeKey(traceId, key);
		return this.state[fullKey] ? this.state[fullKey] : null;
	}
	async set(traceId, key, value) {
		const fullKey = this._makeKey(traceId, key);
		this.state[fullKey] = value;
		return value;
	}
	async delete(traceId, key) {
		const fullKey = this._makeKey(traceId, key);
		const value = await this.get(traceId, key);
		if (value) delete this.state[fullKey];
		return value;
	}
	async clear(traceId) {
		const pattern = this._makeKey(traceId, "");
		for (const key in this.state) if (key.startsWith(pattern)) delete this.state[key];
	}
	async keys(traceId) {
		return Object.keys(this.state).filter((key) => key.startsWith(this._makeKey(traceId, ""))).map((key) => key.replace(this._makeKey(traceId, ""), ""));
	}
	async traceIds() {
		const traceIds = /* @__PURE__ */ new Set();
		Object.keys(this.state).forEach((key) => traceIds.add(key.split(":")[0]));
		return Array.from(traceIds);
	}
	async items(input) {
		return Object.entries(this.state).map(([key, value]) => {
			const [groupId, ...keyParts] = key.split(":");
			return {
				groupId,
				key: keyParts.join(":"),
				type: inferType(value),
				value
			};
		}).filter((item) => input.groupId ? item.groupId === input.groupId : true).filter((item) => input.filter ? filterItem(item, input.filter) : true);
	}
	async cleanup() {}
	_makeKey(traceId, key) {
		return `${traceId}:${key}`;
	}
};

//#endregion
export { MemoryStateAdapter };
//# sourceMappingURL=memory-state-adapter.mjs.map