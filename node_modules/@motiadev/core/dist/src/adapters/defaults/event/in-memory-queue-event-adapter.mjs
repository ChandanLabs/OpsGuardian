import { DEFAULT_QUEUE_CONFIG } from "../../../infrastructure-validator/defaults.mjs";
import { QueueManager } from "../../../queue-manager.mjs";
import { v4 } from "uuid";

//#region src/adapters/defaults/event/in-memory-queue-event-adapter.ts
var InMemoryQueueEventAdapter = class {
	constructor() {
		this.queueManager = new QueueManager();
		this.subscriptions = /* @__PURE__ */ new Map();
	}
	async emit(event) {
		await this.queueManager.enqueue(event.topic, event, event.messageGroupId);
	}
	async subscribe(topic, stepName, handler, queueConfig) {
		const id = v4();
		this.subscriptions.set(id, {
			topic,
			handler
		});
		const config = queueConfig || DEFAULT_QUEUE_CONFIG;
		this.queueManager.subscribe(topic, handler, config, id);
		const handle = {
			topic,
			id,
			unsubscribe: async () => {
				await this.unsubscribe(handle);
			}
		};
		return handle;
	}
	async unsubscribe(handle) {
		const subscription = this.subscriptions.get(handle.id);
		if (subscription) {
			this.queueManager.unsubscribe(handle.topic, subscription.handler);
			this.subscriptions.delete(handle.id);
		}
	}
	async shutdown() {
		this.subscriptions.clear();
	}
	async getSubscriptionCount(topic) {
		return Array.from(this.subscriptions.values()).filter((sub) => sub.topic === topic).length;
	}
	async listTopics() {
		return Array.from(new Set(Array.from(this.subscriptions.values()).map((sub) => sub.topic)));
	}
	getAllMetrics() {
		return this.queueManager.getAllMetrics();
	}
};

//#endregion
export { InMemoryQueueEventAdapter };
//# sourceMappingURL=in-memory-queue-event-adapter.mjs.map