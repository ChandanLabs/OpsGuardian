//#region src/step-handler-rpc-processor.ts
var RpcProcessor = class {
	constructor(child) {
		this.child = child;
		this.handlers = {};
		this.isClosed = false;
	}
	handler(method, handler) {
		this.handlers[method] = handler;
	}
	onMessage(callback) {
		this.messageCallback = callback;
	}
	async handle(method, input) {
		const handler = this.handlers[method];
		if (!handler) throw new Error(`Handler for method ${method} not found`);
		return handler(input);
	}
	response(id, result, error) {
		if (id && !this.isClosed && this.child.send && this.child.connected) {
			const responseMessage = {
				type: "rpc_response",
				id,
				result: error ? void 0 : result,
				error: error ? String(error) : void 0
			};
			this.child.send(responseMessage);
		}
	}
	async init() {
		this.child.on("message", (msg) => {
			if (this.messageCallback) this.messageCallback(msg);
			if (msg && msg.type === "rpc_request") {
				const { id, method, args } = msg;
				this.handle(method, args).then((result) => this.response(id, result, null)).catch((error) => this.response(id, null, error));
			}
		});
		this.child.on("exit", () => {
			this.isClosed = true;
		});
		this.child.on("close", () => {
			this.isClosed = true;
		});
		this.child.on("disconnect", () => {
			this.isClosed = true;
		});
	}
	close() {
		this.isClosed = true;
		this.messageCallback = void 0;
		this.handlers = {};
	}
};

//#endregion
export { RpcProcessor };
//# sourceMappingURL=step-handler-rpc-processor.mjs.map