import { globalLogger } from "./logger.mjs";
import { getRoom, sendAccessDenied, sendError } from "./socket-server/helpers.mjs";
import { WebSocket, WebSocketServer } from "ws";

//#region src/socket-server.ts
const AUTH_ERROR_CODE = 401;
const createSocketServer = ({ server, onJoin, onJoinGroup, authenticate, authorize }) => {
	const socketServer = new WebSocketServer({
		server,
		verifyClient: async (info, callback) => {
			if (authenticate) try {
				const authRequest = {
					headers: info.req.headers,
					url: info.req.url
				};
				info.req.authContext = await authenticate(authRequest);
				callback(true);
			} catch {
				globalLogger.debug("[Socket Server] Authentication failed");
				callback(false, AUTH_ERROR_CODE, "Authentication failed");
			}
			else callback(true);
		}
	});
	const rooms = {};
	const subscriptions = /* @__PURE__ */ new Map();
	const authContexts = /* @__PURE__ */ new Map();
	const isAuthorized = async (socket, data) => {
		if (!authorize) return true;
		try {
			return await authorize(data, authContexts.get(socket)) !== false;
		} catch (error) {
			sendError(socket, data, error);
			globalLogger.error("[Socket Server] Failed to authorize stream subscription");
			return false;
		}
	};
	socketServer.on("connection", async (socket, request) => {
		authContexts.set(socket, request.authContext);
		subscriptions.set(socket, /* @__PURE__ */ new Map());
		let messageQueue = Promise.resolve();
		const processMessage = async (message) => {
			if (message.type === "join") {
				if (!await isAuthorized(socket, message.data)) {
					sendAccessDenied(socket, message.data);
					return;
				}
				const room = getRoom(message.data);
				if (!rooms[room]) rooms[room] = /* @__PURE__ */ new Map();
				if (message.data.id) {
					const item = await onJoin(message.data.streamName, message.data.groupId, message.data.id);
					if (item) {
						const resultMessage = {
							timestamp: Date.now(),
							streamName: message.data.streamName,
							groupId: message.data.groupId,
							id: message.data.id,
							event: {
								type: "sync",
								data: item
							}
						};
						socket.send(JSON.stringify(resultMessage));
					}
				} else {
					const items = await onJoinGroup(message.data.streamName, message.data.groupId);
					if (items) {
						const resultMessage = {
							timestamp: Date.now(),
							streamName: message.data.streamName,
							groupId: message.data.groupId,
							event: {
								type: "sync",
								data: items
							}
						};
						socket.send(JSON.stringify(resultMessage));
					}
				}
				rooms[room].set(message.data.subscriptionId, socket);
				subscriptions.get(socket)?.set(message.data.subscriptionId, room);
			} else if (message.type === "leave") {
				if (!message.data.subscriptionId) {
					globalLogger.error("[Socket Server] Subscription ID is required for leave message");
					return;
				}
				const room = getRoom(message.data);
				if (rooms[room]) {
					rooms[room].delete(message.data.subscriptionId);
					if (rooms[room].size === 0) delete rooms[room];
				}
				subscriptions.get(socket)?.delete(message.data.subscriptionId);
			}
		};
		socket.on("message", (payload) => {
			const message = JSON.parse(payload.toString());
			messageQueue = messageQueue.then(() => processMessage(message)).catch((error) => {
				globalLogger.error("[Socket Server] Error processing message", error);
			});
		});
		socket.on("close", () => {
			subscriptions.get(socket)?.forEach((room, subscriptionId) => {
				rooms[room]?.delete(subscriptionId);
				if (rooms[room]?.size === 0) delete rooms[room];
			});
			subscriptions.delete(socket);
			authContexts.delete(socket);
		});
	});
	const pushEvent = (message) => {
		const { groupId, streamName, id } = message;
		const groupRoom = getRoom({
			streamName,
			groupId
		});
		const eventMessage = JSON.stringify({
			timestamp: Date.now(),
			...message
		});
		const safeSend = (socket) => {
			if (socket.readyState === WebSocket.OPEN) try {
				socket.send(eventMessage);
			} catch (error) {
				globalLogger.debug("[Socket Server] Failed to send message to socket", error);
			}
		};
		if (rooms[groupRoom]) rooms[groupRoom].forEach(safeSend);
		if (id) {
			const itemRoom = getRoom({
				groupId,
				streamName,
				id
			});
			if (rooms[itemRoom]) rooms[itemRoom].forEach(safeSend);
		}
	};
	return {
		pushEvent,
		socketServer
	};
};

//#endregion
export { createSocketServer };
//# sourceMappingURL=socket-server.mjs.map