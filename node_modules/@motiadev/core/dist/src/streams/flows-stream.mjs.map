{"version":3,"file":"flows-stream.mjs","names":["lockedData: LockedData"],"sources":["../../../src/streams/flows-stream.ts"],"sourcesContent":["import { StreamAdapter } from '../adapters/interfaces/stream-adapter.interface'\nimport { generateFlow } from '../helper/flows-helper'\nimport type { LockedData } from '../locked-data'\nimport { PLUGIN_FLOW_ID } from '../motia'\nimport type { FlowResponse } from '../types/flows-types'\n\nexport class FlowsStream extends StreamAdapter<FlowResponse> {\n  constructor(private readonly lockedData: LockedData) {\n    super('__motia.flows')\n  }\n\n  async get(_: string, id: string): Promise<FlowResponse | null> {\n    const flow = this.lockedData.flows[id]\n\n    if (!flow) {\n      return null\n    }\n\n    return generateFlow(id, flow.steps)\n  }\n\n  async delete(_: string): Promise<FlowResponse | null> {\n    return null\n  }\n\n  async set(_: string, __: string, data: FlowResponse): Promise<FlowResponse> {\n    return data\n  }\n\n  async getGroup(): Promise<FlowResponse[]> {\n    /**\n     * Get list should receive a groupId argument but that's irrelevant for this stream\n     * since we only have one group of flows.\n     */\n    return Object.entries(this.lockedData.flows)\n      .map(([id, flow]) => generateFlow(id, flow.steps))\n      .filter((flow) => flow.id !== PLUGIN_FLOW_ID)\n  }\n}\n"],"mappings":";;;;;AAMA,IAAa,cAAb,cAAiC,cAA4B;CAC3D,YAAY,AAAiBA,YAAwB;AACnD,QAAM,gBAAgB;EADK;;CAI7B,MAAM,IAAI,GAAW,IAA0C;EAC7D,MAAM,OAAO,KAAK,WAAW,MAAM;AAEnC,MAAI,CAAC,KACH,QAAO;AAGT,SAAO,aAAa,IAAI,KAAK,MAAM;;CAGrC,MAAM,OAAO,GAAyC;AACpD,SAAO;;CAGT,MAAM,IAAI,GAAW,IAAY,MAA2C;AAC1E,SAAO;;CAGT,MAAM,WAAoC;;;;;AAKxC,SAAO,OAAO,QAAQ,KAAK,WAAW,MAAM,CACzC,KAAK,CAAC,IAAI,UAAU,aAAa,IAAI,KAAK,MAAM,CAAC,CACjD,QAAQ,SAAS,KAAK,OAAO,eAAe"}