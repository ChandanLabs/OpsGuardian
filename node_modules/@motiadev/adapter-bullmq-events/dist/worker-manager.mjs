import { FIFO_CONCURRENCY, MILLISECONDS_PER_SECOND } from "./constants.mjs";
import { WorkerCreationError } from "./errors.mjs";
import { Worker } from "bullmq";
import { v4 } from "uuid";

//#region src/worker-manager.ts
var WorkerManager = class {
	constructor(connection, config, getQueueName, dlqManager) {
		this.workers = /* @__PURE__ */ new Map();
		this.topicSubscriptions = /* @__PURE__ */ new Map();
		this.connection = connection;
		this.config = config;
		this.getQueueName = getQueueName;
		this.dlqManager = dlqManager ?? null;
	}
	createWorker(topic, stepName, handler, options) {
		const id = v4();
		const queueName = this.getQueueName(topic, stepName);
		this.addTopicSubscription(topic, id);
		const concurrency = options?.type === "fifo" ? FIFO_CONCURRENCY : options?.concurrency || this.config.concurrency;
		const attempts = options?.maxRetries != null ? options.maxRetries + 1 : this.config.defaultJobOptions.attempts;
		const lockDuration = options?.visibilityTimeout ? options.visibilityTimeout * MILLISECONDS_PER_SECOND : void 0;
		const worker = new Worker(queueName, async (job) => {
			const eventData = job.data;
			await handler({
				topic: eventData.topic,
				data: eventData.data,
				traceId: eventData.traceId,
				flows: eventData.flows,
				messageGroupId: eventData.messageGroupId
			});
		}, {
			connection: this.connection,
			prefix: this.config.prefix,
			concurrency,
			lockDuration,
			removeOnComplete: this.config.defaultJobOptions.removeOnComplete,
			removeOnFail: this.config.defaultJobOptions.removeOnFail
		});
		this.setupWorkerHandlers(worker, topic, stepName, attempts ?? 3);
		const handle = {
			topic,
			id,
			unsubscribe: async () => {
				await this.removeWorker(handle.id);
			}
		};
		const workerInfo = {
			worker,
			topic,
			stepName,
			handle,
			queueConfig: options
		};
		this.workers.set(id, workerInfo);
		return handle;
	}
	getSubscribers(topic) {
		const subscriptionIds = this.topicSubscriptions.get(topic);
		if (!subscriptionIds || subscriptionIds.size === 0) return [];
		return Array.from(subscriptionIds).map((id) => this.workers.get(id)).filter((info) => info !== void 0).map((info) => ({
			topic: info.topic,
			stepName: info.stepName,
			queueConfig: info.queueConfig
		}));
	}
	getWorkerInfo(id) {
		return this.workers.get(id);
	}
	async removeWorker(id) {
		const workerInfo = this.workers.get(id);
		if (!workerInfo) return;
		this.removeTopicSubscription(workerInfo.topic, id);
		await workerInfo.worker.close();
		this.workers.delete(id);
	}
	async closeAll() {
		const promises = Array.from(this.workers.values()).map((info) => info.worker.close().catch((err) => {
			console.error(`[BullMQ] Error closing worker for topic ${info.topic}, step ${info.stepName}:`, err);
		}));
		await Promise.allSettled(promises);
		this.workers.clear();
		this.topicSubscriptions.clear();
	}
	getSubscriptionCount(topic) {
		return Array.from(this.workers.values()).filter((w) => w.topic === topic).length;
	}
	listTopics() {
		return Array.from(new Set(Array.from(this.workers.values()).map((w) => w.topic)));
	}
	addTopicSubscription(topic, id) {
		if (!this.topicSubscriptions.has(topic)) this.topicSubscriptions.set(topic, /* @__PURE__ */ new Set());
		this.topicSubscriptions.get(topic)?.add(id);
	}
	removeTopicSubscription(topic, id) {
		const subscriptions = this.topicSubscriptions.get(topic);
		if (subscriptions) {
			subscriptions.delete(id);
			if (subscriptions.size === 0) this.topicSubscriptions.delete(topic);
		}
	}
	setupWorkerHandlers(worker, topic, stepName, attempts) {
		worker.on("error", (err) => {
			const error = new WorkerCreationError(topic, stepName, err);
			console.error(`[BullMQ] Worker error for topic ${topic}, step ${stepName}:`, error);
		});
		worker.on("failed", async (job, err) => {
			if (job) {
				const attemptsMade = job.attemptsMade || 0;
				if (attemptsMade >= attempts) {
					if (this.dlqManager) {
						const eventData = job.data;
						const event = {
							topic: eventData.topic || topic,
							data: eventData.data,
							traceId: eventData.traceId || "unknown",
							...eventData.flows && { flows: eventData.flows },
							...eventData.messageGroupId && { messageGroupId: eventData.messageGroupId }
						};
						await this.dlqManager.moveToDLQ(topic, stepName, event, err, attemptsMade, job.id);
					}
				}
			}
		});
	}
};

//#endregion
export { WorkerManager };
//# sourceMappingURL=worker-manager.mjs.map