import { MILLISECONDS_PER_SECOND } from "./constants.mjs";
import { QueueCreationError } from "./errors.mjs";
import { Queue } from "bullmq";

//#region src/queue-manager.ts
var QueueManager = class {
	constructor(connection, config) {
		this.queues = /* @__PURE__ */ new Map();
		this.connection = connection;
		this.config = config;
	}
	getQueue(queueName) {
		if (!this.queues.has(queueName)) {
			const queue$1 = new Queue(queueName, {
				connection: this.connection,
				prefix: this.config.prefix,
				defaultJobOptions: this.config.defaultJobOptions
			});
			queue$1.on("error", (err) => {
				console.error(`[BullMQ] Queue error for ${queueName}:`, err);
			});
			this.queues.set(queueName, queue$1);
		}
		const queue = this.queues.get(queueName);
		if (!queue) throw new QueueCreationError(queueName);
		return queue;
	}
	getQueueName(topic, stepName) {
		return `${topic}.${stepName}`;
	}
	async enqueueToAll(event, subscribers) {
		const promises = subscribers.map((subscriber) => {
			const queueName = this.getQueueName(subscriber.topic, subscriber.stepName);
			const queue = this.getQueue(queueName);
			const jobId = event.messageGroupId ? `${queueName}.${event.messageGroupId}` : void 0;
			const jobData = {
				topic: event.topic,
				data: event.data,
				traceId: event.traceId,
				flows: event.flows,
				messageGroupId: event.messageGroupId
			};
			const maxRetries = subscriber.queueConfig?.maxRetries;
			const attempts = maxRetries != null ? maxRetries + 1 : this.config.defaultJobOptions.attempts;
			const delay = subscriber.queueConfig?.delaySeconds ? subscriber.queueConfig.delaySeconds * MILLISECONDS_PER_SECOND : void 0;
			const jobOptions = {
				jobId,
				attempts,
				backoff: this.config.defaultJobOptions.backoff,
				delay
			};
			return queue.add(event.topic, jobData, jobOptions).then(() => void 0);
		});
		await Promise.all(promises);
	}
	async closeQueue(queueName) {
		const queue = this.queues.get(queueName);
		if (queue) {
			await queue.close();
			this.queues.delete(queueName);
		}
	}
	async closeAll() {
		const promises = Array.from(this.queues.values()).map((queue) => queue.close().catch((err) => {
			console.error(`[BullMQ] Error closing queue:`, err);
		}));
		await Promise.allSettled(promises);
		this.queues.clear();
	}
	listQueueNames() {
		return Array.from(this.queues.keys());
	}
	getPrefix() {
		return this.config.prefix;
	}
	getConnection() {
		return this.connection;
	}
};

//#endregion
export { QueueManager };
//# sourceMappingURL=queue-manager.mjs.map